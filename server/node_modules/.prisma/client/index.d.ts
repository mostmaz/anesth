
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Admission
 * 
 */
export type Admission = $Result.DefaultSelection<Prisma.$AdmissionPayload>
/**
 * Model ClinicalNote
 * 
 */
export type ClinicalNote = $Result.DefaultSelection<Prisma.$ClinicalNotePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model VitalSign
 * 
 */
export type VitalSign = $Result.DefaultSelection<Prisma.$VitalSignPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model DrugCatalog
 * 
 */
export type DrugCatalog = $Result.DefaultSelection<Prisma.$DrugCatalogPayload>
/**
 * Model MedicationAdministration
 * 
 */
export type MedicationAdministration = $Result.DefaultSelection<Prisma.$MedicationAdministrationPayload>
/**
 * Model IntakeOutput
 * 
 */
export type IntakeOutput = $Result.DefaultSelection<Prisma.$IntakeOutputPayload>
/**
 * Model NurseCheckIn
 * 
 */
export type NurseCheckIn = $Result.DefaultSelection<Prisma.$NurseCheckInPayload>
/**
 * Model Governorate
 * 
 */
export type Governorate = $Result.DefaultSelection<Prisma.$GovernoratePayload>
/**
 * Model ClinicalOrder
 * 
 */
export type ClinicalOrder = $Result.DefaultSelection<Prisma.$ClinicalOrderPayload>
/**
 * Model SpecialistNote
 * 
 */
export type SpecialistNote = $Result.DefaultSelection<Prisma.$SpecialistNotePayload>
/**
 * Model Investigation
 * 
 */
export type Investigation = $Result.DefaultSelection<Prisma.$InvestigationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SENIOR: 'SENIOR',
  RESIDENT: 'RESIDENT',
  NURSE: 'NURSE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ShiftType: {
  DAY: 'DAY',
  NIGHT: 'NIGHT'
};

export type ShiftType = (typeof ShiftType)[keyof typeof ShiftType]


export const NoteType: {
  ADMISSION: 'ADMISSION',
  PROGRESS: 'PROGRESS',
  PROCEDURE: 'PROCEDURE',
  DISCHARGE: 'DISCHARGE',
  NURSING: 'NURSING',
  CONSULT: 'CONSULT',
  OTHER: 'OTHER'
};

export type NoteType = (typeof NoteType)[keyof typeof NoteType]


export const OrderStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  COMPLETED: 'COMPLETED',
  DISCONTINUED: 'DISCONTINUED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const OrderType: {
  MEDICATION: 'MEDICATION',
  LAB: 'LAB',
  IMAGING: 'IMAGING',
  PROTOCOL: 'PROTOCOL',
  NURSING: 'NURSING',
  DIET: 'DIET',
  CONSULT: 'CONSULT'
};

export type OrderType = (typeof OrderType)[keyof typeof OrderType]


export const Priority: {
  ROUTINE: 'ROUTINE',
  URGENT: 'URGENT',
  STAT: 'STAT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const InvestigationStatus: {
  PRELIMINARY: 'PRELIMINARY',
  FINAL: 'FINAL',
  AMENDED: 'AMENDED'
};

export type InvestigationStatus = (typeof InvestigationStatus)[keyof typeof InvestigationStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ShiftType = $Enums.ShiftType

export const ShiftType: typeof $Enums.ShiftType

export type NoteType = $Enums.NoteType

export const NoteType: typeof $Enums.NoteType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type OrderType = $Enums.OrderType

export const OrderType: typeof $Enums.OrderType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type InvestigationStatus = $Enums.InvestigationStatus

export const InvestigationStatus: typeof $Enums.InvestigationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admission`: Exposes CRUD operations for the **Admission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admission.findMany()
    * ```
    */
  get admission(): Prisma.AdmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicalNote`: Exposes CRUD operations for the **ClinicalNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicalNotes
    * const clinicalNotes = await prisma.clinicalNote.findMany()
    * ```
    */
  get clinicalNote(): Prisma.ClinicalNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vitalSign`: Exposes CRUD operations for the **VitalSign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitalSigns
    * const vitalSigns = await prisma.vitalSign.findMany()
    * ```
    */
  get vitalSign(): Prisma.VitalSignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drugCatalog`: Exposes CRUD operations for the **DrugCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DrugCatalogs
    * const drugCatalogs = await prisma.drugCatalog.findMany()
    * ```
    */
  get drugCatalog(): Prisma.DrugCatalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicationAdministration`: Exposes CRUD operations for the **MedicationAdministration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicationAdministrations
    * const medicationAdministrations = await prisma.medicationAdministration.findMany()
    * ```
    */
  get medicationAdministration(): Prisma.MedicationAdministrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intakeOutput`: Exposes CRUD operations for the **IntakeOutput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntakeOutputs
    * const intakeOutputs = await prisma.intakeOutput.findMany()
    * ```
    */
  get intakeOutput(): Prisma.IntakeOutputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nurseCheckIn`: Exposes CRUD operations for the **NurseCheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NurseCheckIns
    * const nurseCheckIns = await prisma.nurseCheckIn.findMany()
    * ```
    */
  get nurseCheckIn(): Prisma.NurseCheckInDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.governorate`: Exposes CRUD operations for the **Governorate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Governorates
    * const governorates = await prisma.governorate.findMany()
    * ```
    */
  get governorate(): Prisma.GovernorateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicalOrder`: Exposes CRUD operations for the **ClinicalOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicalOrders
    * const clinicalOrders = await prisma.clinicalOrder.findMany()
    * ```
    */
  get clinicalOrder(): Prisma.ClinicalOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialistNote`: Exposes CRUD operations for the **SpecialistNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecialistNotes
    * const specialistNotes = await prisma.specialistNote.findMany()
    * ```
    */
  get specialistNote(): Prisma.SpecialistNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investigation`: Exposes CRUD operations for the **Investigation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investigations
    * const investigations = await prisma.investigation.findMany()
    * ```
    */
  get investigation(): Prisma.InvestigationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Shift: 'Shift',
    Patient: 'Patient',
    Admission: 'Admission',
    ClinicalNote: 'ClinicalNote',
    AuditLog: 'AuditLog',
    VitalSign: 'VitalSign',
    Medication: 'Medication',
    DrugCatalog: 'DrugCatalog',
    MedicationAdministration: 'MedicationAdministration',
    IntakeOutput: 'IntakeOutput',
    NurseCheckIn: 'NurseCheckIn',
    Governorate: 'Governorate',
    ClinicalOrder: 'ClinicalOrder',
    SpecialistNote: 'SpecialistNote',
    Investigation: 'Investigation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "shift" | "patient" | "admission" | "clinicalNote" | "auditLog" | "vitalSign" | "medication" | "drugCatalog" | "medicationAdministration" | "intakeOutput" | "nurseCheckIn" | "governorate" | "clinicalOrder" | "specialistNote" | "investigation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Admission: {
        payload: Prisma.$AdmissionPayload<ExtArgs>
        fields: Prisma.AdmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findFirst: {
            args: Prisma.AdmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findMany: {
            args: Prisma.AdmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          create: {
            args: Prisma.AdmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          createMany: {
            args: Prisma.AdmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          delete: {
            args: Prisma.AdmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          update: {
            args: Prisma.AdmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          upsert: {
            args: Prisma.AdmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          aggregate: {
            args: Prisma.AdmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmission>
          }
          groupBy: {
            args: Prisma.AdmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionCountAggregateOutputType> | number
          }
        }
      }
      ClinicalNote: {
        payload: Prisma.$ClinicalNotePayload<ExtArgs>
        fields: Prisma.ClinicalNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicalNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicalNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          findFirst: {
            args: Prisma.ClinicalNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicalNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          findMany: {
            args: Prisma.ClinicalNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          create: {
            args: Prisma.ClinicalNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          createMany: {
            args: Prisma.ClinicalNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicalNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          delete: {
            args: Prisma.ClinicalNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          update: {
            args: Prisma.ClinicalNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          deleteMany: {
            args: Prisma.ClinicalNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicalNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicalNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          upsert: {
            args: Prisma.ClinicalNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          aggregate: {
            args: Prisma.ClinicalNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicalNote>
          }
          groupBy: {
            args: Prisma.ClinicalNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicalNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicalNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicalNoteCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      VitalSign: {
        payload: Prisma.$VitalSignPayload<ExtArgs>
        fields: Prisma.VitalSignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VitalSignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VitalSignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          findFirst: {
            args: Prisma.VitalSignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VitalSignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          findMany: {
            args: Prisma.VitalSignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          create: {
            args: Prisma.VitalSignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          createMany: {
            args: Prisma.VitalSignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VitalSignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          delete: {
            args: Prisma.VitalSignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          update: {
            args: Prisma.VitalSignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          deleteMany: {
            args: Prisma.VitalSignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VitalSignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VitalSignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>[]
          }
          upsert: {
            args: Prisma.VitalSignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignPayload>
          }
          aggregate: {
            args: Prisma.VitalSignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVitalSign>
          }
          groupBy: {
            args: Prisma.VitalSignGroupByArgs<ExtArgs>
            result: $Utils.Optional<VitalSignGroupByOutputType>[]
          }
          count: {
            args: Prisma.VitalSignCountArgs<ExtArgs>
            result: $Utils.Optional<VitalSignCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      DrugCatalog: {
        payload: Prisma.$DrugCatalogPayload<ExtArgs>
        fields: Prisma.DrugCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DrugCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrugCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>
          }
          findFirst: {
            args: Prisma.DrugCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrugCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>
          }
          findMany: {
            args: Prisma.DrugCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>[]
          }
          create: {
            args: Prisma.DrugCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>
          }
          createMany: {
            args: Prisma.DrugCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DrugCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>[]
          }
          delete: {
            args: Prisma.DrugCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>
          }
          update: {
            args: Prisma.DrugCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>
          }
          deleteMany: {
            args: Prisma.DrugCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DrugCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DrugCatalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>[]
          }
          upsert: {
            args: Prisma.DrugCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugCatalogPayload>
          }
          aggregate: {
            args: Prisma.DrugCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrugCatalog>
          }
          groupBy: {
            args: Prisma.DrugCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrugCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrugCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<DrugCatalogCountAggregateOutputType> | number
          }
        }
      }
      MedicationAdministration: {
        payload: Prisma.$MedicationAdministrationPayload<ExtArgs>
        fields: Prisma.MedicationAdministrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationAdministrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationAdministrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          findFirst: {
            args: Prisma.MedicationAdministrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationAdministrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          findMany: {
            args: Prisma.MedicationAdministrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>[]
          }
          create: {
            args: Prisma.MedicationAdministrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          createMany: {
            args: Prisma.MedicationAdministrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationAdministrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>[]
          }
          delete: {
            args: Prisma.MedicationAdministrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          update: {
            args: Prisma.MedicationAdministrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationAdministrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationAdministrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicationAdministrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>[]
          }
          upsert: {
            args: Prisma.MedicationAdministrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationAdministrationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAdministrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicationAdministration>
          }
          groupBy: {
            args: Prisma.MedicationAdministrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationAdministrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationAdministrationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationAdministrationCountAggregateOutputType> | number
          }
        }
      }
      IntakeOutput: {
        payload: Prisma.$IntakeOutputPayload<ExtArgs>
        fields: Prisma.IntakeOutputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntakeOutputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntakeOutputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>
          }
          findFirst: {
            args: Prisma.IntakeOutputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntakeOutputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>
          }
          findMany: {
            args: Prisma.IntakeOutputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>[]
          }
          create: {
            args: Prisma.IntakeOutputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>
          }
          createMany: {
            args: Prisma.IntakeOutputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntakeOutputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>[]
          }
          delete: {
            args: Prisma.IntakeOutputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>
          }
          update: {
            args: Prisma.IntakeOutputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>
          }
          deleteMany: {
            args: Prisma.IntakeOutputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntakeOutputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntakeOutputUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>[]
          }
          upsert: {
            args: Prisma.IntakeOutputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntakeOutputPayload>
          }
          aggregate: {
            args: Prisma.IntakeOutputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntakeOutput>
          }
          groupBy: {
            args: Prisma.IntakeOutputGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntakeOutputGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntakeOutputCountArgs<ExtArgs>
            result: $Utils.Optional<IntakeOutputCountAggregateOutputType> | number
          }
        }
      }
      NurseCheckIn: {
        payload: Prisma.$NurseCheckInPayload<ExtArgs>
        fields: Prisma.NurseCheckInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NurseCheckInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NurseCheckInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>
          }
          findFirst: {
            args: Prisma.NurseCheckInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NurseCheckInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>
          }
          findMany: {
            args: Prisma.NurseCheckInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>[]
          }
          create: {
            args: Prisma.NurseCheckInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>
          }
          createMany: {
            args: Prisma.NurseCheckInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NurseCheckInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>[]
          }
          delete: {
            args: Prisma.NurseCheckInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>
          }
          update: {
            args: Prisma.NurseCheckInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>
          }
          deleteMany: {
            args: Prisma.NurseCheckInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NurseCheckInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NurseCheckInUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>[]
          }
          upsert: {
            args: Prisma.NurseCheckInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseCheckInPayload>
          }
          aggregate: {
            args: Prisma.NurseCheckInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNurseCheckIn>
          }
          groupBy: {
            args: Prisma.NurseCheckInGroupByArgs<ExtArgs>
            result: $Utils.Optional<NurseCheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.NurseCheckInCountArgs<ExtArgs>
            result: $Utils.Optional<NurseCheckInCountAggregateOutputType> | number
          }
        }
      }
      Governorate: {
        payload: Prisma.$GovernoratePayload<ExtArgs>
        fields: Prisma.GovernorateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GovernorateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GovernorateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>
          }
          findFirst: {
            args: Prisma.GovernorateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GovernorateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>
          }
          findMany: {
            args: Prisma.GovernorateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>[]
          }
          create: {
            args: Prisma.GovernorateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>
          }
          createMany: {
            args: Prisma.GovernorateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GovernorateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>[]
          }
          delete: {
            args: Prisma.GovernorateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>
          }
          update: {
            args: Prisma.GovernorateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>
          }
          deleteMany: {
            args: Prisma.GovernorateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GovernorateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GovernorateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>[]
          }
          upsert: {
            args: Prisma.GovernorateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernoratePayload>
          }
          aggregate: {
            args: Prisma.GovernorateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGovernorate>
          }
          groupBy: {
            args: Prisma.GovernorateGroupByArgs<ExtArgs>
            result: $Utils.Optional<GovernorateGroupByOutputType>[]
          }
          count: {
            args: Prisma.GovernorateCountArgs<ExtArgs>
            result: $Utils.Optional<GovernorateCountAggregateOutputType> | number
          }
        }
      }
      ClinicalOrder: {
        payload: Prisma.$ClinicalOrderPayload<ExtArgs>
        fields: Prisma.ClinicalOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicalOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicalOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>
          }
          findFirst: {
            args: Prisma.ClinicalOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicalOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>
          }
          findMany: {
            args: Prisma.ClinicalOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>[]
          }
          create: {
            args: Prisma.ClinicalOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>
          }
          createMany: {
            args: Prisma.ClinicalOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicalOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>[]
          }
          delete: {
            args: Prisma.ClinicalOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>
          }
          update: {
            args: Prisma.ClinicalOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>
          }
          deleteMany: {
            args: Prisma.ClinicalOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicalOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicalOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>[]
          }
          upsert: {
            args: Prisma.ClinicalOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalOrderPayload>
          }
          aggregate: {
            args: Prisma.ClinicalOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicalOrder>
          }
          groupBy: {
            args: Prisma.ClinicalOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicalOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicalOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicalOrderCountAggregateOutputType> | number
          }
        }
      }
      SpecialistNote: {
        payload: Prisma.$SpecialistNotePayload<ExtArgs>
        fields: Prisma.SpecialistNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialistNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialistNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>
          }
          findFirst: {
            args: Prisma.SpecialistNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialistNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>
          }
          findMany: {
            args: Prisma.SpecialistNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>[]
          }
          create: {
            args: Prisma.SpecialistNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>
          }
          createMany: {
            args: Prisma.SpecialistNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialistNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>[]
          }
          delete: {
            args: Prisma.SpecialistNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>
          }
          update: {
            args: Prisma.SpecialistNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>
          }
          deleteMany: {
            args: Prisma.SpecialistNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialistNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecialistNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>[]
          }
          upsert: {
            args: Prisma.SpecialistNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialistNotePayload>
          }
          aggregate: {
            args: Prisma.SpecialistNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialistNote>
          }
          groupBy: {
            args: Prisma.SpecialistNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialistNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialistNoteCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialistNoteCountAggregateOutputType> | number
          }
        }
      }
      Investigation: {
        payload: Prisma.$InvestigationPayload<ExtArgs>
        fields: Prisma.InvestigationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestigationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestigationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          findFirst: {
            args: Prisma.InvestigationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestigationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          findMany: {
            args: Prisma.InvestigationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>[]
          }
          create: {
            args: Prisma.InvestigationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          createMany: {
            args: Prisma.InvestigationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestigationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>[]
          }
          delete: {
            args: Prisma.InvestigationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          update: {
            args: Prisma.InvestigationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          deleteMany: {
            args: Prisma.InvestigationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestigationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestigationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>[]
          }
          upsert: {
            args: Prisma.InvestigationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationPayload>
          }
          aggregate: {
            args: Prisma.InvestigationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestigation>
          }
          groupBy: {
            args: Prisma.InvestigationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestigationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestigationCountArgs<ExtArgs>
            result: $Utils.Optional<InvestigationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    shift?: ShiftOmit
    patient?: PatientOmit
    admission?: AdmissionOmit
    clinicalNote?: ClinicalNoteOmit
    auditLog?: AuditLogOmit
    vitalSign?: VitalSignOmit
    medication?: MedicationOmit
    drugCatalog?: DrugCatalogOmit
    medicationAdministration?: MedicationAdministrationOmit
    intakeOutput?: IntakeOutputOmit
    nurseCheckIn?: NurseCheckInOmit
    governorate?: GovernorateOmit
    clinicalOrder?: ClinicalOrderOmit
    specialistNote?: SpecialistNoteOmit
    investigation?: InvestigationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    shifts: number
    notes: number
    audits: number
    ioEntries: number
    checkIns: number
    createdOrders: number
    approvedOrders: number
    investigations: number
    specialistNotes: number
    administeredMeds: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | UserCountOutputTypeCountShiftsArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    audits?: boolean | UserCountOutputTypeCountAuditsArgs
    ioEntries?: boolean | UserCountOutputTypeCountIoEntriesArgs
    checkIns?: boolean | UserCountOutputTypeCountCheckInsArgs
    createdOrders?: boolean | UserCountOutputTypeCountCreatedOrdersArgs
    approvedOrders?: boolean | UserCountOutputTypeCountApprovedOrdersArgs
    investigations?: boolean | UserCountOutputTypeCountInvestigationsArgs
    specialistNotes?: boolean | UserCountOutputTypeCountSpecialistNotesArgs
    administeredMeds?: boolean | UserCountOutputTypeCountAdministeredMedsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIoEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntakeOutputWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseCheckInWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvestigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestigationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpecialistNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialistNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdministeredMedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationAdministrationWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    ioEntries: number
    checkIns: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ioEntries?: boolean | ShiftCountOutputTypeCountIoEntriesArgs
    checkIns?: boolean | ShiftCountOutputTypeCountCheckInsArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountIoEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntakeOutputWhereInput
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseCheckInWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    admissions: number
    notes: number
    vitals: number
    medications: number
    prescriptions: number
    ioEntries: number
    checkIns: number
    orders: number
    investigations: number
    specialistNotes: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissions?: boolean | PatientCountOutputTypeCountAdmissionsArgs
    notes?: boolean | PatientCountOutputTypeCountNotesArgs
    vitals?: boolean | PatientCountOutputTypeCountVitalsArgs
    medications?: boolean | PatientCountOutputTypeCountMedicationsArgs
    prescriptions?: boolean | PatientCountOutputTypeCountPrescriptionsArgs
    ioEntries?: boolean | PatientCountOutputTypeCountIoEntriesArgs
    checkIns?: boolean | PatientCountOutputTypeCountCheckInsArgs
    orders?: boolean | PatientCountOutputTypeCountOrdersArgs
    investigations?: boolean | PatientCountOutputTypeCountInvestigationsArgs
    specialistNotes?: boolean | PatientCountOutputTypeCountSpecialistNotesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountVitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationAdministrationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountIoEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntakeOutputWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseCheckInWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalOrderWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvestigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestigationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountSpecialistNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialistNoteWhereInput
  }


  /**
   * Count Type MedicationCountOutputType
   */

  export type MedicationCountOutputType = {
    administrations: number
  }

  export type MedicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrations?: boolean | MedicationCountOutputTypeCountAdministrationsArgs
  }

  // Custom InputTypes
  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationCountOutputType
     */
    select?: MedicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeCountAdministrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationAdministrationWhereInput
  }


  /**
   * Count Type ClinicalOrderCountOutputType
   */

  export type ClinicalOrderCountOutputType = {
    investigations: number
  }

  export type ClinicalOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investigations?: boolean | ClinicalOrderCountOutputTypeCountInvestigationsArgs
  }

  // Custom InputTypes
  /**
   * ClinicalOrderCountOutputType without action
   */
  export type ClinicalOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrderCountOutputType
     */
    select?: ClinicalOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicalOrderCountOutputType without action
   */
  export type ClinicalOrderCountOutputTypeCountInvestigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestigationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    username: number
    passwordHash: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shifts?: boolean | User$shiftsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    ioEntries?: boolean | User$ioEntriesArgs<ExtArgs>
    checkIns?: boolean | User$checkInsArgs<ExtArgs>
    createdOrders?: boolean | User$createdOrdersArgs<ExtArgs>
    approvedOrders?: boolean | User$approvedOrdersArgs<ExtArgs>
    investigations?: boolean | User$investigationsArgs<ExtArgs>
    specialistNotes?: boolean | User$specialistNotesArgs<ExtArgs>
    administeredMeds?: boolean | User$administeredMedsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "passwordHash" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | User$shiftsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    audits?: boolean | User$auditsArgs<ExtArgs>
    ioEntries?: boolean | User$ioEntriesArgs<ExtArgs>
    checkIns?: boolean | User$checkInsArgs<ExtArgs>
    createdOrders?: boolean | User$createdOrdersArgs<ExtArgs>
    approvedOrders?: boolean | User$approvedOrdersArgs<ExtArgs>
    investigations?: boolean | User$investigationsArgs<ExtArgs>
    specialistNotes?: boolean | User$specialistNotesArgs<ExtArgs>
    administeredMeds?: boolean | User$administeredMedsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      notes: Prisma.$ClinicalNotePayload<ExtArgs>[]
      audits: Prisma.$AuditLogPayload<ExtArgs>[]
      ioEntries: Prisma.$IntakeOutputPayload<ExtArgs>[]
      checkIns: Prisma.$NurseCheckInPayload<ExtArgs>[]
      createdOrders: Prisma.$ClinicalOrderPayload<ExtArgs>[]
      approvedOrders: Prisma.$ClinicalOrderPayload<ExtArgs>[]
      investigations: Prisma.$InvestigationPayload<ExtArgs>[]
      specialistNotes: Prisma.$SpecialistNotePayload<ExtArgs>[]
      administeredMeds: Prisma.$MedicationAdministrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      passwordHash: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shifts<T extends User$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, User$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audits<T extends User$auditsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ioEntries<T extends User$ioEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$ioEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkIns<T extends User$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, User$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdOrders<T extends User$createdOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedOrders<T extends User$approvedOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investigations<T extends User$investigationsArgs<ExtArgs> = {}>(args?: Subset<T, User$investigationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialistNotes<T extends User$specialistNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$specialistNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    administeredMeds<T extends User$administeredMedsArgs<ExtArgs> = {}>(args?: Subset<T, User$administeredMedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.shifts
   */
  export type User$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    cursor?: ClinicalNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * User.audits
   */
  export type User$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.ioEntries
   */
  export type User$ioEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    where?: IntakeOutputWhereInput
    orderBy?: IntakeOutputOrderByWithRelationInput | IntakeOutputOrderByWithRelationInput[]
    cursor?: IntakeOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntakeOutputScalarFieldEnum | IntakeOutputScalarFieldEnum[]
  }

  /**
   * User.checkIns
   */
  export type User$checkInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    where?: NurseCheckInWhereInput
    orderBy?: NurseCheckInOrderByWithRelationInput | NurseCheckInOrderByWithRelationInput[]
    cursor?: NurseCheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseCheckInScalarFieldEnum | NurseCheckInScalarFieldEnum[]
  }

  /**
   * User.createdOrders
   */
  export type User$createdOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    where?: ClinicalOrderWhereInput
    orderBy?: ClinicalOrderOrderByWithRelationInput | ClinicalOrderOrderByWithRelationInput[]
    cursor?: ClinicalOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalOrderScalarFieldEnum | ClinicalOrderScalarFieldEnum[]
  }

  /**
   * User.approvedOrders
   */
  export type User$approvedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    where?: ClinicalOrderWhereInput
    orderBy?: ClinicalOrderOrderByWithRelationInput | ClinicalOrderOrderByWithRelationInput[]
    cursor?: ClinicalOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalOrderScalarFieldEnum | ClinicalOrderScalarFieldEnum[]
  }

  /**
   * User.investigations
   */
  export type User$investigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    where?: InvestigationWhereInput
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    cursor?: InvestigationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * User.specialistNotes
   */
  export type User$specialistNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    where?: SpecialistNoteWhereInput
    orderBy?: SpecialistNoteOrderByWithRelationInput | SpecialistNoteOrderByWithRelationInput[]
    cursor?: SpecialistNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialistNoteScalarFieldEnum | SpecialistNoteScalarFieldEnum[]
  }

  /**
   * User.administeredMeds
   */
  export type User$administeredMedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    where?: MedicationAdministrationWhereInput
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    cursor?: MedicationAdministrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ShiftType | null
    startTime: Date | null
    endTime: Date | null
    isActive: boolean | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ShiftType | null
    startTime: Date | null
    endTime: Date | null
    isActive: boolean | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    startTime: number
    endTime: number
    isActive: number
    _all: number
  }


  export type ShiftMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    startTime?: true
    endTime?: true
    isActive?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    startTime?: true
    endTime?: true
    isActive?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    startTime?: true
    endTime?: true
    isActive?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ShiftType
    startTime: Date
    endTime: Date | null
    isActive: boolean
    _count: ShiftCountAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ioEntries?: boolean | Shift$ioEntriesArgs<ExtArgs>
    checkIns?: boolean | Shift$checkInsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "startTime" | "endTime" | "isActive", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ioEntries?: boolean | Shift$ioEntriesArgs<ExtArgs>
    checkIns?: boolean | Shift$checkInsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ioEntries: Prisma.$IntakeOutputPayload<ExtArgs>[]
      checkIns: Prisma.$NurseCheckInPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ShiftType
      startTime: Date
      endTime: Date | null
      isActive: boolean
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ioEntries<T extends Shift$ioEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Shift$ioEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkIns<T extends Shift$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, Shift$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly userId: FieldRef<"Shift", 'String'>
    readonly type: FieldRef<"Shift", 'ShiftType'>
    readonly startTime: FieldRef<"Shift", 'DateTime'>
    readonly endTime: FieldRef<"Shift", 'DateTime'>
    readonly isActive: FieldRef<"Shift", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift.ioEntries
   */
  export type Shift$ioEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    where?: IntakeOutputWhereInput
    orderBy?: IntakeOutputOrderByWithRelationInput | IntakeOutputOrderByWithRelationInput[]
    cursor?: IntakeOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntakeOutputScalarFieldEnum | IntakeOutputScalarFieldEnum[]
  }

  /**
   * Shift.checkIns
   */
  export type Shift$checkInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    where?: NurseCheckInWhereInput
    orderBy?: NurseCheckInOrderByWithRelationInput | NurseCheckInOrderByWithRelationInput[]
    cursor?: NurseCheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseCheckInScalarFieldEnum | NurseCheckInScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    mrn: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    gender: string | null
    diagnosis: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    mrn: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    gender: string | null
    diagnosis: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    mrn: number
    firstName: number
    lastName: number
    dob: number
    gender: number
    comorbidities: number
    diagnosis: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    mrn?: true
    firstName?: true
    lastName?: true
    dob?: true
    gender?: true
    diagnosis?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    mrn?: true
    firstName?: true
    lastName?: true
    dob?: true
    gender?: true
    diagnosis?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    mrn?: true
    firstName?: true
    lastName?: true
    dob?: true
    gender?: true
    comorbidities?: true
    diagnosis?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date
    gender: string
    comorbidities: string[]
    diagnosis: string | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrn?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    comorbidities?: boolean
    diagnosis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admissions?: boolean | Patient$admissionsArgs<ExtArgs>
    notes?: boolean | Patient$notesArgs<ExtArgs>
    vitals?: boolean | Patient$vitalsArgs<ExtArgs>
    medications?: boolean | Patient$medicationsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    ioEntries?: boolean | Patient$ioEntriesArgs<ExtArgs>
    checkIns?: boolean | Patient$checkInsArgs<ExtArgs>
    orders?: boolean | Patient$ordersArgs<ExtArgs>
    investigations?: boolean | Patient$investigationsArgs<ExtArgs>
    specialistNotes?: boolean | Patient$specialistNotesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrn?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    comorbidities?: boolean
    diagnosis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mrn?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    comorbidities?: boolean
    diagnosis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    mrn?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    comorbidities?: boolean
    diagnosis?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mrn" | "firstName" | "lastName" | "dob" | "gender" | "comorbidities" | "diagnosis" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissions?: boolean | Patient$admissionsArgs<ExtArgs>
    notes?: boolean | Patient$notesArgs<ExtArgs>
    vitals?: boolean | Patient$vitalsArgs<ExtArgs>
    medications?: boolean | Patient$medicationsArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    ioEntries?: boolean | Patient$ioEntriesArgs<ExtArgs>
    checkIns?: boolean | Patient$checkInsArgs<ExtArgs>
    orders?: boolean | Patient$ordersArgs<ExtArgs>
    investigations?: boolean | Patient$investigationsArgs<ExtArgs>
    specialistNotes?: boolean | Patient$specialistNotesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
      notes: Prisma.$ClinicalNotePayload<ExtArgs>[]
      vitals: Prisma.$VitalSignPayload<ExtArgs>[]
      medications: Prisma.$MedicationAdministrationPayload<ExtArgs>[]
      prescriptions: Prisma.$MedicationPayload<ExtArgs>[]
      ioEntries: Prisma.$IntakeOutputPayload<ExtArgs>[]
      checkIns: Prisma.$NurseCheckInPayload<ExtArgs>[]
      orders: Prisma.$ClinicalOrderPayload<ExtArgs>[]
      investigations: Prisma.$InvestigationPayload<ExtArgs>[]
      specialistNotes: Prisma.$SpecialistNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mrn: string
      firstName: string
      lastName: string
      dob: Date
      gender: string
      comorbidities: string[]
      diagnosis: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admissions<T extends Patient$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Patient$notesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vitals<T extends Patient$vitalsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$vitalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medications<T extends Patient$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Patient$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ioEntries<T extends Patient$ioEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$ioEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkIns<T extends Patient$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Patient$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investigations<T extends Patient$investigationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$investigationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialistNotes<T extends Patient$specialistNotesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$specialistNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly mrn: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly dob: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly comorbidities: FieldRef<"Patient", 'String[]'>
    readonly diagnosis: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.admissions
   */
  export type Patient$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Patient.notes
   */
  export type Patient$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    cursor?: ClinicalNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * Patient.vitals
   */
  export type Patient$vitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    cursor?: VitalSignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * Patient.medications
   */
  export type Patient$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    where?: MedicationAdministrationWhereInput
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    cursor?: MedicationAdministrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * Patient.prescriptions
   */
  export type Patient$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Patient.ioEntries
   */
  export type Patient$ioEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    where?: IntakeOutputWhereInput
    orderBy?: IntakeOutputOrderByWithRelationInput | IntakeOutputOrderByWithRelationInput[]
    cursor?: IntakeOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntakeOutputScalarFieldEnum | IntakeOutputScalarFieldEnum[]
  }

  /**
   * Patient.checkIns
   */
  export type Patient$checkInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    where?: NurseCheckInWhereInput
    orderBy?: NurseCheckInOrderByWithRelationInput | NurseCheckInOrderByWithRelationInput[]
    cursor?: NurseCheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseCheckInScalarFieldEnum | NurseCheckInScalarFieldEnum[]
  }

  /**
   * Patient.orders
   */
  export type Patient$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    where?: ClinicalOrderWhereInput
    orderBy?: ClinicalOrderOrderByWithRelationInput | ClinicalOrderOrderByWithRelationInput[]
    cursor?: ClinicalOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalOrderScalarFieldEnum | ClinicalOrderScalarFieldEnum[]
  }

  /**
   * Patient.investigations
   */
  export type Patient$investigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    where?: InvestigationWhereInput
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    cursor?: InvestigationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Patient.specialistNotes
   */
  export type Patient$specialistNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    where?: SpecialistNoteWhereInput
    orderBy?: SpecialistNoteOrderByWithRelationInput | SpecialistNoteOrderByWithRelationInput[]
    cursor?: SpecialistNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialistNoteScalarFieldEnum | SpecialistNoteScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Admission
   */

  export type AggregateAdmission = {
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  export type AdmissionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    bed: string | null
    diagnosis: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
  }

  export type AdmissionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    bed: string | null
    diagnosis: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
  }

  export type AdmissionCountAggregateOutputType = {
    id: number
    patientId: number
    bed: number
    diagnosis: number
    admittedAt: number
    dischargedAt: number
    _all: number
  }


  export type AdmissionMinAggregateInputType = {
    id?: true
    patientId?: true
    bed?: true
    diagnosis?: true
    admittedAt?: true
    dischargedAt?: true
  }

  export type AdmissionMaxAggregateInputType = {
    id?: true
    patientId?: true
    bed?: true
    diagnosis?: true
    admittedAt?: true
    dischargedAt?: true
  }

  export type AdmissionCountAggregateInputType = {
    id?: true
    patientId?: true
    bed?: true
    diagnosis?: true
    admittedAt?: true
    dischargedAt?: true
    _all?: true
  }

  export type AdmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admission to aggregate.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admissions
    **/
    _count?: true | AdmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionMaxAggregateInputType
  }

  export type GetAdmissionAggregateType<T extends AdmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmission[P]>
      : GetScalarType<T[P], AggregateAdmission[P]>
  }




  export type AdmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithAggregationInput | AdmissionOrderByWithAggregationInput[]
    by: AdmissionScalarFieldEnum[] | AdmissionScalarFieldEnum
    having?: AdmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionCountAggregateInputType | true
    _min?: AdmissionMinAggregateInputType
    _max?: AdmissionMaxAggregateInputType
  }

  export type AdmissionGroupByOutputType = {
    id: string
    patientId: string
    bed: string | null
    diagnosis: string | null
    admittedAt: Date
    dischargedAt: Date | null
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  type GetAdmissionGroupByPayload<T extends AdmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    bed?: boolean
    diagnosis?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    bed?: boolean
    diagnosis?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    bed?: boolean
    diagnosis?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectScalar = {
    id?: boolean
    patientId?: boolean
    bed?: boolean
    diagnosis?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
  }

  export type AdmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "bed" | "diagnosis" | "admittedAt" | "dischargedAt", ExtArgs["result"]["admission"]>
  export type AdmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AdmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AdmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AdmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admission"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      bed: string | null
      diagnosis: string | null
      admittedAt: Date
      dischargedAt: Date | null
    }, ExtArgs["result"]["admission"]>
    composites: {}
  }

  type AdmissionGetPayload<S extends boolean | null | undefined | AdmissionDefaultArgs> = $Result.GetResult<Prisma.$AdmissionPayload, S>

  type AdmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmissionCountAggregateInputType | true
    }

  export interface AdmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admission'], meta: { name: 'Admission' } }
    /**
     * Find zero or one Admission that matches the filter.
     * @param {AdmissionFindUniqueArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionFindUniqueArgs>(args: SelectSubset<T, AdmissionFindUniqueArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdmissionFindUniqueOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionFindFirstArgs>(args?: SelectSubset<T, AdmissionFindFirstArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admission.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionWithIdOnly = await prisma.admission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionFindManyArgs>(args?: SelectSubset<T, AdmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admission.
     * @param {AdmissionCreateArgs} args - Arguments to create a Admission.
     * @example
     * // Create one Admission
     * const Admission = await prisma.admission.create({
     *   data: {
     *     // ... data to create a Admission
     *   }
     * })
     * 
     */
    create<T extends AdmissionCreateArgs>(args: SelectSubset<T, AdmissionCreateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admissions.
     * @param {AdmissionCreateManyArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionCreateManyArgs>(args?: SelectSubset<T, AdmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admissions and returns the data saved in the database.
     * @param {AdmissionCreateManyAndReturnArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admissions and only return the `id`
     * const admissionWithIdOnly = await prisma.admission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admission.
     * @param {AdmissionDeleteArgs} args - Arguments to delete one Admission.
     * @example
     * // Delete one Admission
     * const Admission = await prisma.admission.delete({
     *   where: {
     *     // ... filter to delete one Admission
     *   }
     * })
     * 
     */
    delete<T extends AdmissionDeleteArgs>(args: SelectSubset<T, AdmissionDeleteArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admission.
     * @param {AdmissionUpdateArgs} args - Arguments to update one Admission.
     * @example
     * // Update one Admission
     * const admission = await prisma.admission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionUpdateArgs>(args: SelectSubset<T, AdmissionUpdateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admissions.
     * @param {AdmissionDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionDeleteManyArgs>(args?: SelectSubset<T, AdmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionUpdateManyArgs>(args: SelectSubset<T, AdmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions and returns the data updated in the database.
     * @param {AdmissionUpdateManyAndReturnArgs} args - Arguments to update many Admissions.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admissions and only return the `id`
     * const admissionWithIdOnly = await prisma.admission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admission.
     * @param {AdmissionUpsertArgs} args - Arguments to update or create a Admission.
     * @example
     * // Update or create a Admission
     * const admission = await prisma.admission.upsert({
     *   create: {
     *     // ... data to create a Admission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admission we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionUpsertArgs>(args: SelectSubset<T, AdmissionUpsertArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admission.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends AdmissionCountArgs>(
      args?: Subset<T, AdmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionAggregateArgs>(args: Subset<T, AdmissionAggregateArgs>): Prisma.PrismaPromise<GetAdmissionAggregateType<T>>

    /**
     * Group by Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admission model
   */
  readonly fields: AdmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admission model
   */
  interface AdmissionFieldRefs {
    readonly id: FieldRef<"Admission", 'String'>
    readonly patientId: FieldRef<"Admission", 'String'>
    readonly bed: FieldRef<"Admission", 'String'>
    readonly diagnosis: FieldRef<"Admission", 'String'>
    readonly admittedAt: FieldRef<"Admission", 'DateTime'>
    readonly dischargedAt: FieldRef<"Admission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admission findUnique
   */
  export type AdmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findUniqueOrThrow
   */
  export type AdmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findFirst
   */
  export type AdmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findFirstOrThrow
   */
  export type AdmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findMany
   */
  export type AdmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admissions to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission create
   */
  export type AdmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Admission.
     */
    data: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
  }

  /**
   * Admission createMany
   */
  export type AdmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admission createManyAndReturn
   */
  export type AdmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admission update
   */
  export type AdmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Admission.
     */
    data: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
    /**
     * Choose, which Admission to update.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission updateMany
   */
  export type AdmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
    /**
     * Limit how many Admissions to update.
     */
    limit?: number
  }

  /**
   * Admission updateManyAndReturn
   */
  export type AdmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
    /**
     * Limit how many Admissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admission upsert
   */
  export type AdmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Admission to update in case it exists.
     */
    where: AdmissionWhereUniqueInput
    /**
     * In case the Admission found by the `where` argument doesn't exist, create a new Admission with this data.
     */
    create: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
    /**
     * In case the Admission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
  }

  /**
   * Admission delete
   */
  export type AdmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter which Admission to delete.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission deleteMany
   */
  export type AdmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admissions to delete
     */
    where?: AdmissionWhereInput
    /**
     * Limit how many Admissions to delete.
     */
    limit?: number
  }

  /**
   * Admission without action
   */
  export type AdmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
  }


  /**
   * Model ClinicalNote
   */

  export type AggregateClinicalNote = {
    _count: ClinicalNoteCountAggregateOutputType | null
    _min: ClinicalNoteMinAggregateOutputType | null
    _max: ClinicalNoteMaxAggregateOutputType | null
  }

  export type ClinicalNoteMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    authorId: string | null
    type: $Enums.NoteType | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicalNoteMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    authorId: string | null
    type: $Enums.NoteType | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicalNoteCountAggregateOutputType = {
    id: number
    patientId: number
    authorId: number
    type: number
    title: number
    content: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicalNoteMinAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    type?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicalNoteMaxAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    type?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicalNoteCountAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    type?: true
    title?: true
    content?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicalNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalNote to aggregate.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicalNotes
    **/
    _count?: true | ClinicalNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicalNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicalNoteMaxAggregateInputType
  }

  export type GetClinicalNoteAggregateType<T extends ClinicalNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicalNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicalNote[P]>
      : GetScalarType<T[P], AggregateClinicalNote[P]>
  }




  export type ClinicalNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithAggregationInput | ClinicalNoteOrderByWithAggregationInput[]
    by: ClinicalNoteScalarFieldEnum[] | ClinicalNoteScalarFieldEnum
    having?: ClinicalNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicalNoteCountAggregateInputType | true
    _min?: ClinicalNoteMinAggregateInputType
    _max?: ClinicalNoteMaxAggregateInputType
  }

  export type ClinicalNoteGroupByOutputType = {
    id: string
    patientId: string
    authorId: string
    type: $Enums.NoteType
    title: string
    content: string
    data: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ClinicalNoteCountAggregateOutputType | null
    _min: ClinicalNoteMinAggregateOutputType | null
    _max: ClinicalNoteMaxAggregateOutputType | null
  }

  type GetClinicalNoteGroupByPayload<T extends ClinicalNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicalNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicalNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicalNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicalNoteGroupByOutputType[P]>
        }
      >
    >


  export type ClinicalNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectScalar = {
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicalNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "authorId" | "type" | "title" | "content" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["clinicalNote"]>
  export type ClinicalNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClinicalNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClinicalNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClinicalNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicalNote"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      authorId: string
      type: $Enums.NoteType
      title: string
      content: string
      data: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicalNote"]>
    composites: {}
  }

  type ClinicalNoteGetPayload<S extends boolean | null | undefined | ClinicalNoteDefaultArgs> = $Result.GetResult<Prisma.$ClinicalNotePayload, S>

  type ClinicalNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicalNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicalNoteCountAggregateInputType | true
    }

  export interface ClinicalNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicalNote'], meta: { name: 'ClinicalNote' } }
    /**
     * Find zero or one ClinicalNote that matches the filter.
     * @param {ClinicalNoteFindUniqueArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicalNoteFindUniqueArgs>(args: SelectSubset<T, ClinicalNoteFindUniqueArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicalNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicalNoteFindUniqueOrThrowArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicalNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicalNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindFirstArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicalNoteFindFirstArgs>(args?: SelectSubset<T, ClinicalNoteFindFirstArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindFirstOrThrowArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicalNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicalNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicalNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicalNotes
     * const clinicalNotes = await prisma.clinicalNote.findMany()
     * 
     * // Get first 10 ClinicalNotes
     * const clinicalNotes = await prisma.clinicalNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicalNoteFindManyArgs>(args?: SelectSubset<T, ClinicalNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicalNote.
     * @param {ClinicalNoteCreateArgs} args - Arguments to create a ClinicalNote.
     * @example
     * // Create one ClinicalNote
     * const ClinicalNote = await prisma.clinicalNote.create({
     *   data: {
     *     // ... data to create a ClinicalNote
     *   }
     * })
     * 
     */
    create<T extends ClinicalNoteCreateArgs>(args: SelectSubset<T, ClinicalNoteCreateArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicalNotes.
     * @param {ClinicalNoteCreateManyArgs} args - Arguments to create many ClinicalNotes.
     * @example
     * // Create many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicalNoteCreateManyArgs>(args?: SelectSubset<T, ClinicalNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicalNotes and returns the data saved in the database.
     * @param {ClinicalNoteCreateManyAndReturnArgs} args - Arguments to create many ClinicalNotes.
     * @example
     * // Create many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicalNotes and only return the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicalNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicalNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicalNote.
     * @param {ClinicalNoteDeleteArgs} args - Arguments to delete one ClinicalNote.
     * @example
     * // Delete one ClinicalNote
     * const ClinicalNote = await prisma.clinicalNote.delete({
     *   where: {
     *     // ... filter to delete one ClinicalNote
     *   }
     * })
     * 
     */
    delete<T extends ClinicalNoteDeleteArgs>(args: SelectSubset<T, ClinicalNoteDeleteArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicalNote.
     * @param {ClinicalNoteUpdateArgs} args - Arguments to update one ClinicalNote.
     * @example
     * // Update one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicalNoteUpdateArgs>(args: SelectSubset<T, ClinicalNoteUpdateArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicalNotes.
     * @param {ClinicalNoteDeleteManyArgs} args - Arguments to filter ClinicalNotes to delete.
     * @example
     * // Delete a few ClinicalNotes
     * const { count } = await prisma.clinicalNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicalNoteDeleteManyArgs>(args?: SelectSubset<T, ClinicalNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicalNoteUpdateManyArgs>(args: SelectSubset<T, ClinicalNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalNotes and returns the data updated in the database.
     * @param {ClinicalNoteUpdateManyAndReturnArgs} args - Arguments to update many ClinicalNotes.
     * @example
     * // Update many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicalNotes and only return the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicalNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicalNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicalNote.
     * @param {ClinicalNoteUpsertArgs} args - Arguments to update or create a ClinicalNote.
     * @example
     * // Update or create a ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.upsert({
     *   create: {
     *     // ... data to create a ClinicalNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicalNote we want to update
     *   }
     * })
     */
    upsert<T extends ClinicalNoteUpsertArgs>(args: SelectSubset<T, ClinicalNoteUpsertArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicalNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteCountArgs} args - Arguments to filter ClinicalNotes to count.
     * @example
     * // Count the number of ClinicalNotes
     * const count = await prisma.clinicalNote.count({
     *   where: {
     *     // ... the filter for the ClinicalNotes we want to count
     *   }
     * })
    **/
    count<T extends ClinicalNoteCountArgs>(
      args?: Subset<T, ClinicalNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicalNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicalNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicalNoteAggregateArgs>(args: Subset<T, ClinicalNoteAggregateArgs>): Prisma.PrismaPromise<GetClinicalNoteAggregateType<T>>

    /**
     * Group by ClinicalNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicalNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicalNoteGroupByArgs['orderBy'] }
        : { orderBy?: ClinicalNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicalNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicalNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicalNote model
   */
  readonly fields: ClinicalNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicalNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicalNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicalNote model
   */
  interface ClinicalNoteFieldRefs {
    readonly id: FieldRef<"ClinicalNote", 'String'>
    readonly patientId: FieldRef<"ClinicalNote", 'String'>
    readonly authorId: FieldRef<"ClinicalNote", 'String'>
    readonly type: FieldRef<"ClinicalNote", 'NoteType'>
    readonly title: FieldRef<"ClinicalNote", 'String'>
    readonly content: FieldRef<"ClinicalNote", 'String'>
    readonly data: FieldRef<"ClinicalNote", 'Json'>
    readonly createdAt: FieldRef<"ClinicalNote", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicalNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicalNote findUnique
   */
  export type ClinicalNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote findUniqueOrThrow
   */
  export type ClinicalNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote findFirst
   */
  export type ClinicalNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalNotes.
     */
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote findFirstOrThrow
   */
  export type ClinicalNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalNotes.
     */
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote findMany
   */
  export type ClinicalNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNotes to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote create
   */
  export type ClinicalNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicalNote.
     */
    data: XOR<ClinicalNoteCreateInput, ClinicalNoteUncheckedCreateInput>
  }

  /**
   * ClinicalNote createMany
   */
  export type ClinicalNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicalNotes.
     */
    data: ClinicalNoteCreateManyInput | ClinicalNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicalNote createManyAndReturn
   */
  export type ClinicalNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicalNotes.
     */
    data: ClinicalNoteCreateManyInput | ClinicalNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalNote update
   */
  export type ClinicalNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicalNote.
     */
    data: XOR<ClinicalNoteUpdateInput, ClinicalNoteUncheckedUpdateInput>
    /**
     * Choose, which ClinicalNote to update.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote updateMany
   */
  export type ClinicalNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicalNotes.
     */
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalNotes to update
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to update.
     */
    limit?: number
  }

  /**
   * ClinicalNote updateManyAndReturn
   */
  export type ClinicalNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * The data used to update ClinicalNotes.
     */
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalNotes to update
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalNote upsert
   */
  export type ClinicalNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicalNote to update in case it exists.
     */
    where: ClinicalNoteWhereUniqueInput
    /**
     * In case the ClinicalNote found by the `where` argument doesn't exist, create a new ClinicalNote with this data.
     */
    create: XOR<ClinicalNoteCreateInput, ClinicalNoteUncheckedCreateInput>
    /**
     * In case the ClinicalNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicalNoteUpdateInput, ClinicalNoteUncheckedUpdateInput>
  }

  /**
   * ClinicalNote delete
   */
  export type ClinicalNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter which ClinicalNote to delete.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote deleteMany
   */
  export type ClinicalNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalNotes to delete
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to delete.
     */
    limit?: number
  }

  /**
   * ClinicalNote without action
   */
  export type ClinicalNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    details: string | null
    userId: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    details: string | null
    userId: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    details: number
    userId: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    details?: true
    userId?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    details?: true
    userId?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    details?: true
    userId?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    details: string | null
    userId: string
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    details?: boolean
    userId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    details?: boolean
    userId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    details?: boolean
    userId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    details?: boolean
    userId?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "details" | "userId" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      details: string | null
      userId: string
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model VitalSign
   */

  export type AggregateVitalSign = {
    _count: VitalSignCountAggregateOutputType | null
    _avg: VitalSignAvgAggregateOutputType | null
    _sum: VitalSignSumAggregateOutputType | null
    _min: VitalSignMinAggregateOutputType | null
    _max: VitalSignMaxAggregateOutputType | null
  }

  export type VitalSignAvgAggregateOutputType = {
    heartRate: number | null
    bpSys: number | null
    bpDia: number | null
    spo2: number | null
    temp: number | null
    rbs: number | null
  }

  export type VitalSignSumAggregateOutputType = {
    heartRate: number | null
    bpSys: number | null
    bpDia: number | null
    spo2: number | null
    temp: number | null
    rbs: number | null
  }

  export type VitalSignMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    heartRate: number | null
    bpSys: number | null
    bpDia: number | null
    spo2: number | null
    temp: number | null
    rbs: number | null
    timestamp: Date | null
  }

  export type VitalSignMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    heartRate: number | null
    bpSys: number | null
    bpDia: number | null
    spo2: number | null
    temp: number | null
    rbs: number | null
    timestamp: Date | null
  }

  export type VitalSignCountAggregateOutputType = {
    id: number
    patientId: number
    heartRate: number
    bpSys: number
    bpDia: number
    spo2: number
    temp: number
    rbs: number
    timestamp: number
    _all: number
  }


  export type VitalSignAvgAggregateInputType = {
    heartRate?: true
    bpSys?: true
    bpDia?: true
    spo2?: true
    temp?: true
    rbs?: true
  }

  export type VitalSignSumAggregateInputType = {
    heartRate?: true
    bpSys?: true
    bpDia?: true
    spo2?: true
    temp?: true
    rbs?: true
  }

  export type VitalSignMinAggregateInputType = {
    id?: true
    patientId?: true
    heartRate?: true
    bpSys?: true
    bpDia?: true
    spo2?: true
    temp?: true
    rbs?: true
    timestamp?: true
  }

  export type VitalSignMaxAggregateInputType = {
    id?: true
    patientId?: true
    heartRate?: true
    bpSys?: true
    bpDia?: true
    spo2?: true
    temp?: true
    rbs?: true
    timestamp?: true
  }

  export type VitalSignCountAggregateInputType = {
    id?: true
    patientId?: true
    heartRate?: true
    bpSys?: true
    bpDia?: true
    spo2?: true
    temp?: true
    rbs?: true
    timestamp?: true
    _all?: true
  }

  export type VitalSignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSign to aggregate.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitalSigns
    **/
    _count?: true | VitalSignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitalSignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitalSignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitalSignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitalSignMaxAggregateInputType
  }

  export type GetVitalSignAggregateType<T extends VitalSignAggregateArgs> = {
        [P in keyof T & keyof AggregateVitalSign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitalSign[P]>
      : GetScalarType<T[P], AggregateVitalSign[P]>
  }




  export type VitalSignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignWhereInput
    orderBy?: VitalSignOrderByWithAggregationInput | VitalSignOrderByWithAggregationInput[]
    by: VitalSignScalarFieldEnum[] | VitalSignScalarFieldEnum
    having?: VitalSignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitalSignCountAggregateInputType | true
    _avg?: VitalSignAvgAggregateInputType
    _sum?: VitalSignSumAggregateInputType
    _min?: VitalSignMinAggregateInputType
    _max?: VitalSignMaxAggregateInputType
  }

  export type VitalSignGroupByOutputType = {
    id: string
    patientId: string
    heartRate: number | null
    bpSys: number | null
    bpDia: number | null
    spo2: number | null
    temp: number | null
    rbs: number | null
    timestamp: Date
    _count: VitalSignCountAggregateOutputType | null
    _avg: VitalSignAvgAggregateOutputType | null
    _sum: VitalSignSumAggregateOutputType | null
    _min: VitalSignMinAggregateOutputType | null
    _max: VitalSignMaxAggregateOutputType | null
  }

  type GetVitalSignGroupByPayload<T extends VitalSignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VitalSignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitalSignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitalSignGroupByOutputType[P]>
            : GetScalarType<T[P], VitalSignGroupByOutputType[P]>
        }
      >
    >


  export type VitalSignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    heartRate?: boolean
    bpSys?: boolean
    bpDia?: boolean
    spo2?: boolean
    temp?: boolean
    rbs?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    heartRate?: boolean
    bpSys?: boolean
    bpDia?: boolean
    spo2?: boolean
    temp?: boolean
    rbs?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    heartRate?: boolean
    bpSys?: boolean
    bpDia?: boolean
    spo2?: boolean
    temp?: boolean
    rbs?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSign"]>

  export type VitalSignSelectScalar = {
    id?: boolean
    patientId?: boolean
    heartRate?: boolean
    bpSys?: boolean
    bpDia?: boolean
    spo2?: boolean
    temp?: boolean
    rbs?: boolean
    timestamp?: boolean
  }

  export type VitalSignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "heartRate" | "bpSys" | "bpDia" | "spo2" | "temp" | "rbs" | "timestamp", ExtArgs["result"]["vitalSign"]>
  export type VitalSignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type VitalSignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type VitalSignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $VitalSignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VitalSign"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      heartRate: number | null
      bpSys: number | null
      bpDia: number | null
      spo2: number | null
      temp: number | null
      rbs: number | null
      timestamp: Date
    }, ExtArgs["result"]["vitalSign"]>
    composites: {}
  }

  type VitalSignGetPayload<S extends boolean | null | undefined | VitalSignDefaultArgs> = $Result.GetResult<Prisma.$VitalSignPayload, S>

  type VitalSignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VitalSignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VitalSignCountAggregateInputType | true
    }

  export interface VitalSignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VitalSign'], meta: { name: 'VitalSign' } }
    /**
     * Find zero or one VitalSign that matches the filter.
     * @param {VitalSignFindUniqueArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VitalSignFindUniqueArgs>(args: SelectSubset<T, VitalSignFindUniqueArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VitalSign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VitalSignFindUniqueOrThrowArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VitalSignFindUniqueOrThrowArgs>(args: SelectSubset<T, VitalSignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindFirstArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VitalSignFindFirstArgs>(args?: SelectSubset<T, VitalSignFindFirstArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindFirstOrThrowArgs} args - Arguments to find a VitalSign
     * @example
     * // Get one VitalSign
     * const vitalSign = await prisma.vitalSign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VitalSignFindFirstOrThrowArgs>(args?: SelectSubset<T, VitalSignFindFirstOrThrowArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitalSigns
     * const vitalSigns = await prisma.vitalSign.findMany()
     * 
     * // Get first 10 VitalSigns
     * const vitalSigns = await prisma.vitalSign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VitalSignFindManyArgs>(args?: SelectSubset<T, VitalSignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VitalSign.
     * @param {VitalSignCreateArgs} args - Arguments to create a VitalSign.
     * @example
     * // Create one VitalSign
     * const VitalSign = await prisma.vitalSign.create({
     *   data: {
     *     // ... data to create a VitalSign
     *   }
     * })
     * 
     */
    create<T extends VitalSignCreateArgs>(args: SelectSubset<T, VitalSignCreateArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VitalSigns.
     * @param {VitalSignCreateManyArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSign = await prisma.vitalSign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VitalSignCreateManyArgs>(args?: SelectSubset<T, VitalSignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VitalSigns and returns the data saved in the database.
     * @param {VitalSignCreateManyAndReturnArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSign = await prisma.vitalSign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VitalSigns and only return the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VitalSignCreateManyAndReturnArgs>(args?: SelectSubset<T, VitalSignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VitalSign.
     * @param {VitalSignDeleteArgs} args - Arguments to delete one VitalSign.
     * @example
     * // Delete one VitalSign
     * const VitalSign = await prisma.vitalSign.delete({
     *   where: {
     *     // ... filter to delete one VitalSign
     *   }
     * })
     * 
     */
    delete<T extends VitalSignDeleteArgs>(args: SelectSubset<T, VitalSignDeleteArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VitalSign.
     * @param {VitalSignUpdateArgs} args - Arguments to update one VitalSign.
     * @example
     * // Update one VitalSign
     * const vitalSign = await prisma.vitalSign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VitalSignUpdateArgs>(args: SelectSubset<T, VitalSignUpdateArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VitalSigns.
     * @param {VitalSignDeleteManyArgs} args - Arguments to filter VitalSigns to delete.
     * @example
     * // Delete a few VitalSigns
     * const { count } = await prisma.vitalSign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VitalSignDeleteManyArgs>(args?: SelectSubset<T, VitalSignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitalSigns
     * const vitalSign = await prisma.vitalSign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VitalSignUpdateManyArgs>(args: SelectSubset<T, VitalSignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns and returns the data updated in the database.
     * @param {VitalSignUpdateManyAndReturnArgs} args - Arguments to update many VitalSigns.
     * @example
     * // Update many VitalSigns
     * const vitalSign = await prisma.vitalSign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VitalSigns and only return the `id`
     * const vitalSignWithIdOnly = await prisma.vitalSign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VitalSignUpdateManyAndReturnArgs>(args: SelectSubset<T, VitalSignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VitalSign.
     * @param {VitalSignUpsertArgs} args - Arguments to update or create a VitalSign.
     * @example
     * // Update or create a VitalSign
     * const vitalSign = await prisma.vitalSign.upsert({
     *   create: {
     *     // ... data to create a VitalSign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitalSign we want to update
     *   }
     * })
     */
    upsert<T extends VitalSignUpsertArgs>(args: SelectSubset<T, VitalSignUpsertArgs<ExtArgs>>): Prisma__VitalSignClient<$Result.GetResult<Prisma.$VitalSignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignCountArgs} args - Arguments to filter VitalSigns to count.
     * @example
     * // Count the number of VitalSigns
     * const count = await prisma.vitalSign.count({
     *   where: {
     *     // ... the filter for the VitalSigns we want to count
     *   }
     * })
    **/
    count<T extends VitalSignCountArgs>(
      args?: Subset<T, VitalSignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitalSignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitalSign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitalSignAggregateArgs>(args: Subset<T, VitalSignAggregateArgs>): Prisma.PrismaPromise<GetVitalSignAggregateType<T>>

    /**
     * Group by VitalSign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitalSignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitalSignGroupByArgs['orderBy'] }
        : { orderBy?: VitalSignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitalSignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitalSignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VitalSign model
   */
  readonly fields: VitalSignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitalSign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VitalSignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VitalSign model
   */
  interface VitalSignFieldRefs {
    readonly id: FieldRef<"VitalSign", 'String'>
    readonly patientId: FieldRef<"VitalSign", 'String'>
    readonly heartRate: FieldRef<"VitalSign", 'Int'>
    readonly bpSys: FieldRef<"VitalSign", 'Int'>
    readonly bpDia: FieldRef<"VitalSign", 'Int'>
    readonly spo2: FieldRef<"VitalSign", 'Int'>
    readonly temp: FieldRef<"VitalSign", 'Float'>
    readonly rbs: FieldRef<"VitalSign", 'Float'>
    readonly timestamp: FieldRef<"VitalSign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VitalSign findUnique
   */
  export type VitalSignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign findUniqueOrThrow
   */
  export type VitalSignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign findFirst
   */
  export type VitalSignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign findFirstOrThrow
   */
  export type VitalSignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSign to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign findMany
   */
  export type VitalSignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignOrderByWithRelationInput | VitalSignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitalSigns.
     */
    cursor?: VitalSignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    distinct?: VitalSignScalarFieldEnum | VitalSignScalarFieldEnum[]
  }

  /**
   * VitalSign create
   */
  export type VitalSignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The data needed to create a VitalSign.
     */
    data: XOR<VitalSignCreateInput, VitalSignUncheckedCreateInput>
  }

  /**
   * VitalSign createMany
   */
  export type VitalSignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignCreateManyInput | VitalSignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VitalSign createManyAndReturn
   */
  export type VitalSignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignCreateManyInput | VitalSignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSign update
   */
  export type VitalSignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The data needed to update a VitalSign.
     */
    data: XOR<VitalSignUpdateInput, VitalSignUncheckedUpdateInput>
    /**
     * Choose, which VitalSign to update.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign updateMany
   */
  export type VitalSignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
  }

  /**
   * VitalSign updateManyAndReturn
   */
  export type VitalSignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSign upsert
   */
  export type VitalSignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * The filter to search for the VitalSign to update in case it exists.
     */
    where: VitalSignWhereUniqueInput
    /**
     * In case the VitalSign found by the `where` argument doesn't exist, create a new VitalSign with this data.
     */
    create: XOR<VitalSignCreateInput, VitalSignUncheckedCreateInput>
    /**
     * In case the VitalSign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VitalSignUpdateInput, VitalSignUncheckedUpdateInput>
  }

  /**
   * VitalSign delete
   */
  export type VitalSignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
    /**
     * Filter which VitalSign to delete.
     */
    where: VitalSignWhereUniqueInput
  }

  /**
   * VitalSign deleteMany
   */
  export type VitalSignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to delete
     */
    where?: VitalSignWhereInput
    /**
     * Limit how many VitalSigns to delete.
     */
    limit?: number
  }

  /**
   * VitalSign without action
   */
  export type VitalSignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSign
     */
    select?: VitalSignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSign
     */
    omit?: VitalSignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    name: string | null
    defaultDose: string | null
    route: string | null
    frequency: string | null
    infusionRate: string | null
    otherInstructions: string | null
    patientId: string | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    defaultDose: string | null
    route: string | null
    frequency: string | null
    infusionRate: string | null
    otherInstructions: string | null
    patientId: string | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    name: number
    defaultDose: number
    route: number
    frequency: number
    infusionRate: number
    otherInstructions: number
    patientId: number
    _all: number
  }


  export type MedicationMinAggregateInputType = {
    id?: true
    name?: true
    defaultDose?: true
    route?: true
    frequency?: true
    infusionRate?: true
    otherInstructions?: true
    patientId?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    name?: true
    defaultDose?: true
    route?: true
    frequency?: true
    infusionRate?: true
    otherInstructions?: true
    patientId?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    name?: true
    defaultDose?: true
    route?: true
    frequency?: true
    infusionRate?: true
    otherInstructions?: true
    patientId?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    name: string
    defaultDose: string
    route: string
    frequency: string | null
    infusionRate: string | null
    otherInstructions: string | null
    patientId: string | null
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    route?: boolean
    frequency?: boolean
    infusionRate?: boolean
    otherInstructions?: boolean
    patientId?: boolean
    patient?: boolean | Medication$patientArgs<ExtArgs>
    administrations?: boolean | Medication$administrationsArgs<ExtArgs>
    _count?: boolean | MedicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    route?: boolean
    frequency?: boolean
    infusionRate?: boolean
    otherInstructions?: boolean
    patientId?: boolean
    patient?: boolean | Medication$patientArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    route?: boolean
    frequency?: boolean
    infusionRate?: boolean
    otherInstructions?: boolean
    patientId?: boolean
    patient?: boolean | Medication$patientArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectScalar = {
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    route?: boolean
    frequency?: boolean
    infusionRate?: boolean
    otherInstructions?: boolean
    patientId?: boolean
  }

  export type MedicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "defaultDose" | "route" | "frequency" | "infusionRate" | "otherInstructions" | "patientId", ExtArgs["result"]["medication"]>
  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Medication$patientArgs<ExtArgs>
    administrations?: boolean | Medication$administrationsArgs<ExtArgs>
    _count?: boolean | MedicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Medication$patientArgs<ExtArgs>
  }
  export type MedicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | Medication$patientArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
      administrations: Prisma.$MedicationAdministrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      defaultDose: string
      route: string
      frequency: string | null
      infusionRate: string | null
      otherInstructions: string | null
      patientId: string | null
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications and returns the data updated in the database.
     * @param {MedicationUpdateManyAndReturnArgs} args - Arguments to update many Medications.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicationUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends Medication$patientArgs<ExtArgs> = {}>(args?: Subset<T, Medication$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    administrations<T extends Medication$administrationsArgs<ExtArgs> = {}>(args?: Subset<T, Medication$administrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly name: FieldRef<"Medication", 'String'>
    readonly defaultDose: FieldRef<"Medication", 'String'>
    readonly route: FieldRef<"Medication", 'String'>
    readonly frequency: FieldRef<"Medication", 'String'>
    readonly infusionRate: FieldRef<"Medication", 'String'>
    readonly otherInstructions: FieldRef<"Medication", 'String'>
    readonly patientId: FieldRef<"Medication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medication createManyAndReturn
   */
  export type MedicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
  }

  /**
   * Medication updateManyAndReturn
   */
  export type MedicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to delete.
     */
    limit?: number
  }

  /**
   * Medication.patient
   */
  export type Medication$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Medication.administrations
   */
  export type Medication$administrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    where?: MedicationAdministrationWhereInput
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    cursor?: MedicationAdministrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model DrugCatalog
   */

  export type AggregateDrugCatalog = {
    _count: DrugCatalogCountAggregateOutputType | null
    _min: DrugCatalogMinAggregateOutputType | null
    _max: DrugCatalogMaxAggregateOutputType | null
  }

  export type DrugCatalogMinAggregateOutputType = {
    id: string | null
    name: string | null
    defaultDose: string | null
    defaultRoute: string | null
    createdAt: Date | null
  }

  export type DrugCatalogMaxAggregateOutputType = {
    id: string | null
    name: string | null
    defaultDose: string | null
    defaultRoute: string | null
    createdAt: Date | null
  }

  export type DrugCatalogCountAggregateOutputType = {
    id: number
    name: number
    defaultDose: number
    defaultRoute: number
    createdAt: number
    _all: number
  }


  export type DrugCatalogMinAggregateInputType = {
    id?: true
    name?: true
    defaultDose?: true
    defaultRoute?: true
    createdAt?: true
  }

  export type DrugCatalogMaxAggregateInputType = {
    id?: true
    name?: true
    defaultDose?: true
    defaultRoute?: true
    createdAt?: true
  }

  export type DrugCatalogCountAggregateInputType = {
    id?: true
    name?: true
    defaultDose?: true
    defaultRoute?: true
    createdAt?: true
    _all?: true
  }

  export type DrugCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugCatalog to aggregate.
     */
    where?: DrugCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugCatalogs to fetch.
     */
    orderBy?: DrugCatalogOrderByWithRelationInput | DrugCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrugCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DrugCatalogs
    **/
    _count?: true | DrugCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrugCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrugCatalogMaxAggregateInputType
  }

  export type GetDrugCatalogAggregateType<T extends DrugCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateDrugCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrugCatalog[P]>
      : GetScalarType<T[P], AggregateDrugCatalog[P]>
  }




  export type DrugCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrugCatalogWhereInput
    orderBy?: DrugCatalogOrderByWithAggregationInput | DrugCatalogOrderByWithAggregationInput[]
    by: DrugCatalogScalarFieldEnum[] | DrugCatalogScalarFieldEnum
    having?: DrugCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrugCatalogCountAggregateInputType | true
    _min?: DrugCatalogMinAggregateInputType
    _max?: DrugCatalogMaxAggregateInputType
  }

  export type DrugCatalogGroupByOutputType = {
    id: string
    name: string
    defaultDose: string | null
    defaultRoute: string | null
    createdAt: Date
    _count: DrugCatalogCountAggregateOutputType | null
    _min: DrugCatalogMinAggregateOutputType | null
    _max: DrugCatalogMaxAggregateOutputType | null
  }

  type GetDrugCatalogGroupByPayload<T extends DrugCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrugCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrugCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrugCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], DrugCatalogGroupByOutputType[P]>
        }
      >
    >


  export type DrugCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    defaultRoute?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["drugCatalog"]>

  export type DrugCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    defaultRoute?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["drugCatalog"]>

  export type DrugCatalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    defaultRoute?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["drugCatalog"]>

  export type DrugCatalogSelectScalar = {
    id?: boolean
    name?: boolean
    defaultDose?: boolean
    defaultRoute?: boolean
    createdAt?: boolean
  }

  export type DrugCatalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "defaultDose" | "defaultRoute" | "createdAt", ExtArgs["result"]["drugCatalog"]>

  export type $DrugCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DrugCatalog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      defaultDose: string | null
      defaultRoute: string | null
      createdAt: Date
    }, ExtArgs["result"]["drugCatalog"]>
    composites: {}
  }

  type DrugCatalogGetPayload<S extends boolean | null | undefined | DrugCatalogDefaultArgs> = $Result.GetResult<Prisma.$DrugCatalogPayload, S>

  type DrugCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DrugCatalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DrugCatalogCountAggregateInputType | true
    }

  export interface DrugCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DrugCatalog'], meta: { name: 'DrugCatalog' } }
    /**
     * Find zero or one DrugCatalog that matches the filter.
     * @param {DrugCatalogFindUniqueArgs} args - Arguments to find a DrugCatalog
     * @example
     * // Get one DrugCatalog
     * const drugCatalog = await prisma.drugCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DrugCatalogFindUniqueArgs>(args: SelectSubset<T, DrugCatalogFindUniqueArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DrugCatalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DrugCatalogFindUniqueOrThrowArgs} args - Arguments to find a DrugCatalog
     * @example
     * // Get one DrugCatalog
     * const drugCatalog = await prisma.drugCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DrugCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, DrugCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrugCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCatalogFindFirstArgs} args - Arguments to find a DrugCatalog
     * @example
     * // Get one DrugCatalog
     * const drugCatalog = await prisma.drugCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DrugCatalogFindFirstArgs>(args?: SelectSubset<T, DrugCatalogFindFirstArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrugCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCatalogFindFirstOrThrowArgs} args - Arguments to find a DrugCatalog
     * @example
     * // Get one DrugCatalog
     * const drugCatalog = await prisma.drugCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DrugCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, DrugCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DrugCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DrugCatalogs
     * const drugCatalogs = await prisma.drugCatalog.findMany()
     * 
     * // Get first 10 DrugCatalogs
     * const drugCatalogs = await prisma.drugCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drugCatalogWithIdOnly = await prisma.drugCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DrugCatalogFindManyArgs>(args?: SelectSubset<T, DrugCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DrugCatalog.
     * @param {DrugCatalogCreateArgs} args - Arguments to create a DrugCatalog.
     * @example
     * // Create one DrugCatalog
     * const DrugCatalog = await prisma.drugCatalog.create({
     *   data: {
     *     // ... data to create a DrugCatalog
     *   }
     * })
     * 
     */
    create<T extends DrugCatalogCreateArgs>(args: SelectSubset<T, DrugCatalogCreateArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DrugCatalogs.
     * @param {DrugCatalogCreateManyArgs} args - Arguments to create many DrugCatalogs.
     * @example
     * // Create many DrugCatalogs
     * const drugCatalog = await prisma.drugCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DrugCatalogCreateManyArgs>(args?: SelectSubset<T, DrugCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DrugCatalogs and returns the data saved in the database.
     * @param {DrugCatalogCreateManyAndReturnArgs} args - Arguments to create many DrugCatalogs.
     * @example
     * // Create many DrugCatalogs
     * const drugCatalog = await prisma.drugCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DrugCatalogs and only return the `id`
     * const drugCatalogWithIdOnly = await prisma.drugCatalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DrugCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, DrugCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DrugCatalog.
     * @param {DrugCatalogDeleteArgs} args - Arguments to delete one DrugCatalog.
     * @example
     * // Delete one DrugCatalog
     * const DrugCatalog = await prisma.drugCatalog.delete({
     *   where: {
     *     // ... filter to delete one DrugCatalog
     *   }
     * })
     * 
     */
    delete<T extends DrugCatalogDeleteArgs>(args: SelectSubset<T, DrugCatalogDeleteArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DrugCatalog.
     * @param {DrugCatalogUpdateArgs} args - Arguments to update one DrugCatalog.
     * @example
     * // Update one DrugCatalog
     * const drugCatalog = await prisma.drugCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DrugCatalogUpdateArgs>(args: SelectSubset<T, DrugCatalogUpdateArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DrugCatalogs.
     * @param {DrugCatalogDeleteManyArgs} args - Arguments to filter DrugCatalogs to delete.
     * @example
     * // Delete a few DrugCatalogs
     * const { count } = await prisma.drugCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DrugCatalogDeleteManyArgs>(args?: SelectSubset<T, DrugCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrugCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DrugCatalogs
     * const drugCatalog = await prisma.drugCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DrugCatalogUpdateManyArgs>(args: SelectSubset<T, DrugCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrugCatalogs and returns the data updated in the database.
     * @param {DrugCatalogUpdateManyAndReturnArgs} args - Arguments to update many DrugCatalogs.
     * @example
     * // Update many DrugCatalogs
     * const drugCatalog = await prisma.drugCatalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DrugCatalogs and only return the `id`
     * const drugCatalogWithIdOnly = await prisma.drugCatalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DrugCatalogUpdateManyAndReturnArgs>(args: SelectSubset<T, DrugCatalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DrugCatalog.
     * @param {DrugCatalogUpsertArgs} args - Arguments to update or create a DrugCatalog.
     * @example
     * // Update or create a DrugCatalog
     * const drugCatalog = await prisma.drugCatalog.upsert({
     *   create: {
     *     // ... data to create a DrugCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DrugCatalog we want to update
     *   }
     * })
     */
    upsert<T extends DrugCatalogUpsertArgs>(args: SelectSubset<T, DrugCatalogUpsertArgs<ExtArgs>>): Prisma__DrugCatalogClient<$Result.GetResult<Prisma.$DrugCatalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DrugCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCatalogCountArgs} args - Arguments to filter DrugCatalogs to count.
     * @example
     * // Count the number of DrugCatalogs
     * const count = await prisma.drugCatalog.count({
     *   where: {
     *     // ... the filter for the DrugCatalogs we want to count
     *   }
     * })
    **/
    count<T extends DrugCatalogCountArgs>(
      args?: Subset<T, DrugCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrugCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DrugCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrugCatalogAggregateArgs>(args: Subset<T, DrugCatalogAggregateArgs>): Prisma.PrismaPromise<GetDrugCatalogAggregateType<T>>

    /**
     * Group by DrugCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrugCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrugCatalogGroupByArgs['orderBy'] }
        : { orderBy?: DrugCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrugCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrugCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DrugCatalog model
   */
  readonly fields: DrugCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DrugCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DrugCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DrugCatalog model
   */
  interface DrugCatalogFieldRefs {
    readonly id: FieldRef<"DrugCatalog", 'String'>
    readonly name: FieldRef<"DrugCatalog", 'String'>
    readonly defaultDose: FieldRef<"DrugCatalog", 'String'>
    readonly defaultRoute: FieldRef<"DrugCatalog", 'String'>
    readonly createdAt: FieldRef<"DrugCatalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DrugCatalog findUnique
   */
  export type DrugCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * Filter, which DrugCatalog to fetch.
     */
    where: DrugCatalogWhereUniqueInput
  }

  /**
   * DrugCatalog findUniqueOrThrow
   */
  export type DrugCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * Filter, which DrugCatalog to fetch.
     */
    where: DrugCatalogWhereUniqueInput
  }

  /**
   * DrugCatalog findFirst
   */
  export type DrugCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * Filter, which DrugCatalog to fetch.
     */
    where?: DrugCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugCatalogs to fetch.
     */
    orderBy?: DrugCatalogOrderByWithRelationInput | DrugCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugCatalogs.
     */
    cursor?: DrugCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugCatalogs.
     */
    distinct?: DrugCatalogScalarFieldEnum | DrugCatalogScalarFieldEnum[]
  }

  /**
   * DrugCatalog findFirstOrThrow
   */
  export type DrugCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * Filter, which DrugCatalog to fetch.
     */
    where?: DrugCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugCatalogs to fetch.
     */
    orderBy?: DrugCatalogOrderByWithRelationInput | DrugCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugCatalogs.
     */
    cursor?: DrugCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugCatalogs.
     */
    distinct?: DrugCatalogScalarFieldEnum | DrugCatalogScalarFieldEnum[]
  }

  /**
   * DrugCatalog findMany
   */
  export type DrugCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * Filter, which DrugCatalogs to fetch.
     */
    where?: DrugCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugCatalogs to fetch.
     */
    orderBy?: DrugCatalogOrderByWithRelationInput | DrugCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DrugCatalogs.
     */
    cursor?: DrugCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugCatalogs.
     */
    skip?: number
    distinct?: DrugCatalogScalarFieldEnum | DrugCatalogScalarFieldEnum[]
  }

  /**
   * DrugCatalog create
   */
  export type DrugCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * The data needed to create a DrugCatalog.
     */
    data: XOR<DrugCatalogCreateInput, DrugCatalogUncheckedCreateInput>
  }

  /**
   * DrugCatalog createMany
   */
  export type DrugCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DrugCatalogs.
     */
    data: DrugCatalogCreateManyInput | DrugCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DrugCatalog createManyAndReturn
   */
  export type DrugCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * The data used to create many DrugCatalogs.
     */
    data: DrugCatalogCreateManyInput | DrugCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DrugCatalog update
   */
  export type DrugCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * The data needed to update a DrugCatalog.
     */
    data: XOR<DrugCatalogUpdateInput, DrugCatalogUncheckedUpdateInput>
    /**
     * Choose, which DrugCatalog to update.
     */
    where: DrugCatalogWhereUniqueInput
  }

  /**
   * DrugCatalog updateMany
   */
  export type DrugCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DrugCatalogs.
     */
    data: XOR<DrugCatalogUpdateManyMutationInput, DrugCatalogUncheckedUpdateManyInput>
    /**
     * Filter which DrugCatalogs to update
     */
    where?: DrugCatalogWhereInput
    /**
     * Limit how many DrugCatalogs to update.
     */
    limit?: number
  }

  /**
   * DrugCatalog updateManyAndReturn
   */
  export type DrugCatalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * The data used to update DrugCatalogs.
     */
    data: XOR<DrugCatalogUpdateManyMutationInput, DrugCatalogUncheckedUpdateManyInput>
    /**
     * Filter which DrugCatalogs to update
     */
    where?: DrugCatalogWhereInput
    /**
     * Limit how many DrugCatalogs to update.
     */
    limit?: number
  }

  /**
   * DrugCatalog upsert
   */
  export type DrugCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * The filter to search for the DrugCatalog to update in case it exists.
     */
    where: DrugCatalogWhereUniqueInput
    /**
     * In case the DrugCatalog found by the `where` argument doesn't exist, create a new DrugCatalog with this data.
     */
    create: XOR<DrugCatalogCreateInput, DrugCatalogUncheckedCreateInput>
    /**
     * In case the DrugCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrugCatalogUpdateInput, DrugCatalogUncheckedUpdateInput>
  }

  /**
   * DrugCatalog delete
   */
  export type DrugCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
    /**
     * Filter which DrugCatalog to delete.
     */
    where: DrugCatalogWhereUniqueInput
  }

  /**
   * DrugCatalog deleteMany
   */
  export type DrugCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugCatalogs to delete
     */
    where?: DrugCatalogWhereInput
    /**
     * Limit how many DrugCatalogs to delete.
     */
    limit?: number
  }

  /**
   * DrugCatalog without action
   */
  export type DrugCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCatalog
     */
    select?: DrugCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugCatalog
     */
    omit?: DrugCatalogOmit<ExtArgs> | null
  }


  /**
   * Model MedicationAdministration
   */

  export type AggregateMedicationAdministration = {
    _count: MedicationAdministrationCountAggregateOutputType | null
    _min: MedicationAdministrationMinAggregateOutputType | null
    _max: MedicationAdministrationMaxAggregateOutputType | null
  }

  export type MedicationAdministrationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    medicationId: string | null
    status: string | null
    dose: string | null
    timestamp: Date | null
    userId: string | null
  }

  export type MedicationAdministrationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    medicationId: string | null
    status: string | null
    dose: string | null
    timestamp: Date | null
    userId: string | null
  }

  export type MedicationAdministrationCountAggregateOutputType = {
    id: number
    patientId: number
    medicationId: number
    status: number
    dose: number
    timestamp: number
    userId: number
    _all: number
  }


  export type MedicationAdministrationMinAggregateInputType = {
    id?: true
    patientId?: true
    medicationId?: true
    status?: true
    dose?: true
    timestamp?: true
    userId?: true
  }

  export type MedicationAdministrationMaxAggregateInputType = {
    id?: true
    patientId?: true
    medicationId?: true
    status?: true
    dose?: true
    timestamp?: true
    userId?: true
  }

  export type MedicationAdministrationCountAggregateInputType = {
    id?: true
    patientId?: true
    medicationId?: true
    status?: true
    dose?: true
    timestamp?: true
    userId?: true
    _all?: true
  }

  export type MedicationAdministrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationAdministration to aggregate.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicationAdministrations
    **/
    _count?: true | MedicationAdministrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationAdministrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationAdministrationMaxAggregateInputType
  }

  export type GetMedicationAdministrationAggregateType<T extends MedicationAdministrationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicationAdministration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicationAdministration[P]>
      : GetScalarType<T[P], AggregateMedicationAdministration[P]>
  }




  export type MedicationAdministrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationAdministrationWhereInput
    orderBy?: MedicationAdministrationOrderByWithAggregationInput | MedicationAdministrationOrderByWithAggregationInput[]
    by: MedicationAdministrationScalarFieldEnum[] | MedicationAdministrationScalarFieldEnum
    having?: MedicationAdministrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationAdministrationCountAggregateInputType | true
    _min?: MedicationAdministrationMinAggregateInputType
    _max?: MedicationAdministrationMaxAggregateInputType
  }

  export type MedicationAdministrationGroupByOutputType = {
    id: string
    patientId: string
    medicationId: string
    status: string
    dose: string | null
    timestamp: Date
    userId: string | null
    _count: MedicationAdministrationCountAggregateOutputType | null
    _min: MedicationAdministrationMinAggregateOutputType | null
    _max: MedicationAdministrationMaxAggregateOutputType | null
  }

  type GetMedicationAdministrationGroupByPayload<T extends MedicationAdministrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationAdministrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationAdministrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationAdministrationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationAdministrationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationAdministrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medicationId?: boolean
    status?: boolean
    dose?: boolean
    timestamp?: boolean
    userId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    user?: boolean | MedicationAdministration$userArgs<ExtArgs>
  }, ExtArgs["result"]["medicationAdministration"]>

  export type MedicationAdministrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medicationId?: boolean
    status?: boolean
    dose?: boolean
    timestamp?: boolean
    userId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    user?: boolean | MedicationAdministration$userArgs<ExtArgs>
  }, ExtArgs["result"]["medicationAdministration"]>

  export type MedicationAdministrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medicationId?: boolean
    status?: boolean
    dose?: boolean
    timestamp?: boolean
    userId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    user?: boolean | MedicationAdministration$userArgs<ExtArgs>
  }, ExtArgs["result"]["medicationAdministration"]>

  export type MedicationAdministrationSelectScalar = {
    id?: boolean
    patientId?: boolean
    medicationId?: boolean
    status?: boolean
    dose?: boolean
    timestamp?: boolean
    userId?: boolean
  }

  export type MedicationAdministrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "medicationId" | "status" | "dose" | "timestamp" | "userId", ExtArgs["result"]["medicationAdministration"]>
  export type MedicationAdministrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    user?: boolean | MedicationAdministration$userArgs<ExtArgs>
  }
  export type MedicationAdministrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    user?: boolean | MedicationAdministration$userArgs<ExtArgs>
  }
  export type MedicationAdministrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    user?: boolean | MedicationAdministration$userArgs<ExtArgs>
  }

  export type $MedicationAdministrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicationAdministration"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      medication: Prisma.$MedicationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      medicationId: string
      status: string
      dose: string | null
      timestamp: Date
      userId: string | null
    }, ExtArgs["result"]["medicationAdministration"]>
    composites: {}
  }

  type MedicationAdministrationGetPayload<S extends boolean | null | undefined | MedicationAdministrationDefaultArgs> = $Result.GetResult<Prisma.$MedicationAdministrationPayload, S>

  type MedicationAdministrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationAdministrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationAdministrationCountAggregateInputType | true
    }

  export interface MedicationAdministrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicationAdministration'], meta: { name: 'MedicationAdministration' } }
    /**
     * Find zero or one MedicationAdministration that matches the filter.
     * @param {MedicationAdministrationFindUniqueArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationAdministrationFindUniqueArgs>(args: SelectSubset<T, MedicationAdministrationFindUniqueArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicationAdministration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationAdministrationFindUniqueOrThrowArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationAdministrationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationAdministrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationAdministration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationFindFirstArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationAdministrationFindFirstArgs>(args?: SelectSubset<T, MedicationAdministrationFindFirstArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicationAdministration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationFindFirstOrThrowArgs} args - Arguments to find a MedicationAdministration
     * @example
     * // Get one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationAdministrationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationAdministrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicationAdministrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicationAdministrations
     * const medicationAdministrations = await prisma.medicationAdministration.findMany()
     * 
     * // Get first 10 MedicationAdministrations
     * const medicationAdministrations = await prisma.medicationAdministration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationAdministrationWithIdOnly = await prisma.medicationAdministration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationAdministrationFindManyArgs>(args?: SelectSubset<T, MedicationAdministrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicationAdministration.
     * @param {MedicationAdministrationCreateArgs} args - Arguments to create a MedicationAdministration.
     * @example
     * // Create one MedicationAdministration
     * const MedicationAdministration = await prisma.medicationAdministration.create({
     *   data: {
     *     // ... data to create a MedicationAdministration
     *   }
     * })
     * 
     */
    create<T extends MedicationAdministrationCreateArgs>(args: SelectSubset<T, MedicationAdministrationCreateArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicationAdministrations.
     * @param {MedicationAdministrationCreateManyArgs} args - Arguments to create many MedicationAdministrations.
     * @example
     * // Create many MedicationAdministrations
     * const medicationAdministration = await prisma.medicationAdministration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationAdministrationCreateManyArgs>(args?: SelectSubset<T, MedicationAdministrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicationAdministrations and returns the data saved in the database.
     * @param {MedicationAdministrationCreateManyAndReturnArgs} args - Arguments to create many MedicationAdministrations.
     * @example
     * // Create many MedicationAdministrations
     * const medicationAdministration = await prisma.medicationAdministration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicationAdministrations and only return the `id`
     * const medicationAdministrationWithIdOnly = await prisma.medicationAdministration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationAdministrationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationAdministrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicationAdministration.
     * @param {MedicationAdministrationDeleteArgs} args - Arguments to delete one MedicationAdministration.
     * @example
     * // Delete one MedicationAdministration
     * const MedicationAdministration = await prisma.medicationAdministration.delete({
     *   where: {
     *     // ... filter to delete one MedicationAdministration
     *   }
     * })
     * 
     */
    delete<T extends MedicationAdministrationDeleteArgs>(args: SelectSubset<T, MedicationAdministrationDeleteArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicationAdministration.
     * @param {MedicationAdministrationUpdateArgs} args - Arguments to update one MedicationAdministration.
     * @example
     * // Update one MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationAdministrationUpdateArgs>(args: SelectSubset<T, MedicationAdministrationUpdateArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicationAdministrations.
     * @param {MedicationAdministrationDeleteManyArgs} args - Arguments to filter MedicationAdministrations to delete.
     * @example
     * // Delete a few MedicationAdministrations
     * const { count } = await prisma.medicationAdministration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationAdministrationDeleteManyArgs>(args?: SelectSubset<T, MedicationAdministrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationAdministrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicationAdministrations
     * const medicationAdministration = await prisma.medicationAdministration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationAdministrationUpdateManyArgs>(args: SelectSubset<T, MedicationAdministrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationAdministrations and returns the data updated in the database.
     * @param {MedicationAdministrationUpdateManyAndReturnArgs} args - Arguments to update many MedicationAdministrations.
     * @example
     * // Update many MedicationAdministrations
     * const medicationAdministration = await prisma.medicationAdministration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicationAdministrations and only return the `id`
     * const medicationAdministrationWithIdOnly = await prisma.medicationAdministration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicationAdministrationUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicationAdministrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicationAdministration.
     * @param {MedicationAdministrationUpsertArgs} args - Arguments to update or create a MedicationAdministration.
     * @example
     * // Update or create a MedicationAdministration
     * const medicationAdministration = await prisma.medicationAdministration.upsert({
     *   create: {
     *     // ... data to create a MedicationAdministration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicationAdministration we want to update
     *   }
     * })
     */
    upsert<T extends MedicationAdministrationUpsertArgs>(args: SelectSubset<T, MedicationAdministrationUpsertArgs<ExtArgs>>): Prisma__MedicationAdministrationClient<$Result.GetResult<Prisma.$MedicationAdministrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicationAdministrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationCountArgs} args - Arguments to filter MedicationAdministrations to count.
     * @example
     * // Count the number of MedicationAdministrations
     * const count = await prisma.medicationAdministration.count({
     *   where: {
     *     // ... the filter for the MedicationAdministrations we want to count
     *   }
     * })
    **/
    count<T extends MedicationAdministrationCountArgs>(
      args?: Subset<T, MedicationAdministrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationAdministrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicationAdministration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAdministrationAggregateArgs>(args: Subset<T, MedicationAdministrationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAdministrationAggregateType<T>>

    /**
     * Group by MedicationAdministration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAdministrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationAdministrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationAdministrationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationAdministrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationAdministrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationAdministrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicationAdministration model
   */
  readonly fields: MedicationAdministrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicationAdministration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationAdministrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medication<T extends MedicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationDefaultArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends MedicationAdministration$userArgs<ExtArgs> = {}>(args?: Subset<T, MedicationAdministration$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicationAdministration model
   */
  interface MedicationAdministrationFieldRefs {
    readonly id: FieldRef<"MedicationAdministration", 'String'>
    readonly patientId: FieldRef<"MedicationAdministration", 'String'>
    readonly medicationId: FieldRef<"MedicationAdministration", 'String'>
    readonly status: FieldRef<"MedicationAdministration", 'String'>
    readonly dose: FieldRef<"MedicationAdministration", 'String'>
    readonly timestamp: FieldRef<"MedicationAdministration", 'DateTime'>
    readonly userId: FieldRef<"MedicationAdministration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MedicationAdministration findUnique
   */
  export type MedicationAdministrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration findUniqueOrThrow
   */
  export type MedicationAdministrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration findFirst
   */
  export type MedicationAdministrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationAdministrations.
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationAdministrations.
     */
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * MedicationAdministration findFirstOrThrow
   */
  export type MedicationAdministrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministration to fetch.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationAdministrations.
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationAdministrations.
     */
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * MedicationAdministration findMany
   */
  export type MedicationAdministrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter, which MedicationAdministrations to fetch.
     */
    where?: MedicationAdministrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationAdministrations to fetch.
     */
    orderBy?: MedicationAdministrationOrderByWithRelationInput | MedicationAdministrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicationAdministrations.
     */
    cursor?: MedicationAdministrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationAdministrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationAdministrations.
     */
    skip?: number
    distinct?: MedicationAdministrationScalarFieldEnum | MedicationAdministrationScalarFieldEnum[]
  }

  /**
   * MedicationAdministration create
   */
  export type MedicationAdministrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicationAdministration.
     */
    data: XOR<MedicationAdministrationCreateInput, MedicationAdministrationUncheckedCreateInput>
  }

  /**
   * MedicationAdministration createMany
   */
  export type MedicationAdministrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicationAdministrations.
     */
    data: MedicationAdministrationCreateManyInput | MedicationAdministrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicationAdministration createManyAndReturn
   */
  export type MedicationAdministrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * The data used to create many MedicationAdministrations.
     */
    data: MedicationAdministrationCreateManyInput | MedicationAdministrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationAdministration update
   */
  export type MedicationAdministrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicationAdministration.
     */
    data: XOR<MedicationAdministrationUpdateInput, MedicationAdministrationUncheckedUpdateInput>
    /**
     * Choose, which MedicationAdministration to update.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration updateMany
   */
  export type MedicationAdministrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicationAdministrations.
     */
    data: XOR<MedicationAdministrationUpdateManyMutationInput, MedicationAdministrationUncheckedUpdateManyInput>
    /**
     * Filter which MedicationAdministrations to update
     */
    where?: MedicationAdministrationWhereInput
    /**
     * Limit how many MedicationAdministrations to update.
     */
    limit?: number
  }

  /**
   * MedicationAdministration updateManyAndReturn
   */
  export type MedicationAdministrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * The data used to update MedicationAdministrations.
     */
    data: XOR<MedicationAdministrationUpdateManyMutationInput, MedicationAdministrationUncheckedUpdateManyInput>
    /**
     * Filter which MedicationAdministrations to update
     */
    where?: MedicationAdministrationWhereInput
    /**
     * Limit how many MedicationAdministrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationAdministration upsert
   */
  export type MedicationAdministrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicationAdministration to update in case it exists.
     */
    where: MedicationAdministrationWhereUniqueInput
    /**
     * In case the MedicationAdministration found by the `where` argument doesn't exist, create a new MedicationAdministration with this data.
     */
    create: XOR<MedicationAdministrationCreateInput, MedicationAdministrationUncheckedCreateInput>
    /**
     * In case the MedicationAdministration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationAdministrationUpdateInput, MedicationAdministrationUncheckedUpdateInput>
  }

  /**
   * MedicationAdministration delete
   */
  export type MedicationAdministrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
    /**
     * Filter which MedicationAdministration to delete.
     */
    where: MedicationAdministrationWhereUniqueInput
  }

  /**
   * MedicationAdministration deleteMany
   */
  export type MedicationAdministrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationAdministrations to delete
     */
    where?: MedicationAdministrationWhereInput
    /**
     * Limit how many MedicationAdministrations to delete.
     */
    limit?: number
  }

  /**
   * MedicationAdministration.user
   */
  export type MedicationAdministration$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MedicationAdministration without action
   */
  export type MedicationAdministrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationAdministration
     */
    select?: MedicationAdministrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicationAdministration
     */
    omit?: MedicationAdministrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationAdministrationInclude<ExtArgs> | null
  }


  /**
   * Model IntakeOutput
   */

  export type AggregateIntakeOutput = {
    _count: IntakeOutputCountAggregateOutputType | null
    _avg: IntakeOutputAvgAggregateOutputType | null
    _sum: IntakeOutputSumAggregateOutputType | null
    _min: IntakeOutputMinAggregateOutputType | null
    _max: IntakeOutputMaxAggregateOutputType | null
  }

  export type IntakeOutputAvgAggregateOutputType = {
    amount: number | null
  }

  export type IntakeOutputSumAggregateOutputType = {
    amount: number | null
  }

  export type IntakeOutputMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    userId: string | null
    shiftId: string | null
    type: string | null
    category: string | null
    amount: number | null
    notes: string | null
    timestamp: Date | null
  }

  export type IntakeOutputMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    userId: string | null
    shiftId: string | null
    type: string | null
    category: string | null
    amount: number | null
    notes: string | null
    timestamp: Date | null
  }

  export type IntakeOutputCountAggregateOutputType = {
    id: number
    patientId: number
    userId: number
    shiftId: number
    type: number
    category: number
    amount: number
    notes: number
    timestamp: number
    _all: number
  }


  export type IntakeOutputAvgAggregateInputType = {
    amount?: true
  }

  export type IntakeOutputSumAggregateInputType = {
    amount?: true
  }

  export type IntakeOutputMinAggregateInputType = {
    id?: true
    patientId?: true
    userId?: true
    shiftId?: true
    type?: true
    category?: true
    amount?: true
    notes?: true
    timestamp?: true
  }

  export type IntakeOutputMaxAggregateInputType = {
    id?: true
    patientId?: true
    userId?: true
    shiftId?: true
    type?: true
    category?: true
    amount?: true
    notes?: true
    timestamp?: true
  }

  export type IntakeOutputCountAggregateInputType = {
    id?: true
    patientId?: true
    userId?: true
    shiftId?: true
    type?: true
    category?: true
    amount?: true
    notes?: true
    timestamp?: true
    _all?: true
  }

  export type IntakeOutputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntakeOutput to aggregate.
     */
    where?: IntakeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntakeOutputs to fetch.
     */
    orderBy?: IntakeOutputOrderByWithRelationInput | IntakeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntakeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntakeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntakeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntakeOutputs
    **/
    _count?: true | IntakeOutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntakeOutputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntakeOutputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntakeOutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntakeOutputMaxAggregateInputType
  }

  export type GetIntakeOutputAggregateType<T extends IntakeOutputAggregateArgs> = {
        [P in keyof T & keyof AggregateIntakeOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntakeOutput[P]>
      : GetScalarType<T[P], AggregateIntakeOutput[P]>
  }




  export type IntakeOutputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntakeOutputWhereInput
    orderBy?: IntakeOutputOrderByWithAggregationInput | IntakeOutputOrderByWithAggregationInput[]
    by: IntakeOutputScalarFieldEnum[] | IntakeOutputScalarFieldEnum
    having?: IntakeOutputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntakeOutputCountAggregateInputType | true
    _avg?: IntakeOutputAvgAggregateInputType
    _sum?: IntakeOutputSumAggregateInputType
    _min?: IntakeOutputMinAggregateInputType
    _max?: IntakeOutputMaxAggregateInputType
  }

  export type IntakeOutputGroupByOutputType = {
    id: string
    patientId: string
    userId: string
    shiftId: string | null
    type: string
    category: string
    amount: number
    notes: string | null
    timestamp: Date
    _count: IntakeOutputCountAggregateOutputType | null
    _avg: IntakeOutputAvgAggregateOutputType | null
    _sum: IntakeOutputSumAggregateOutputType | null
    _min: IntakeOutputMinAggregateOutputType | null
    _max: IntakeOutputMaxAggregateOutputType | null
  }

  type GetIntakeOutputGroupByPayload<T extends IntakeOutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntakeOutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntakeOutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntakeOutputGroupByOutputType[P]>
            : GetScalarType<T[P], IntakeOutputGroupByOutputType[P]>
        }
      >
    >


  export type IntakeOutputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    notes?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | IntakeOutput$shiftArgs<ExtArgs>
  }, ExtArgs["result"]["intakeOutput"]>

  export type IntakeOutputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    notes?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | IntakeOutput$shiftArgs<ExtArgs>
  }, ExtArgs["result"]["intakeOutput"]>

  export type IntakeOutputSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    notes?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | IntakeOutput$shiftArgs<ExtArgs>
  }, ExtArgs["result"]["intakeOutput"]>

  export type IntakeOutputSelectScalar = {
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    notes?: boolean
    timestamp?: boolean
  }

  export type IntakeOutputOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "userId" | "shiftId" | "type" | "category" | "amount" | "notes" | "timestamp", ExtArgs["result"]["intakeOutput"]>
  export type IntakeOutputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | IntakeOutput$shiftArgs<ExtArgs>
  }
  export type IntakeOutputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | IntakeOutput$shiftArgs<ExtArgs>
  }
  export type IntakeOutputIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | IntakeOutput$shiftArgs<ExtArgs>
  }

  export type $IntakeOutputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntakeOutput"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      userId: string
      shiftId: string | null
      type: string
      category: string
      amount: number
      notes: string | null
      timestamp: Date
    }, ExtArgs["result"]["intakeOutput"]>
    composites: {}
  }

  type IntakeOutputGetPayload<S extends boolean | null | undefined | IntakeOutputDefaultArgs> = $Result.GetResult<Prisma.$IntakeOutputPayload, S>

  type IntakeOutputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntakeOutputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntakeOutputCountAggregateInputType | true
    }

  export interface IntakeOutputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntakeOutput'], meta: { name: 'IntakeOutput' } }
    /**
     * Find zero or one IntakeOutput that matches the filter.
     * @param {IntakeOutputFindUniqueArgs} args - Arguments to find a IntakeOutput
     * @example
     * // Get one IntakeOutput
     * const intakeOutput = await prisma.intakeOutput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntakeOutputFindUniqueArgs>(args: SelectSubset<T, IntakeOutputFindUniqueArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntakeOutput that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntakeOutputFindUniqueOrThrowArgs} args - Arguments to find a IntakeOutput
     * @example
     * // Get one IntakeOutput
     * const intakeOutput = await prisma.intakeOutput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntakeOutputFindUniqueOrThrowArgs>(args: SelectSubset<T, IntakeOutputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntakeOutput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntakeOutputFindFirstArgs} args - Arguments to find a IntakeOutput
     * @example
     * // Get one IntakeOutput
     * const intakeOutput = await prisma.intakeOutput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntakeOutputFindFirstArgs>(args?: SelectSubset<T, IntakeOutputFindFirstArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntakeOutput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntakeOutputFindFirstOrThrowArgs} args - Arguments to find a IntakeOutput
     * @example
     * // Get one IntakeOutput
     * const intakeOutput = await prisma.intakeOutput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntakeOutputFindFirstOrThrowArgs>(args?: SelectSubset<T, IntakeOutputFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntakeOutputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntakeOutputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntakeOutputs
     * const intakeOutputs = await prisma.intakeOutput.findMany()
     * 
     * // Get first 10 IntakeOutputs
     * const intakeOutputs = await prisma.intakeOutput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intakeOutputWithIdOnly = await prisma.intakeOutput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntakeOutputFindManyArgs>(args?: SelectSubset<T, IntakeOutputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntakeOutput.
     * @param {IntakeOutputCreateArgs} args - Arguments to create a IntakeOutput.
     * @example
     * // Create one IntakeOutput
     * const IntakeOutput = await prisma.intakeOutput.create({
     *   data: {
     *     // ... data to create a IntakeOutput
     *   }
     * })
     * 
     */
    create<T extends IntakeOutputCreateArgs>(args: SelectSubset<T, IntakeOutputCreateArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntakeOutputs.
     * @param {IntakeOutputCreateManyArgs} args - Arguments to create many IntakeOutputs.
     * @example
     * // Create many IntakeOutputs
     * const intakeOutput = await prisma.intakeOutput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntakeOutputCreateManyArgs>(args?: SelectSubset<T, IntakeOutputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntakeOutputs and returns the data saved in the database.
     * @param {IntakeOutputCreateManyAndReturnArgs} args - Arguments to create many IntakeOutputs.
     * @example
     * // Create many IntakeOutputs
     * const intakeOutput = await prisma.intakeOutput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntakeOutputs and only return the `id`
     * const intakeOutputWithIdOnly = await prisma.intakeOutput.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntakeOutputCreateManyAndReturnArgs>(args?: SelectSubset<T, IntakeOutputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntakeOutput.
     * @param {IntakeOutputDeleteArgs} args - Arguments to delete one IntakeOutput.
     * @example
     * // Delete one IntakeOutput
     * const IntakeOutput = await prisma.intakeOutput.delete({
     *   where: {
     *     // ... filter to delete one IntakeOutput
     *   }
     * })
     * 
     */
    delete<T extends IntakeOutputDeleteArgs>(args: SelectSubset<T, IntakeOutputDeleteArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntakeOutput.
     * @param {IntakeOutputUpdateArgs} args - Arguments to update one IntakeOutput.
     * @example
     * // Update one IntakeOutput
     * const intakeOutput = await prisma.intakeOutput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntakeOutputUpdateArgs>(args: SelectSubset<T, IntakeOutputUpdateArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntakeOutputs.
     * @param {IntakeOutputDeleteManyArgs} args - Arguments to filter IntakeOutputs to delete.
     * @example
     * // Delete a few IntakeOutputs
     * const { count } = await prisma.intakeOutput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntakeOutputDeleteManyArgs>(args?: SelectSubset<T, IntakeOutputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntakeOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntakeOutputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntakeOutputs
     * const intakeOutput = await prisma.intakeOutput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntakeOutputUpdateManyArgs>(args: SelectSubset<T, IntakeOutputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntakeOutputs and returns the data updated in the database.
     * @param {IntakeOutputUpdateManyAndReturnArgs} args - Arguments to update many IntakeOutputs.
     * @example
     * // Update many IntakeOutputs
     * const intakeOutput = await prisma.intakeOutput.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IntakeOutputs and only return the `id`
     * const intakeOutputWithIdOnly = await prisma.intakeOutput.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntakeOutputUpdateManyAndReturnArgs>(args: SelectSubset<T, IntakeOutputUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IntakeOutput.
     * @param {IntakeOutputUpsertArgs} args - Arguments to update or create a IntakeOutput.
     * @example
     * // Update or create a IntakeOutput
     * const intakeOutput = await prisma.intakeOutput.upsert({
     *   create: {
     *     // ... data to create a IntakeOutput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntakeOutput we want to update
     *   }
     * })
     */
    upsert<T extends IntakeOutputUpsertArgs>(args: SelectSubset<T, IntakeOutputUpsertArgs<ExtArgs>>): Prisma__IntakeOutputClient<$Result.GetResult<Prisma.$IntakeOutputPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntakeOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntakeOutputCountArgs} args - Arguments to filter IntakeOutputs to count.
     * @example
     * // Count the number of IntakeOutputs
     * const count = await prisma.intakeOutput.count({
     *   where: {
     *     // ... the filter for the IntakeOutputs we want to count
     *   }
     * })
    **/
    count<T extends IntakeOutputCountArgs>(
      args?: Subset<T, IntakeOutputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntakeOutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntakeOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntakeOutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntakeOutputAggregateArgs>(args: Subset<T, IntakeOutputAggregateArgs>): Prisma.PrismaPromise<GetIntakeOutputAggregateType<T>>

    /**
     * Group by IntakeOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntakeOutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntakeOutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntakeOutputGroupByArgs['orderBy'] }
        : { orderBy?: IntakeOutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntakeOutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntakeOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntakeOutput model
   */
  readonly fields: IntakeOutputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntakeOutput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntakeOutputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends IntakeOutput$shiftArgs<ExtArgs> = {}>(args?: Subset<T, IntakeOutput$shiftArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntakeOutput model
   */
  interface IntakeOutputFieldRefs {
    readonly id: FieldRef<"IntakeOutput", 'String'>
    readonly patientId: FieldRef<"IntakeOutput", 'String'>
    readonly userId: FieldRef<"IntakeOutput", 'String'>
    readonly shiftId: FieldRef<"IntakeOutput", 'String'>
    readonly type: FieldRef<"IntakeOutput", 'String'>
    readonly category: FieldRef<"IntakeOutput", 'String'>
    readonly amount: FieldRef<"IntakeOutput", 'Float'>
    readonly notes: FieldRef<"IntakeOutput", 'String'>
    readonly timestamp: FieldRef<"IntakeOutput", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntakeOutput findUnique
   */
  export type IntakeOutputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * Filter, which IntakeOutput to fetch.
     */
    where: IntakeOutputWhereUniqueInput
  }

  /**
   * IntakeOutput findUniqueOrThrow
   */
  export type IntakeOutputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * Filter, which IntakeOutput to fetch.
     */
    where: IntakeOutputWhereUniqueInput
  }

  /**
   * IntakeOutput findFirst
   */
  export type IntakeOutputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * Filter, which IntakeOutput to fetch.
     */
    where?: IntakeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntakeOutputs to fetch.
     */
    orderBy?: IntakeOutputOrderByWithRelationInput | IntakeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntakeOutputs.
     */
    cursor?: IntakeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntakeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntakeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntakeOutputs.
     */
    distinct?: IntakeOutputScalarFieldEnum | IntakeOutputScalarFieldEnum[]
  }

  /**
   * IntakeOutput findFirstOrThrow
   */
  export type IntakeOutputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * Filter, which IntakeOutput to fetch.
     */
    where?: IntakeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntakeOutputs to fetch.
     */
    orderBy?: IntakeOutputOrderByWithRelationInput | IntakeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntakeOutputs.
     */
    cursor?: IntakeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntakeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntakeOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntakeOutputs.
     */
    distinct?: IntakeOutputScalarFieldEnum | IntakeOutputScalarFieldEnum[]
  }

  /**
   * IntakeOutput findMany
   */
  export type IntakeOutputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * Filter, which IntakeOutputs to fetch.
     */
    where?: IntakeOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntakeOutputs to fetch.
     */
    orderBy?: IntakeOutputOrderByWithRelationInput | IntakeOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntakeOutputs.
     */
    cursor?: IntakeOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntakeOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntakeOutputs.
     */
    skip?: number
    distinct?: IntakeOutputScalarFieldEnum | IntakeOutputScalarFieldEnum[]
  }

  /**
   * IntakeOutput create
   */
  export type IntakeOutputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * The data needed to create a IntakeOutput.
     */
    data: XOR<IntakeOutputCreateInput, IntakeOutputUncheckedCreateInput>
  }

  /**
   * IntakeOutput createMany
   */
  export type IntakeOutputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntakeOutputs.
     */
    data: IntakeOutputCreateManyInput | IntakeOutputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntakeOutput createManyAndReturn
   */
  export type IntakeOutputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * The data used to create many IntakeOutputs.
     */
    data: IntakeOutputCreateManyInput | IntakeOutputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntakeOutput update
   */
  export type IntakeOutputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * The data needed to update a IntakeOutput.
     */
    data: XOR<IntakeOutputUpdateInput, IntakeOutputUncheckedUpdateInput>
    /**
     * Choose, which IntakeOutput to update.
     */
    where: IntakeOutputWhereUniqueInput
  }

  /**
   * IntakeOutput updateMany
   */
  export type IntakeOutputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntakeOutputs.
     */
    data: XOR<IntakeOutputUpdateManyMutationInput, IntakeOutputUncheckedUpdateManyInput>
    /**
     * Filter which IntakeOutputs to update
     */
    where?: IntakeOutputWhereInput
    /**
     * Limit how many IntakeOutputs to update.
     */
    limit?: number
  }

  /**
   * IntakeOutput updateManyAndReturn
   */
  export type IntakeOutputUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * The data used to update IntakeOutputs.
     */
    data: XOR<IntakeOutputUpdateManyMutationInput, IntakeOutputUncheckedUpdateManyInput>
    /**
     * Filter which IntakeOutputs to update
     */
    where?: IntakeOutputWhereInput
    /**
     * Limit how many IntakeOutputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntakeOutput upsert
   */
  export type IntakeOutputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * The filter to search for the IntakeOutput to update in case it exists.
     */
    where: IntakeOutputWhereUniqueInput
    /**
     * In case the IntakeOutput found by the `where` argument doesn't exist, create a new IntakeOutput with this data.
     */
    create: XOR<IntakeOutputCreateInput, IntakeOutputUncheckedCreateInput>
    /**
     * In case the IntakeOutput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntakeOutputUpdateInput, IntakeOutputUncheckedUpdateInput>
  }

  /**
   * IntakeOutput delete
   */
  export type IntakeOutputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
    /**
     * Filter which IntakeOutput to delete.
     */
    where: IntakeOutputWhereUniqueInput
  }

  /**
   * IntakeOutput deleteMany
   */
  export type IntakeOutputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntakeOutputs to delete
     */
    where?: IntakeOutputWhereInput
    /**
     * Limit how many IntakeOutputs to delete.
     */
    limit?: number
  }

  /**
   * IntakeOutput.shift
   */
  export type IntakeOutput$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
  }

  /**
   * IntakeOutput without action
   */
  export type IntakeOutputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntakeOutput
     */
    select?: IntakeOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntakeOutput
     */
    omit?: IntakeOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntakeOutputInclude<ExtArgs> | null
  }


  /**
   * Model NurseCheckIn
   */

  export type AggregateNurseCheckIn = {
    _count: NurseCheckInCountAggregateOutputType | null
    _min: NurseCheckInMinAggregateOutputType | null
    _max: NurseCheckInMaxAggregateOutputType | null
  }

  export type NurseCheckInMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    userId: string | null
    shiftId: string | null
    airwaySafe: boolean | null
    breathingOk: boolean | null
    circulationOk: boolean | null
    notes: string | null
    timestamp: Date | null
  }

  export type NurseCheckInMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    userId: string | null
    shiftId: string | null
    airwaySafe: boolean | null
    breathingOk: boolean | null
    circulationOk: boolean | null
    notes: string | null
    timestamp: Date | null
  }

  export type NurseCheckInCountAggregateOutputType = {
    id: number
    patientId: number
    userId: number
    shiftId: number
    airwaySafe: number
    breathingOk: number
    circulationOk: number
    notes: number
    timestamp: number
    _all: number
  }


  export type NurseCheckInMinAggregateInputType = {
    id?: true
    patientId?: true
    userId?: true
    shiftId?: true
    airwaySafe?: true
    breathingOk?: true
    circulationOk?: true
    notes?: true
    timestamp?: true
  }

  export type NurseCheckInMaxAggregateInputType = {
    id?: true
    patientId?: true
    userId?: true
    shiftId?: true
    airwaySafe?: true
    breathingOk?: true
    circulationOk?: true
    notes?: true
    timestamp?: true
  }

  export type NurseCheckInCountAggregateInputType = {
    id?: true
    patientId?: true
    userId?: true
    shiftId?: true
    airwaySafe?: true
    breathingOk?: true
    circulationOk?: true
    notes?: true
    timestamp?: true
    _all?: true
  }

  export type NurseCheckInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseCheckIn to aggregate.
     */
    where?: NurseCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseCheckIns to fetch.
     */
    orderBy?: NurseCheckInOrderByWithRelationInput | NurseCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NurseCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NurseCheckIns
    **/
    _count?: true | NurseCheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NurseCheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NurseCheckInMaxAggregateInputType
  }

  export type GetNurseCheckInAggregateType<T extends NurseCheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateNurseCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNurseCheckIn[P]>
      : GetScalarType<T[P], AggregateNurseCheckIn[P]>
  }




  export type NurseCheckInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseCheckInWhereInput
    orderBy?: NurseCheckInOrderByWithAggregationInput | NurseCheckInOrderByWithAggregationInput[]
    by: NurseCheckInScalarFieldEnum[] | NurseCheckInScalarFieldEnum
    having?: NurseCheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NurseCheckInCountAggregateInputType | true
    _min?: NurseCheckInMinAggregateInputType
    _max?: NurseCheckInMaxAggregateInputType
  }

  export type NurseCheckInGroupByOutputType = {
    id: string
    patientId: string
    userId: string
    shiftId: string | null
    airwaySafe: boolean
    breathingOk: boolean
    circulationOk: boolean
    notes: string | null
    timestamp: Date
    _count: NurseCheckInCountAggregateOutputType | null
    _min: NurseCheckInMinAggregateOutputType | null
    _max: NurseCheckInMaxAggregateOutputType | null
  }

  type GetNurseCheckInGroupByPayload<T extends NurseCheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NurseCheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NurseCheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NurseCheckInGroupByOutputType[P]>
            : GetScalarType<T[P], NurseCheckInGroupByOutputType[P]>
        }
      >
    >


  export type NurseCheckInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | NurseCheckIn$shiftArgs<ExtArgs>
  }, ExtArgs["result"]["nurseCheckIn"]>

  export type NurseCheckInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | NurseCheckIn$shiftArgs<ExtArgs>
  }, ExtArgs["result"]["nurseCheckIn"]>

  export type NurseCheckInSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: boolean
    timestamp?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | NurseCheckIn$shiftArgs<ExtArgs>
  }, ExtArgs["result"]["nurseCheckIn"]>

  export type NurseCheckInSelectScalar = {
    id?: boolean
    patientId?: boolean
    userId?: boolean
    shiftId?: boolean
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: boolean
    timestamp?: boolean
  }

  export type NurseCheckInOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "userId" | "shiftId" | "airwaySafe" | "breathingOk" | "circulationOk" | "notes" | "timestamp", ExtArgs["result"]["nurseCheckIn"]>
  export type NurseCheckInInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | NurseCheckIn$shiftArgs<ExtArgs>
  }
  export type NurseCheckInIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | NurseCheckIn$shiftArgs<ExtArgs>
  }
  export type NurseCheckInIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    shift?: boolean | NurseCheckIn$shiftArgs<ExtArgs>
  }

  export type $NurseCheckInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NurseCheckIn"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      userId: string
      shiftId: string | null
      airwaySafe: boolean
      breathingOk: boolean
      circulationOk: boolean
      notes: string | null
      timestamp: Date
    }, ExtArgs["result"]["nurseCheckIn"]>
    composites: {}
  }

  type NurseCheckInGetPayload<S extends boolean | null | undefined | NurseCheckInDefaultArgs> = $Result.GetResult<Prisma.$NurseCheckInPayload, S>

  type NurseCheckInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NurseCheckInFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NurseCheckInCountAggregateInputType | true
    }

  export interface NurseCheckInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NurseCheckIn'], meta: { name: 'NurseCheckIn' } }
    /**
     * Find zero or one NurseCheckIn that matches the filter.
     * @param {NurseCheckInFindUniqueArgs} args - Arguments to find a NurseCheckIn
     * @example
     * // Get one NurseCheckIn
     * const nurseCheckIn = await prisma.nurseCheckIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NurseCheckInFindUniqueArgs>(args: SelectSubset<T, NurseCheckInFindUniqueArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NurseCheckIn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NurseCheckInFindUniqueOrThrowArgs} args - Arguments to find a NurseCheckIn
     * @example
     * // Get one NurseCheckIn
     * const nurseCheckIn = await prisma.nurseCheckIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NurseCheckInFindUniqueOrThrowArgs>(args: SelectSubset<T, NurseCheckInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NurseCheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCheckInFindFirstArgs} args - Arguments to find a NurseCheckIn
     * @example
     * // Get one NurseCheckIn
     * const nurseCheckIn = await prisma.nurseCheckIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NurseCheckInFindFirstArgs>(args?: SelectSubset<T, NurseCheckInFindFirstArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NurseCheckIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCheckInFindFirstOrThrowArgs} args - Arguments to find a NurseCheckIn
     * @example
     * // Get one NurseCheckIn
     * const nurseCheckIn = await prisma.nurseCheckIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NurseCheckInFindFirstOrThrowArgs>(args?: SelectSubset<T, NurseCheckInFindFirstOrThrowArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NurseCheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCheckInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NurseCheckIns
     * const nurseCheckIns = await prisma.nurseCheckIn.findMany()
     * 
     * // Get first 10 NurseCheckIns
     * const nurseCheckIns = await prisma.nurseCheckIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nurseCheckInWithIdOnly = await prisma.nurseCheckIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NurseCheckInFindManyArgs>(args?: SelectSubset<T, NurseCheckInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NurseCheckIn.
     * @param {NurseCheckInCreateArgs} args - Arguments to create a NurseCheckIn.
     * @example
     * // Create one NurseCheckIn
     * const NurseCheckIn = await prisma.nurseCheckIn.create({
     *   data: {
     *     // ... data to create a NurseCheckIn
     *   }
     * })
     * 
     */
    create<T extends NurseCheckInCreateArgs>(args: SelectSubset<T, NurseCheckInCreateArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NurseCheckIns.
     * @param {NurseCheckInCreateManyArgs} args - Arguments to create many NurseCheckIns.
     * @example
     * // Create many NurseCheckIns
     * const nurseCheckIn = await prisma.nurseCheckIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NurseCheckInCreateManyArgs>(args?: SelectSubset<T, NurseCheckInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NurseCheckIns and returns the data saved in the database.
     * @param {NurseCheckInCreateManyAndReturnArgs} args - Arguments to create many NurseCheckIns.
     * @example
     * // Create many NurseCheckIns
     * const nurseCheckIn = await prisma.nurseCheckIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NurseCheckIns and only return the `id`
     * const nurseCheckInWithIdOnly = await prisma.nurseCheckIn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NurseCheckInCreateManyAndReturnArgs>(args?: SelectSubset<T, NurseCheckInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NurseCheckIn.
     * @param {NurseCheckInDeleteArgs} args - Arguments to delete one NurseCheckIn.
     * @example
     * // Delete one NurseCheckIn
     * const NurseCheckIn = await prisma.nurseCheckIn.delete({
     *   where: {
     *     // ... filter to delete one NurseCheckIn
     *   }
     * })
     * 
     */
    delete<T extends NurseCheckInDeleteArgs>(args: SelectSubset<T, NurseCheckInDeleteArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NurseCheckIn.
     * @param {NurseCheckInUpdateArgs} args - Arguments to update one NurseCheckIn.
     * @example
     * // Update one NurseCheckIn
     * const nurseCheckIn = await prisma.nurseCheckIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NurseCheckInUpdateArgs>(args: SelectSubset<T, NurseCheckInUpdateArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NurseCheckIns.
     * @param {NurseCheckInDeleteManyArgs} args - Arguments to filter NurseCheckIns to delete.
     * @example
     * // Delete a few NurseCheckIns
     * const { count } = await prisma.nurseCheckIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NurseCheckInDeleteManyArgs>(args?: SelectSubset<T, NurseCheckInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NurseCheckIns
     * const nurseCheckIn = await prisma.nurseCheckIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NurseCheckInUpdateManyArgs>(args: SelectSubset<T, NurseCheckInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseCheckIns and returns the data updated in the database.
     * @param {NurseCheckInUpdateManyAndReturnArgs} args - Arguments to update many NurseCheckIns.
     * @example
     * // Update many NurseCheckIns
     * const nurseCheckIn = await prisma.nurseCheckIn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NurseCheckIns and only return the `id`
     * const nurseCheckInWithIdOnly = await prisma.nurseCheckIn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NurseCheckInUpdateManyAndReturnArgs>(args: SelectSubset<T, NurseCheckInUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NurseCheckIn.
     * @param {NurseCheckInUpsertArgs} args - Arguments to update or create a NurseCheckIn.
     * @example
     * // Update or create a NurseCheckIn
     * const nurseCheckIn = await prisma.nurseCheckIn.upsert({
     *   create: {
     *     // ... data to create a NurseCheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NurseCheckIn we want to update
     *   }
     * })
     */
    upsert<T extends NurseCheckInUpsertArgs>(args: SelectSubset<T, NurseCheckInUpsertArgs<ExtArgs>>): Prisma__NurseCheckInClient<$Result.GetResult<Prisma.$NurseCheckInPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NurseCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCheckInCountArgs} args - Arguments to filter NurseCheckIns to count.
     * @example
     * // Count the number of NurseCheckIns
     * const count = await prisma.nurseCheckIn.count({
     *   where: {
     *     // ... the filter for the NurseCheckIns we want to count
     *   }
     * })
    **/
    count<T extends NurseCheckInCountArgs>(
      args?: Subset<T, NurseCheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NurseCheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NurseCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NurseCheckInAggregateArgs>(args: Subset<T, NurseCheckInAggregateArgs>): Prisma.PrismaPromise<GetNurseCheckInAggregateType<T>>

    /**
     * Group by NurseCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseCheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NurseCheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NurseCheckInGroupByArgs['orderBy'] }
        : { orderBy?: NurseCheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NurseCheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNurseCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NurseCheckIn model
   */
  readonly fields: NurseCheckInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NurseCheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NurseCheckInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends NurseCheckIn$shiftArgs<ExtArgs> = {}>(args?: Subset<T, NurseCheckIn$shiftArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NurseCheckIn model
   */
  interface NurseCheckInFieldRefs {
    readonly id: FieldRef<"NurseCheckIn", 'String'>
    readonly patientId: FieldRef<"NurseCheckIn", 'String'>
    readonly userId: FieldRef<"NurseCheckIn", 'String'>
    readonly shiftId: FieldRef<"NurseCheckIn", 'String'>
    readonly airwaySafe: FieldRef<"NurseCheckIn", 'Boolean'>
    readonly breathingOk: FieldRef<"NurseCheckIn", 'Boolean'>
    readonly circulationOk: FieldRef<"NurseCheckIn", 'Boolean'>
    readonly notes: FieldRef<"NurseCheckIn", 'String'>
    readonly timestamp: FieldRef<"NurseCheckIn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NurseCheckIn findUnique
   */
  export type NurseCheckInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NurseCheckIn to fetch.
     */
    where: NurseCheckInWhereUniqueInput
  }

  /**
   * NurseCheckIn findUniqueOrThrow
   */
  export type NurseCheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NurseCheckIn to fetch.
     */
    where: NurseCheckInWhereUniqueInput
  }

  /**
   * NurseCheckIn findFirst
   */
  export type NurseCheckInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NurseCheckIn to fetch.
     */
    where?: NurseCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseCheckIns to fetch.
     */
    orderBy?: NurseCheckInOrderByWithRelationInput | NurseCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseCheckIns.
     */
    cursor?: NurseCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseCheckIns.
     */
    distinct?: NurseCheckInScalarFieldEnum | NurseCheckInScalarFieldEnum[]
  }

  /**
   * NurseCheckIn findFirstOrThrow
   */
  export type NurseCheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NurseCheckIn to fetch.
     */
    where?: NurseCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseCheckIns to fetch.
     */
    orderBy?: NurseCheckInOrderByWithRelationInput | NurseCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseCheckIns.
     */
    cursor?: NurseCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseCheckIns.
     */
    distinct?: NurseCheckInScalarFieldEnum | NurseCheckInScalarFieldEnum[]
  }

  /**
   * NurseCheckIn findMany
   */
  export type NurseCheckInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NurseCheckIns to fetch.
     */
    where?: NurseCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseCheckIns to fetch.
     */
    orderBy?: NurseCheckInOrderByWithRelationInput | NurseCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NurseCheckIns.
     */
    cursor?: NurseCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseCheckIns.
     */
    skip?: number
    distinct?: NurseCheckInScalarFieldEnum | NurseCheckInScalarFieldEnum[]
  }

  /**
   * NurseCheckIn create
   */
  export type NurseCheckInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a NurseCheckIn.
     */
    data: XOR<NurseCheckInCreateInput, NurseCheckInUncheckedCreateInput>
  }

  /**
   * NurseCheckIn createMany
   */
  export type NurseCheckInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NurseCheckIns.
     */
    data: NurseCheckInCreateManyInput | NurseCheckInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NurseCheckIn createManyAndReturn
   */
  export type NurseCheckInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * The data used to create many NurseCheckIns.
     */
    data: NurseCheckInCreateManyInput | NurseCheckInCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NurseCheckIn update
   */
  export type NurseCheckInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a NurseCheckIn.
     */
    data: XOR<NurseCheckInUpdateInput, NurseCheckInUncheckedUpdateInput>
    /**
     * Choose, which NurseCheckIn to update.
     */
    where: NurseCheckInWhereUniqueInput
  }

  /**
   * NurseCheckIn updateMany
   */
  export type NurseCheckInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NurseCheckIns.
     */
    data: XOR<NurseCheckInUpdateManyMutationInput, NurseCheckInUncheckedUpdateManyInput>
    /**
     * Filter which NurseCheckIns to update
     */
    where?: NurseCheckInWhereInput
    /**
     * Limit how many NurseCheckIns to update.
     */
    limit?: number
  }

  /**
   * NurseCheckIn updateManyAndReturn
   */
  export type NurseCheckInUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * The data used to update NurseCheckIns.
     */
    data: XOR<NurseCheckInUpdateManyMutationInput, NurseCheckInUncheckedUpdateManyInput>
    /**
     * Filter which NurseCheckIns to update
     */
    where?: NurseCheckInWhereInput
    /**
     * Limit how many NurseCheckIns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NurseCheckIn upsert
   */
  export type NurseCheckInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the NurseCheckIn to update in case it exists.
     */
    where: NurseCheckInWhereUniqueInput
    /**
     * In case the NurseCheckIn found by the `where` argument doesn't exist, create a new NurseCheckIn with this data.
     */
    create: XOR<NurseCheckInCreateInput, NurseCheckInUncheckedCreateInput>
    /**
     * In case the NurseCheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NurseCheckInUpdateInput, NurseCheckInUncheckedUpdateInput>
  }

  /**
   * NurseCheckIn delete
   */
  export type NurseCheckInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
    /**
     * Filter which NurseCheckIn to delete.
     */
    where: NurseCheckInWhereUniqueInput
  }

  /**
   * NurseCheckIn deleteMany
   */
  export type NurseCheckInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseCheckIns to delete
     */
    where?: NurseCheckInWhereInput
    /**
     * Limit how many NurseCheckIns to delete.
     */
    limit?: number
  }

  /**
   * NurseCheckIn.shift
   */
  export type NurseCheckIn$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
  }

  /**
   * NurseCheckIn without action
   */
  export type NurseCheckInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseCheckIn
     */
    select?: NurseCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NurseCheckIn
     */
    omit?: NurseCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseCheckInInclude<ExtArgs> | null
  }


  /**
   * Model Governorate
   */

  export type AggregateGovernorate = {
    _count: GovernorateCountAggregateOutputType | null
    _min: GovernorateMinAggregateOutputType | null
    _max: GovernorateMaxAggregateOutputType | null
  }

  export type GovernorateMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernorateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernorateCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GovernorateMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernorateMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernorateCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GovernorateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Governorate to aggregate.
     */
    where?: GovernorateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Governorates to fetch.
     */
    orderBy?: GovernorateOrderByWithRelationInput | GovernorateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GovernorateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Governorates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Governorates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Governorates
    **/
    _count?: true | GovernorateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GovernorateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GovernorateMaxAggregateInputType
  }

  export type GetGovernorateAggregateType<T extends GovernorateAggregateArgs> = {
        [P in keyof T & keyof AggregateGovernorate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGovernorate[P]>
      : GetScalarType<T[P], AggregateGovernorate[P]>
  }




  export type GovernorateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernorateWhereInput
    orderBy?: GovernorateOrderByWithAggregationInput | GovernorateOrderByWithAggregationInput[]
    by: GovernorateScalarFieldEnum[] | GovernorateScalarFieldEnum
    having?: GovernorateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GovernorateCountAggregateInputType | true
    _min?: GovernorateMinAggregateInputType
    _max?: GovernorateMaxAggregateInputType
  }

  export type GovernorateGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: GovernorateCountAggregateOutputType | null
    _min: GovernorateMinAggregateOutputType | null
    _max: GovernorateMaxAggregateOutputType | null
  }

  type GetGovernorateGroupByPayload<T extends GovernorateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GovernorateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GovernorateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GovernorateGroupByOutputType[P]>
            : GetScalarType<T[P], GovernorateGroupByOutputType[P]>
        }
      >
    >


  export type GovernorateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["governorate"]>

  export type GovernorateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["governorate"]>

  export type GovernorateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["governorate"]>

  export type GovernorateSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GovernorateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["governorate"]>

  export type $GovernoratePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Governorate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["governorate"]>
    composites: {}
  }

  type GovernorateGetPayload<S extends boolean | null | undefined | GovernorateDefaultArgs> = $Result.GetResult<Prisma.$GovernoratePayload, S>

  type GovernorateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GovernorateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GovernorateCountAggregateInputType | true
    }

  export interface GovernorateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Governorate'], meta: { name: 'Governorate' } }
    /**
     * Find zero or one Governorate that matches the filter.
     * @param {GovernorateFindUniqueArgs} args - Arguments to find a Governorate
     * @example
     * // Get one Governorate
     * const governorate = await prisma.governorate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GovernorateFindUniqueArgs>(args: SelectSubset<T, GovernorateFindUniqueArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Governorate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GovernorateFindUniqueOrThrowArgs} args - Arguments to find a Governorate
     * @example
     * // Get one Governorate
     * const governorate = await prisma.governorate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GovernorateFindUniqueOrThrowArgs>(args: SelectSubset<T, GovernorateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Governorate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernorateFindFirstArgs} args - Arguments to find a Governorate
     * @example
     * // Get one Governorate
     * const governorate = await prisma.governorate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GovernorateFindFirstArgs>(args?: SelectSubset<T, GovernorateFindFirstArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Governorate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernorateFindFirstOrThrowArgs} args - Arguments to find a Governorate
     * @example
     * // Get one Governorate
     * const governorate = await prisma.governorate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GovernorateFindFirstOrThrowArgs>(args?: SelectSubset<T, GovernorateFindFirstOrThrowArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Governorates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernorateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Governorates
     * const governorates = await prisma.governorate.findMany()
     * 
     * // Get first 10 Governorates
     * const governorates = await prisma.governorate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const governorateWithIdOnly = await prisma.governorate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GovernorateFindManyArgs>(args?: SelectSubset<T, GovernorateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Governorate.
     * @param {GovernorateCreateArgs} args - Arguments to create a Governorate.
     * @example
     * // Create one Governorate
     * const Governorate = await prisma.governorate.create({
     *   data: {
     *     // ... data to create a Governorate
     *   }
     * })
     * 
     */
    create<T extends GovernorateCreateArgs>(args: SelectSubset<T, GovernorateCreateArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Governorates.
     * @param {GovernorateCreateManyArgs} args - Arguments to create many Governorates.
     * @example
     * // Create many Governorates
     * const governorate = await prisma.governorate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GovernorateCreateManyArgs>(args?: SelectSubset<T, GovernorateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Governorates and returns the data saved in the database.
     * @param {GovernorateCreateManyAndReturnArgs} args - Arguments to create many Governorates.
     * @example
     * // Create many Governorates
     * const governorate = await prisma.governorate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Governorates and only return the `id`
     * const governorateWithIdOnly = await prisma.governorate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GovernorateCreateManyAndReturnArgs>(args?: SelectSubset<T, GovernorateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Governorate.
     * @param {GovernorateDeleteArgs} args - Arguments to delete one Governorate.
     * @example
     * // Delete one Governorate
     * const Governorate = await prisma.governorate.delete({
     *   where: {
     *     // ... filter to delete one Governorate
     *   }
     * })
     * 
     */
    delete<T extends GovernorateDeleteArgs>(args: SelectSubset<T, GovernorateDeleteArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Governorate.
     * @param {GovernorateUpdateArgs} args - Arguments to update one Governorate.
     * @example
     * // Update one Governorate
     * const governorate = await prisma.governorate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GovernorateUpdateArgs>(args: SelectSubset<T, GovernorateUpdateArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Governorates.
     * @param {GovernorateDeleteManyArgs} args - Arguments to filter Governorates to delete.
     * @example
     * // Delete a few Governorates
     * const { count } = await prisma.governorate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GovernorateDeleteManyArgs>(args?: SelectSubset<T, GovernorateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Governorates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernorateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Governorates
     * const governorate = await prisma.governorate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GovernorateUpdateManyArgs>(args: SelectSubset<T, GovernorateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Governorates and returns the data updated in the database.
     * @param {GovernorateUpdateManyAndReturnArgs} args - Arguments to update many Governorates.
     * @example
     * // Update many Governorates
     * const governorate = await prisma.governorate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Governorates and only return the `id`
     * const governorateWithIdOnly = await prisma.governorate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GovernorateUpdateManyAndReturnArgs>(args: SelectSubset<T, GovernorateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Governorate.
     * @param {GovernorateUpsertArgs} args - Arguments to update or create a Governorate.
     * @example
     * // Update or create a Governorate
     * const governorate = await prisma.governorate.upsert({
     *   create: {
     *     // ... data to create a Governorate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Governorate we want to update
     *   }
     * })
     */
    upsert<T extends GovernorateUpsertArgs>(args: SelectSubset<T, GovernorateUpsertArgs<ExtArgs>>): Prisma__GovernorateClient<$Result.GetResult<Prisma.$GovernoratePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Governorates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernorateCountArgs} args - Arguments to filter Governorates to count.
     * @example
     * // Count the number of Governorates
     * const count = await prisma.governorate.count({
     *   where: {
     *     // ... the filter for the Governorates we want to count
     *   }
     * })
    **/
    count<T extends GovernorateCountArgs>(
      args?: Subset<T, GovernorateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GovernorateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Governorate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernorateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GovernorateAggregateArgs>(args: Subset<T, GovernorateAggregateArgs>): Prisma.PrismaPromise<GetGovernorateAggregateType<T>>

    /**
     * Group by Governorate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernorateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GovernorateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GovernorateGroupByArgs['orderBy'] }
        : { orderBy?: GovernorateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GovernorateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGovernorateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Governorate model
   */
  readonly fields: GovernorateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Governorate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GovernorateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Governorate model
   */
  interface GovernorateFieldRefs {
    readonly id: FieldRef<"Governorate", 'String'>
    readonly name: FieldRef<"Governorate", 'String'>
    readonly createdAt: FieldRef<"Governorate", 'DateTime'>
    readonly updatedAt: FieldRef<"Governorate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Governorate findUnique
   */
  export type GovernorateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * Filter, which Governorate to fetch.
     */
    where: GovernorateWhereUniqueInput
  }

  /**
   * Governorate findUniqueOrThrow
   */
  export type GovernorateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * Filter, which Governorate to fetch.
     */
    where: GovernorateWhereUniqueInput
  }

  /**
   * Governorate findFirst
   */
  export type GovernorateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * Filter, which Governorate to fetch.
     */
    where?: GovernorateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Governorates to fetch.
     */
    orderBy?: GovernorateOrderByWithRelationInput | GovernorateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Governorates.
     */
    cursor?: GovernorateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Governorates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Governorates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Governorates.
     */
    distinct?: GovernorateScalarFieldEnum | GovernorateScalarFieldEnum[]
  }

  /**
   * Governorate findFirstOrThrow
   */
  export type GovernorateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * Filter, which Governorate to fetch.
     */
    where?: GovernorateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Governorates to fetch.
     */
    orderBy?: GovernorateOrderByWithRelationInput | GovernorateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Governorates.
     */
    cursor?: GovernorateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Governorates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Governorates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Governorates.
     */
    distinct?: GovernorateScalarFieldEnum | GovernorateScalarFieldEnum[]
  }

  /**
   * Governorate findMany
   */
  export type GovernorateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * Filter, which Governorates to fetch.
     */
    where?: GovernorateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Governorates to fetch.
     */
    orderBy?: GovernorateOrderByWithRelationInput | GovernorateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Governorates.
     */
    cursor?: GovernorateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Governorates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Governorates.
     */
    skip?: number
    distinct?: GovernorateScalarFieldEnum | GovernorateScalarFieldEnum[]
  }

  /**
   * Governorate create
   */
  export type GovernorateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * The data needed to create a Governorate.
     */
    data: XOR<GovernorateCreateInput, GovernorateUncheckedCreateInput>
  }

  /**
   * Governorate createMany
   */
  export type GovernorateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Governorates.
     */
    data: GovernorateCreateManyInput | GovernorateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Governorate createManyAndReturn
   */
  export type GovernorateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * The data used to create many Governorates.
     */
    data: GovernorateCreateManyInput | GovernorateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Governorate update
   */
  export type GovernorateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * The data needed to update a Governorate.
     */
    data: XOR<GovernorateUpdateInput, GovernorateUncheckedUpdateInput>
    /**
     * Choose, which Governorate to update.
     */
    where: GovernorateWhereUniqueInput
  }

  /**
   * Governorate updateMany
   */
  export type GovernorateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Governorates.
     */
    data: XOR<GovernorateUpdateManyMutationInput, GovernorateUncheckedUpdateManyInput>
    /**
     * Filter which Governorates to update
     */
    where?: GovernorateWhereInput
    /**
     * Limit how many Governorates to update.
     */
    limit?: number
  }

  /**
   * Governorate updateManyAndReturn
   */
  export type GovernorateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * The data used to update Governorates.
     */
    data: XOR<GovernorateUpdateManyMutationInput, GovernorateUncheckedUpdateManyInput>
    /**
     * Filter which Governorates to update
     */
    where?: GovernorateWhereInput
    /**
     * Limit how many Governorates to update.
     */
    limit?: number
  }

  /**
   * Governorate upsert
   */
  export type GovernorateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * The filter to search for the Governorate to update in case it exists.
     */
    where: GovernorateWhereUniqueInput
    /**
     * In case the Governorate found by the `where` argument doesn't exist, create a new Governorate with this data.
     */
    create: XOR<GovernorateCreateInput, GovernorateUncheckedCreateInput>
    /**
     * In case the Governorate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GovernorateUpdateInput, GovernorateUncheckedUpdateInput>
  }

  /**
   * Governorate delete
   */
  export type GovernorateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
    /**
     * Filter which Governorate to delete.
     */
    where: GovernorateWhereUniqueInput
  }

  /**
   * Governorate deleteMany
   */
  export type GovernorateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Governorates to delete
     */
    where?: GovernorateWhereInput
    /**
     * Limit how many Governorates to delete.
     */
    limit?: number
  }

  /**
   * Governorate without action
   */
  export type GovernorateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Governorate
     */
    select?: GovernorateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Governorate
     */
    omit?: GovernorateOmit<ExtArgs> | null
  }


  /**
   * Model ClinicalOrder
   */

  export type AggregateClinicalOrder = {
    _count: ClinicalOrderCountAggregateOutputType | null
    _min: ClinicalOrderMinAggregateOutputType | null
    _max: ClinicalOrderMaxAggregateOutputType | null
  }

  export type ClinicalOrderMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    authorId: string | null
    approverId: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    priority: $Enums.Priority | null
    title: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicalOrderMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    authorId: string | null
    approverId: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    priority: $Enums.Priority | null
    title: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicalOrderCountAggregateOutputType = {
    id: number
    patientId: number
    authorId: number
    approverId: number
    type: number
    status: number
    priority: number
    title: number
    details: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicalOrderMinAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    approverId?: true
    type?: true
    status?: true
    priority?: true
    title?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicalOrderMaxAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    approverId?: true
    type?: true
    status?: true
    priority?: true
    title?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicalOrderCountAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    approverId?: true
    type?: true
    status?: true
    priority?: true
    title?: true
    details?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicalOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalOrder to aggregate.
     */
    where?: ClinicalOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalOrders to fetch.
     */
    orderBy?: ClinicalOrderOrderByWithRelationInput | ClinicalOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicalOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicalOrders
    **/
    _count?: true | ClinicalOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicalOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicalOrderMaxAggregateInputType
  }

  export type GetClinicalOrderAggregateType<T extends ClinicalOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicalOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicalOrder[P]>
      : GetScalarType<T[P], AggregateClinicalOrder[P]>
  }




  export type ClinicalOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalOrderWhereInput
    orderBy?: ClinicalOrderOrderByWithAggregationInput | ClinicalOrderOrderByWithAggregationInput[]
    by: ClinicalOrderScalarFieldEnum[] | ClinicalOrderScalarFieldEnum
    having?: ClinicalOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicalOrderCountAggregateInputType | true
    _min?: ClinicalOrderMinAggregateInputType
    _max?: ClinicalOrderMaxAggregateInputType
  }

  export type ClinicalOrderGroupByOutputType = {
    id: string
    patientId: string
    authorId: string
    approverId: string | null
    type: $Enums.OrderType
    status: $Enums.OrderStatus
    priority: $Enums.Priority
    title: string
    details: JsonValue | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClinicalOrderCountAggregateOutputType | null
    _min: ClinicalOrderMinAggregateOutputType | null
    _max: ClinicalOrderMaxAggregateOutputType | null
  }

  type GetClinicalOrderGroupByPayload<T extends ClinicalOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicalOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicalOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicalOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicalOrderGroupByOutputType[P]>
        }
      >
    >


  export type ClinicalOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    approverId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    title?: boolean
    details?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | ClinicalOrder$approverArgs<ExtArgs>
    investigations?: boolean | ClinicalOrder$investigationsArgs<ExtArgs>
    _count?: boolean | ClinicalOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalOrder"]>

  export type ClinicalOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    approverId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    title?: boolean
    details?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | ClinicalOrder$approverArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalOrder"]>

  export type ClinicalOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    approverId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    title?: boolean
    details?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | ClinicalOrder$approverArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalOrder"]>

  export type ClinicalOrderSelectScalar = {
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    approverId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    title?: boolean
    details?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicalOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "authorId" | "approverId" | "type" | "status" | "priority" | "title" | "details" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["clinicalOrder"]>
  export type ClinicalOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | ClinicalOrder$approverArgs<ExtArgs>
    investigations?: boolean | ClinicalOrder$investigationsArgs<ExtArgs>
    _count?: boolean | ClinicalOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicalOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | ClinicalOrder$approverArgs<ExtArgs>
  }
  export type ClinicalOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | ClinicalOrder$approverArgs<ExtArgs>
  }

  export type $ClinicalOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicalOrder"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      investigations: Prisma.$InvestigationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      authorId: string
      approverId: string | null
      type: $Enums.OrderType
      status: $Enums.OrderStatus
      priority: $Enums.Priority
      title: string
      details: Prisma.JsonValue | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicalOrder"]>
    composites: {}
  }

  type ClinicalOrderGetPayload<S extends boolean | null | undefined | ClinicalOrderDefaultArgs> = $Result.GetResult<Prisma.$ClinicalOrderPayload, S>

  type ClinicalOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicalOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicalOrderCountAggregateInputType | true
    }

  export interface ClinicalOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicalOrder'], meta: { name: 'ClinicalOrder' } }
    /**
     * Find zero or one ClinicalOrder that matches the filter.
     * @param {ClinicalOrderFindUniqueArgs} args - Arguments to find a ClinicalOrder
     * @example
     * // Get one ClinicalOrder
     * const clinicalOrder = await prisma.clinicalOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicalOrderFindUniqueArgs>(args: SelectSubset<T, ClinicalOrderFindUniqueArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicalOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicalOrderFindUniqueOrThrowArgs} args - Arguments to find a ClinicalOrder
     * @example
     * // Get one ClinicalOrder
     * const clinicalOrder = await prisma.clinicalOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicalOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicalOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalOrderFindFirstArgs} args - Arguments to find a ClinicalOrder
     * @example
     * // Get one ClinicalOrder
     * const clinicalOrder = await prisma.clinicalOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicalOrderFindFirstArgs>(args?: SelectSubset<T, ClinicalOrderFindFirstArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalOrderFindFirstOrThrowArgs} args - Arguments to find a ClinicalOrder
     * @example
     * // Get one ClinicalOrder
     * const clinicalOrder = await prisma.clinicalOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicalOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicalOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicalOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicalOrders
     * const clinicalOrders = await prisma.clinicalOrder.findMany()
     * 
     * // Get first 10 ClinicalOrders
     * const clinicalOrders = await prisma.clinicalOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicalOrderWithIdOnly = await prisma.clinicalOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicalOrderFindManyArgs>(args?: SelectSubset<T, ClinicalOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicalOrder.
     * @param {ClinicalOrderCreateArgs} args - Arguments to create a ClinicalOrder.
     * @example
     * // Create one ClinicalOrder
     * const ClinicalOrder = await prisma.clinicalOrder.create({
     *   data: {
     *     // ... data to create a ClinicalOrder
     *   }
     * })
     * 
     */
    create<T extends ClinicalOrderCreateArgs>(args: SelectSubset<T, ClinicalOrderCreateArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicalOrders.
     * @param {ClinicalOrderCreateManyArgs} args - Arguments to create many ClinicalOrders.
     * @example
     * // Create many ClinicalOrders
     * const clinicalOrder = await prisma.clinicalOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicalOrderCreateManyArgs>(args?: SelectSubset<T, ClinicalOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicalOrders and returns the data saved in the database.
     * @param {ClinicalOrderCreateManyAndReturnArgs} args - Arguments to create many ClinicalOrders.
     * @example
     * // Create many ClinicalOrders
     * const clinicalOrder = await prisma.clinicalOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicalOrders and only return the `id`
     * const clinicalOrderWithIdOnly = await prisma.clinicalOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicalOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicalOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicalOrder.
     * @param {ClinicalOrderDeleteArgs} args - Arguments to delete one ClinicalOrder.
     * @example
     * // Delete one ClinicalOrder
     * const ClinicalOrder = await prisma.clinicalOrder.delete({
     *   where: {
     *     // ... filter to delete one ClinicalOrder
     *   }
     * })
     * 
     */
    delete<T extends ClinicalOrderDeleteArgs>(args: SelectSubset<T, ClinicalOrderDeleteArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicalOrder.
     * @param {ClinicalOrderUpdateArgs} args - Arguments to update one ClinicalOrder.
     * @example
     * // Update one ClinicalOrder
     * const clinicalOrder = await prisma.clinicalOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicalOrderUpdateArgs>(args: SelectSubset<T, ClinicalOrderUpdateArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicalOrders.
     * @param {ClinicalOrderDeleteManyArgs} args - Arguments to filter ClinicalOrders to delete.
     * @example
     * // Delete a few ClinicalOrders
     * const { count } = await prisma.clinicalOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicalOrderDeleteManyArgs>(args?: SelectSubset<T, ClinicalOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicalOrders
     * const clinicalOrder = await prisma.clinicalOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicalOrderUpdateManyArgs>(args: SelectSubset<T, ClinicalOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalOrders and returns the data updated in the database.
     * @param {ClinicalOrderUpdateManyAndReturnArgs} args - Arguments to update many ClinicalOrders.
     * @example
     * // Update many ClinicalOrders
     * const clinicalOrder = await prisma.clinicalOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicalOrders and only return the `id`
     * const clinicalOrderWithIdOnly = await prisma.clinicalOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicalOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicalOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicalOrder.
     * @param {ClinicalOrderUpsertArgs} args - Arguments to update or create a ClinicalOrder.
     * @example
     * // Update or create a ClinicalOrder
     * const clinicalOrder = await prisma.clinicalOrder.upsert({
     *   create: {
     *     // ... data to create a ClinicalOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicalOrder we want to update
     *   }
     * })
     */
    upsert<T extends ClinicalOrderUpsertArgs>(args: SelectSubset<T, ClinicalOrderUpsertArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicalOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalOrderCountArgs} args - Arguments to filter ClinicalOrders to count.
     * @example
     * // Count the number of ClinicalOrders
     * const count = await prisma.clinicalOrder.count({
     *   where: {
     *     // ... the filter for the ClinicalOrders we want to count
     *   }
     * })
    **/
    count<T extends ClinicalOrderCountArgs>(
      args?: Subset<T, ClinicalOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicalOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicalOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicalOrderAggregateArgs>(args: Subset<T, ClinicalOrderAggregateArgs>): Prisma.PrismaPromise<GetClinicalOrderAggregateType<T>>

    /**
     * Group by ClinicalOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicalOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicalOrderGroupByArgs['orderBy'] }
        : { orderBy?: ClinicalOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicalOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicalOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicalOrder model
   */
  readonly fields: ClinicalOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicalOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicalOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends ClinicalOrder$approverArgs<ExtArgs> = {}>(args?: Subset<T, ClinicalOrder$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    investigations<T extends ClinicalOrder$investigationsArgs<ExtArgs> = {}>(args?: Subset<T, ClinicalOrder$investigationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicalOrder model
   */
  interface ClinicalOrderFieldRefs {
    readonly id: FieldRef<"ClinicalOrder", 'String'>
    readonly patientId: FieldRef<"ClinicalOrder", 'String'>
    readonly authorId: FieldRef<"ClinicalOrder", 'String'>
    readonly approverId: FieldRef<"ClinicalOrder", 'String'>
    readonly type: FieldRef<"ClinicalOrder", 'OrderType'>
    readonly status: FieldRef<"ClinicalOrder", 'OrderStatus'>
    readonly priority: FieldRef<"ClinicalOrder", 'Priority'>
    readonly title: FieldRef<"ClinicalOrder", 'String'>
    readonly details: FieldRef<"ClinicalOrder", 'Json'>
    readonly notes: FieldRef<"ClinicalOrder", 'String'>
    readonly createdAt: FieldRef<"ClinicalOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicalOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicalOrder findUnique
   */
  export type ClinicalOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalOrder to fetch.
     */
    where: ClinicalOrderWhereUniqueInput
  }

  /**
   * ClinicalOrder findUniqueOrThrow
   */
  export type ClinicalOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalOrder to fetch.
     */
    where: ClinicalOrderWhereUniqueInput
  }

  /**
   * ClinicalOrder findFirst
   */
  export type ClinicalOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalOrder to fetch.
     */
    where?: ClinicalOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalOrders to fetch.
     */
    orderBy?: ClinicalOrderOrderByWithRelationInput | ClinicalOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalOrders.
     */
    cursor?: ClinicalOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalOrders.
     */
    distinct?: ClinicalOrderScalarFieldEnum | ClinicalOrderScalarFieldEnum[]
  }

  /**
   * ClinicalOrder findFirstOrThrow
   */
  export type ClinicalOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalOrder to fetch.
     */
    where?: ClinicalOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalOrders to fetch.
     */
    orderBy?: ClinicalOrderOrderByWithRelationInput | ClinicalOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalOrders.
     */
    cursor?: ClinicalOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalOrders.
     */
    distinct?: ClinicalOrderScalarFieldEnum | ClinicalOrderScalarFieldEnum[]
  }

  /**
   * ClinicalOrder findMany
   */
  export type ClinicalOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalOrders to fetch.
     */
    where?: ClinicalOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalOrders to fetch.
     */
    orderBy?: ClinicalOrderOrderByWithRelationInput | ClinicalOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicalOrders.
     */
    cursor?: ClinicalOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalOrders.
     */
    skip?: number
    distinct?: ClinicalOrderScalarFieldEnum | ClinicalOrderScalarFieldEnum[]
  }

  /**
   * ClinicalOrder create
   */
  export type ClinicalOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicalOrder.
     */
    data: XOR<ClinicalOrderCreateInput, ClinicalOrderUncheckedCreateInput>
  }

  /**
   * ClinicalOrder createMany
   */
  export type ClinicalOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicalOrders.
     */
    data: ClinicalOrderCreateManyInput | ClinicalOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicalOrder createManyAndReturn
   */
  export type ClinicalOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicalOrders.
     */
    data: ClinicalOrderCreateManyInput | ClinicalOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalOrder update
   */
  export type ClinicalOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicalOrder.
     */
    data: XOR<ClinicalOrderUpdateInput, ClinicalOrderUncheckedUpdateInput>
    /**
     * Choose, which ClinicalOrder to update.
     */
    where: ClinicalOrderWhereUniqueInput
  }

  /**
   * ClinicalOrder updateMany
   */
  export type ClinicalOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicalOrders.
     */
    data: XOR<ClinicalOrderUpdateManyMutationInput, ClinicalOrderUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalOrders to update
     */
    where?: ClinicalOrderWhereInput
    /**
     * Limit how many ClinicalOrders to update.
     */
    limit?: number
  }

  /**
   * ClinicalOrder updateManyAndReturn
   */
  export type ClinicalOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * The data used to update ClinicalOrders.
     */
    data: XOR<ClinicalOrderUpdateManyMutationInput, ClinicalOrderUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalOrders to update
     */
    where?: ClinicalOrderWhereInput
    /**
     * Limit how many ClinicalOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalOrder upsert
   */
  export type ClinicalOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicalOrder to update in case it exists.
     */
    where: ClinicalOrderWhereUniqueInput
    /**
     * In case the ClinicalOrder found by the `where` argument doesn't exist, create a new ClinicalOrder with this data.
     */
    create: XOR<ClinicalOrderCreateInput, ClinicalOrderUncheckedCreateInput>
    /**
     * In case the ClinicalOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicalOrderUpdateInput, ClinicalOrderUncheckedUpdateInput>
  }

  /**
   * ClinicalOrder delete
   */
  export type ClinicalOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    /**
     * Filter which ClinicalOrder to delete.
     */
    where: ClinicalOrderWhereUniqueInput
  }

  /**
   * ClinicalOrder deleteMany
   */
  export type ClinicalOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalOrders to delete
     */
    where?: ClinicalOrderWhereInput
    /**
     * Limit how many ClinicalOrders to delete.
     */
    limit?: number
  }

  /**
   * ClinicalOrder.approver
   */
  export type ClinicalOrder$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ClinicalOrder.investigations
   */
  export type ClinicalOrder$investigationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    where?: InvestigationWhereInput
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    cursor?: InvestigationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * ClinicalOrder without action
   */
  export type ClinicalOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
  }


  /**
   * Model SpecialistNote
   */

  export type AggregateSpecialistNote = {
    _count: SpecialistNoteCountAggregateOutputType | null
    _min: SpecialistNoteMinAggregateOutputType | null
    _max: SpecialistNoteMaxAggregateOutputType | null
  }

  export type SpecialistNoteMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    authorId: string | null
    date: Date | null
    apacheScore: string | null
    histHT: boolean | null
    histDM: boolean | null
    histAsthma: boolean | null
    histCOPD: boolean | null
    histIHD: boolean | null
    histStroke: boolean | null
    histOther: string | null
    neuroGCS: string | null
    neuroRASS: string | null
    respChest: string | null
    respRoomAir: boolean | null
    respO2Therapy: boolean | null
    respVentMode: boolean | null
    respVentModeText: string | null
    respFio2: string | null
    respPS: string | null
    intCVLine: boolean | null
    intArtLine: boolean | null
    intETT: boolean | null
    intTrach: boolean | null
    intDoubleLumen: boolean | null
    hydNormovolemia: boolean | null
    hydHypervolemia: boolean | null
    hydHypovolemia: boolean | null
    hydUOP: string | null
    hydIVC: string | null
    hydCVP: string | null
    hemoStable: boolean | null
    hemoUnstable: boolean | null
    hemoVasopressor: boolean | null
    feedOral: boolean | null
    feedNG: boolean | null
    feedTPN: boolean | null
    feedRate: string | null
    ivFluidsRate: string | null
    sedPropofol: boolean | null
    sedKetamine: boolean | null
    sedMidazolam: boolean | null
    sedRemif: boolean | null
    sedMR: boolean | null
    sedOther: string | null
    clinicalNotes: string | null
    planVentilatory: string | null
    planPhysio: string | null
    planConsult: string | null
    planInvestigation: string | null
    planOther: string | null
    planFuture: string | null
    planHomeTeam: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialistNoteMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    authorId: string | null
    date: Date | null
    apacheScore: string | null
    histHT: boolean | null
    histDM: boolean | null
    histAsthma: boolean | null
    histCOPD: boolean | null
    histIHD: boolean | null
    histStroke: boolean | null
    histOther: string | null
    neuroGCS: string | null
    neuroRASS: string | null
    respChest: string | null
    respRoomAir: boolean | null
    respO2Therapy: boolean | null
    respVentMode: boolean | null
    respVentModeText: string | null
    respFio2: string | null
    respPS: string | null
    intCVLine: boolean | null
    intArtLine: boolean | null
    intETT: boolean | null
    intTrach: boolean | null
    intDoubleLumen: boolean | null
    hydNormovolemia: boolean | null
    hydHypervolemia: boolean | null
    hydHypovolemia: boolean | null
    hydUOP: string | null
    hydIVC: string | null
    hydCVP: string | null
    hemoStable: boolean | null
    hemoUnstable: boolean | null
    hemoVasopressor: boolean | null
    feedOral: boolean | null
    feedNG: boolean | null
    feedTPN: boolean | null
    feedRate: string | null
    ivFluidsRate: string | null
    sedPropofol: boolean | null
    sedKetamine: boolean | null
    sedMidazolam: boolean | null
    sedRemif: boolean | null
    sedMR: boolean | null
    sedOther: string | null
    clinicalNotes: string | null
    planVentilatory: string | null
    planPhysio: string | null
    planConsult: string | null
    planInvestigation: string | null
    planOther: string | null
    planFuture: string | null
    planHomeTeam: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialistNoteCountAggregateOutputType = {
    id: number
    patientId: number
    authorId: number
    date: number
    apacheScore: number
    histHT: number
    histDM: number
    histAsthma: number
    histCOPD: number
    histIHD: number
    histStroke: number
    histOther: number
    neuroGCS: number
    neuroRASS: number
    respChest: number
    respRoomAir: number
    respO2Therapy: number
    respVentMode: number
    respVentModeText: number
    respFio2: number
    respPS: number
    intCVLine: number
    intArtLine: number
    intETT: number
    intTrach: number
    intDoubleLumen: number
    hydNormovolemia: number
    hydHypervolemia: number
    hydHypovolemia: number
    hydUOP: number
    hydIVC: number
    hydCVP: number
    hemoStable: number
    hemoUnstable: number
    hemoVasopressor: number
    feedOral: number
    feedNG: number
    feedTPN: number
    feedRate: number
    ivFluidsRate: number
    sedPropofol: number
    sedKetamine: number
    sedMidazolam: number
    sedRemif: number
    sedMR: number
    sedOther: number
    clinicalNotes: number
    planVentilatory: number
    planPhysio: number
    planConsult: number
    planInvestigation: number
    planOther: number
    planFuture: number
    planHomeTeam: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialistNoteMinAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    date?: true
    apacheScore?: true
    histHT?: true
    histDM?: true
    histAsthma?: true
    histCOPD?: true
    histIHD?: true
    histStroke?: true
    histOther?: true
    neuroGCS?: true
    neuroRASS?: true
    respChest?: true
    respRoomAir?: true
    respO2Therapy?: true
    respVentMode?: true
    respVentModeText?: true
    respFio2?: true
    respPS?: true
    intCVLine?: true
    intArtLine?: true
    intETT?: true
    intTrach?: true
    intDoubleLumen?: true
    hydNormovolemia?: true
    hydHypervolemia?: true
    hydHypovolemia?: true
    hydUOP?: true
    hydIVC?: true
    hydCVP?: true
    hemoStable?: true
    hemoUnstable?: true
    hemoVasopressor?: true
    feedOral?: true
    feedNG?: true
    feedTPN?: true
    feedRate?: true
    ivFluidsRate?: true
    sedPropofol?: true
    sedKetamine?: true
    sedMidazolam?: true
    sedRemif?: true
    sedMR?: true
    sedOther?: true
    clinicalNotes?: true
    planVentilatory?: true
    planPhysio?: true
    planConsult?: true
    planInvestigation?: true
    planOther?: true
    planFuture?: true
    planHomeTeam?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialistNoteMaxAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    date?: true
    apacheScore?: true
    histHT?: true
    histDM?: true
    histAsthma?: true
    histCOPD?: true
    histIHD?: true
    histStroke?: true
    histOther?: true
    neuroGCS?: true
    neuroRASS?: true
    respChest?: true
    respRoomAir?: true
    respO2Therapy?: true
    respVentMode?: true
    respVentModeText?: true
    respFio2?: true
    respPS?: true
    intCVLine?: true
    intArtLine?: true
    intETT?: true
    intTrach?: true
    intDoubleLumen?: true
    hydNormovolemia?: true
    hydHypervolemia?: true
    hydHypovolemia?: true
    hydUOP?: true
    hydIVC?: true
    hydCVP?: true
    hemoStable?: true
    hemoUnstable?: true
    hemoVasopressor?: true
    feedOral?: true
    feedNG?: true
    feedTPN?: true
    feedRate?: true
    ivFluidsRate?: true
    sedPropofol?: true
    sedKetamine?: true
    sedMidazolam?: true
    sedRemif?: true
    sedMR?: true
    sedOther?: true
    clinicalNotes?: true
    planVentilatory?: true
    planPhysio?: true
    planConsult?: true
    planInvestigation?: true
    planOther?: true
    planFuture?: true
    planHomeTeam?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialistNoteCountAggregateInputType = {
    id?: true
    patientId?: true
    authorId?: true
    date?: true
    apacheScore?: true
    histHT?: true
    histDM?: true
    histAsthma?: true
    histCOPD?: true
    histIHD?: true
    histStroke?: true
    histOther?: true
    neuroGCS?: true
    neuroRASS?: true
    respChest?: true
    respRoomAir?: true
    respO2Therapy?: true
    respVentMode?: true
    respVentModeText?: true
    respFio2?: true
    respPS?: true
    intCVLine?: true
    intArtLine?: true
    intETT?: true
    intTrach?: true
    intDoubleLumen?: true
    hydNormovolemia?: true
    hydHypervolemia?: true
    hydHypovolemia?: true
    hydUOP?: true
    hydIVC?: true
    hydCVP?: true
    hemoStable?: true
    hemoUnstable?: true
    hemoVasopressor?: true
    feedOral?: true
    feedNG?: true
    feedTPN?: true
    feedRate?: true
    ivFluidsRate?: true
    sedPropofol?: true
    sedKetamine?: true
    sedMidazolam?: true
    sedRemif?: true
    sedMR?: true
    sedOther?: true
    clinicalNotes?: true
    planVentilatory?: true
    planPhysio?: true
    planConsult?: true
    planInvestigation?: true
    planOther?: true
    planFuture?: true
    planHomeTeam?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialistNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialistNote to aggregate.
     */
    where?: SpecialistNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialistNotes to fetch.
     */
    orderBy?: SpecialistNoteOrderByWithRelationInput | SpecialistNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialistNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialistNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialistNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecialistNotes
    **/
    _count?: true | SpecialistNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialistNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialistNoteMaxAggregateInputType
  }

  export type GetSpecialistNoteAggregateType<T extends SpecialistNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialistNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialistNote[P]>
      : GetScalarType<T[P], AggregateSpecialistNote[P]>
  }




  export type SpecialistNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialistNoteWhereInput
    orderBy?: SpecialistNoteOrderByWithAggregationInput | SpecialistNoteOrderByWithAggregationInput[]
    by: SpecialistNoteScalarFieldEnum[] | SpecialistNoteScalarFieldEnum
    having?: SpecialistNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialistNoteCountAggregateInputType | true
    _min?: SpecialistNoteMinAggregateInputType
    _max?: SpecialistNoteMaxAggregateInputType
  }

  export type SpecialistNoteGroupByOutputType = {
    id: string
    patientId: string
    authorId: string
    date: Date
    apacheScore: string | null
    histHT: boolean
    histDM: boolean
    histAsthma: boolean
    histCOPD: boolean
    histIHD: boolean
    histStroke: boolean
    histOther: string | null
    neuroGCS: string | null
    neuroRASS: string | null
    respChest: string | null
    respRoomAir: boolean
    respO2Therapy: boolean
    respVentMode: boolean
    respVentModeText: string | null
    respFio2: string | null
    respPS: string | null
    intCVLine: boolean
    intArtLine: boolean
    intETT: boolean
    intTrach: boolean
    intDoubleLumen: boolean
    hydNormovolemia: boolean
    hydHypervolemia: boolean
    hydHypovolemia: boolean
    hydUOP: string | null
    hydIVC: string | null
    hydCVP: string | null
    hemoStable: boolean
    hemoUnstable: boolean
    hemoVasopressor: boolean
    feedOral: boolean
    feedNG: boolean
    feedTPN: boolean
    feedRate: string | null
    ivFluidsRate: string | null
    sedPropofol: boolean
    sedKetamine: boolean
    sedMidazolam: boolean
    sedRemif: boolean
    sedMR: boolean
    sedOther: string | null
    clinicalNotes: string | null
    planVentilatory: string | null
    planPhysio: string | null
    planConsult: string | null
    planInvestigation: string | null
    planOther: string | null
    planFuture: string | null
    planHomeTeam: string | null
    createdAt: Date
    updatedAt: Date
    _count: SpecialistNoteCountAggregateOutputType | null
    _min: SpecialistNoteMinAggregateOutputType | null
    _max: SpecialistNoteMaxAggregateOutputType | null
  }

  type GetSpecialistNoteGroupByPayload<T extends SpecialistNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialistNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialistNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialistNoteGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialistNoteGroupByOutputType[P]>
        }
      >
    >


  export type SpecialistNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    date?: boolean
    apacheScore?: boolean
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: boolean
    neuroGCS?: boolean
    neuroRASS?: boolean
    respChest?: boolean
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: boolean
    respFio2?: boolean
    respPS?: boolean
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: boolean
    hydIVC?: boolean
    hydCVP?: boolean
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: boolean
    ivFluidsRate?: boolean
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: boolean
    clinicalNotes?: boolean
    planVentilatory?: boolean
    planPhysio?: boolean
    planConsult?: boolean
    planInvestigation?: boolean
    planOther?: boolean
    planFuture?: boolean
    planHomeTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialistNote"]>

  export type SpecialistNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    date?: boolean
    apacheScore?: boolean
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: boolean
    neuroGCS?: boolean
    neuroRASS?: boolean
    respChest?: boolean
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: boolean
    respFio2?: boolean
    respPS?: boolean
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: boolean
    hydIVC?: boolean
    hydCVP?: boolean
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: boolean
    ivFluidsRate?: boolean
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: boolean
    clinicalNotes?: boolean
    planVentilatory?: boolean
    planPhysio?: boolean
    planConsult?: boolean
    planInvestigation?: boolean
    planOther?: boolean
    planFuture?: boolean
    planHomeTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialistNote"]>

  export type SpecialistNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    date?: boolean
    apacheScore?: boolean
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: boolean
    neuroGCS?: boolean
    neuroRASS?: boolean
    respChest?: boolean
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: boolean
    respFio2?: boolean
    respPS?: boolean
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: boolean
    hydIVC?: boolean
    hydCVP?: boolean
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: boolean
    ivFluidsRate?: boolean
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: boolean
    clinicalNotes?: boolean
    planVentilatory?: boolean
    planPhysio?: boolean
    planConsult?: boolean
    planInvestigation?: boolean
    planOther?: boolean
    planFuture?: boolean
    planHomeTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialistNote"]>

  export type SpecialistNoteSelectScalar = {
    id?: boolean
    patientId?: boolean
    authorId?: boolean
    date?: boolean
    apacheScore?: boolean
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: boolean
    neuroGCS?: boolean
    neuroRASS?: boolean
    respChest?: boolean
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: boolean
    respFio2?: boolean
    respPS?: boolean
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: boolean
    hydIVC?: boolean
    hydCVP?: boolean
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: boolean
    ivFluidsRate?: boolean
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: boolean
    clinicalNotes?: boolean
    planVentilatory?: boolean
    planPhysio?: boolean
    planConsult?: boolean
    planInvestigation?: boolean
    planOther?: boolean
    planFuture?: boolean
    planHomeTeam?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialistNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "authorId" | "date" | "apacheScore" | "histHT" | "histDM" | "histAsthma" | "histCOPD" | "histIHD" | "histStroke" | "histOther" | "neuroGCS" | "neuroRASS" | "respChest" | "respRoomAir" | "respO2Therapy" | "respVentMode" | "respVentModeText" | "respFio2" | "respPS" | "intCVLine" | "intArtLine" | "intETT" | "intTrach" | "intDoubleLumen" | "hydNormovolemia" | "hydHypervolemia" | "hydHypovolemia" | "hydUOP" | "hydIVC" | "hydCVP" | "hemoStable" | "hemoUnstable" | "hemoVasopressor" | "feedOral" | "feedNG" | "feedTPN" | "feedRate" | "ivFluidsRate" | "sedPropofol" | "sedKetamine" | "sedMidazolam" | "sedRemif" | "sedMR" | "sedOther" | "clinicalNotes" | "planVentilatory" | "planPhysio" | "planConsult" | "planInvestigation" | "planOther" | "planFuture" | "planHomeTeam" | "createdAt" | "updatedAt", ExtArgs["result"]["specialistNote"]>
  export type SpecialistNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SpecialistNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SpecialistNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SpecialistNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecialistNote"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      authorId: string
      date: Date
      apacheScore: string | null
      histHT: boolean
      histDM: boolean
      histAsthma: boolean
      histCOPD: boolean
      histIHD: boolean
      histStroke: boolean
      histOther: string | null
      neuroGCS: string | null
      neuroRASS: string | null
      respChest: string | null
      respRoomAir: boolean
      respO2Therapy: boolean
      respVentMode: boolean
      respVentModeText: string | null
      respFio2: string | null
      respPS: string | null
      intCVLine: boolean
      intArtLine: boolean
      intETT: boolean
      intTrach: boolean
      intDoubleLumen: boolean
      hydNormovolemia: boolean
      hydHypervolemia: boolean
      hydHypovolemia: boolean
      hydUOP: string | null
      hydIVC: string | null
      hydCVP: string | null
      hemoStable: boolean
      hemoUnstable: boolean
      hemoVasopressor: boolean
      feedOral: boolean
      feedNG: boolean
      feedTPN: boolean
      feedRate: string | null
      ivFluidsRate: string | null
      sedPropofol: boolean
      sedKetamine: boolean
      sedMidazolam: boolean
      sedRemif: boolean
      sedMR: boolean
      sedOther: string | null
      clinicalNotes: string | null
      planVentilatory: string | null
      planPhysio: string | null
      planConsult: string | null
      planInvestigation: string | null
      planOther: string | null
      planFuture: string | null
      planHomeTeam: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialistNote"]>
    composites: {}
  }

  type SpecialistNoteGetPayload<S extends boolean | null | undefined | SpecialistNoteDefaultArgs> = $Result.GetResult<Prisma.$SpecialistNotePayload, S>

  type SpecialistNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecialistNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialistNoteCountAggregateInputType | true
    }

  export interface SpecialistNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecialistNote'], meta: { name: 'SpecialistNote' } }
    /**
     * Find zero or one SpecialistNote that matches the filter.
     * @param {SpecialistNoteFindUniqueArgs} args - Arguments to find a SpecialistNote
     * @example
     * // Get one SpecialistNote
     * const specialistNote = await prisma.specialistNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialistNoteFindUniqueArgs>(args: SelectSubset<T, SpecialistNoteFindUniqueArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecialistNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecialistNoteFindUniqueOrThrowArgs} args - Arguments to find a SpecialistNote
     * @example
     * // Get one SpecialistNote
     * const specialistNote = await prisma.specialistNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialistNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialistNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialistNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialistNoteFindFirstArgs} args - Arguments to find a SpecialistNote
     * @example
     * // Get one SpecialistNote
     * const specialistNote = await prisma.specialistNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialistNoteFindFirstArgs>(args?: SelectSubset<T, SpecialistNoteFindFirstArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialistNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialistNoteFindFirstOrThrowArgs} args - Arguments to find a SpecialistNote
     * @example
     * // Get one SpecialistNote
     * const specialistNote = await prisma.specialistNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialistNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialistNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecialistNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialistNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecialistNotes
     * const specialistNotes = await prisma.specialistNote.findMany()
     * 
     * // Get first 10 SpecialistNotes
     * const specialistNotes = await prisma.specialistNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialistNoteWithIdOnly = await prisma.specialistNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialistNoteFindManyArgs>(args?: SelectSubset<T, SpecialistNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecialistNote.
     * @param {SpecialistNoteCreateArgs} args - Arguments to create a SpecialistNote.
     * @example
     * // Create one SpecialistNote
     * const SpecialistNote = await prisma.specialistNote.create({
     *   data: {
     *     // ... data to create a SpecialistNote
     *   }
     * })
     * 
     */
    create<T extends SpecialistNoteCreateArgs>(args: SelectSubset<T, SpecialistNoteCreateArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecialistNotes.
     * @param {SpecialistNoteCreateManyArgs} args - Arguments to create many SpecialistNotes.
     * @example
     * // Create many SpecialistNotes
     * const specialistNote = await prisma.specialistNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialistNoteCreateManyArgs>(args?: SelectSubset<T, SpecialistNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecialistNotes and returns the data saved in the database.
     * @param {SpecialistNoteCreateManyAndReturnArgs} args - Arguments to create many SpecialistNotes.
     * @example
     * // Create many SpecialistNotes
     * const specialistNote = await prisma.specialistNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecialistNotes and only return the `id`
     * const specialistNoteWithIdOnly = await prisma.specialistNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialistNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialistNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecialistNote.
     * @param {SpecialistNoteDeleteArgs} args - Arguments to delete one SpecialistNote.
     * @example
     * // Delete one SpecialistNote
     * const SpecialistNote = await prisma.specialistNote.delete({
     *   where: {
     *     // ... filter to delete one SpecialistNote
     *   }
     * })
     * 
     */
    delete<T extends SpecialistNoteDeleteArgs>(args: SelectSubset<T, SpecialistNoteDeleteArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecialistNote.
     * @param {SpecialistNoteUpdateArgs} args - Arguments to update one SpecialistNote.
     * @example
     * // Update one SpecialistNote
     * const specialistNote = await prisma.specialistNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialistNoteUpdateArgs>(args: SelectSubset<T, SpecialistNoteUpdateArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecialistNotes.
     * @param {SpecialistNoteDeleteManyArgs} args - Arguments to filter SpecialistNotes to delete.
     * @example
     * // Delete a few SpecialistNotes
     * const { count } = await prisma.specialistNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialistNoteDeleteManyArgs>(args?: SelectSubset<T, SpecialistNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialistNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialistNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecialistNotes
     * const specialistNote = await prisma.specialistNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialistNoteUpdateManyArgs>(args: SelectSubset<T, SpecialistNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialistNotes and returns the data updated in the database.
     * @param {SpecialistNoteUpdateManyAndReturnArgs} args - Arguments to update many SpecialistNotes.
     * @example
     * // Update many SpecialistNotes
     * const specialistNote = await prisma.specialistNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpecialistNotes and only return the `id`
     * const specialistNoteWithIdOnly = await prisma.specialistNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecialistNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecialistNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpecialistNote.
     * @param {SpecialistNoteUpsertArgs} args - Arguments to update or create a SpecialistNote.
     * @example
     * // Update or create a SpecialistNote
     * const specialistNote = await prisma.specialistNote.upsert({
     *   create: {
     *     // ... data to create a SpecialistNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecialistNote we want to update
     *   }
     * })
     */
    upsert<T extends SpecialistNoteUpsertArgs>(args: SelectSubset<T, SpecialistNoteUpsertArgs<ExtArgs>>): Prisma__SpecialistNoteClient<$Result.GetResult<Prisma.$SpecialistNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecialistNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialistNoteCountArgs} args - Arguments to filter SpecialistNotes to count.
     * @example
     * // Count the number of SpecialistNotes
     * const count = await prisma.specialistNote.count({
     *   where: {
     *     // ... the filter for the SpecialistNotes we want to count
     *   }
     * })
    **/
    count<T extends SpecialistNoteCountArgs>(
      args?: Subset<T, SpecialistNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialistNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecialistNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialistNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialistNoteAggregateArgs>(args: Subset<T, SpecialistNoteAggregateArgs>): Prisma.PrismaPromise<GetSpecialistNoteAggregateType<T>>

    /**
     * Group by SpecialistNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialistNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialistNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialistNoteGroupByArgs['orderBy'] }
        : { orderBy?: SpecialistNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialistNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialistNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecialistNote model
   */
  readonly fields: SpecialistNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecialistNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialistNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecialistNote model
   */
  interface SpecialistNoteFieldRefs {
    readonly id: FieldRef<"SpecialistNote", 'String'>
    readonly patientId: FieldRef<"SpecialistNote", 'String'>
    readonly authorId: FieldRef<"SpecialistNote", 'String'>
    readonly date: FieldRef<"SpecialistNote", 'DateTime'>
    readonly apacheScore: FieldRef<"SpecialistNote", 'String'>
    readonly histHT: FieldRef<"SpecialistNote", 'Boolean'>
    readonly histDM: FieldRef<"SpecialistNote", 'Boolean'>
    readonly histAsthma: FieldRef<"SpecialistNote", 'Boolean'>
    readonly histCOPD: FieldRef<"SpecialistNote", 'Boolean'>
    readonly histIHD: FieldRef<"SpecialistNote", 'Boolean'>
    readonly histStroke: FieldRef<"SpecialistNote", 'Boolean'>
    readonly histOther: FieldRef<"SpecialistNote", 'String'>
    readonly neuroGCS: FieldRef<"SpecialistNote", 'String'>
    readonly neuroRASS: FieldRef<"SpecialistNote", 'String'>
    readonly respChest: FieldRef<"SpecialistNote", 'String'>
    readonly respRoomAir: FieldRef<"SpecialistNote", 'Boolean'>
    readonly respO2Therapy: FieldRef<"SpecialistNote", 'Boolean'>
    readonly respVentMode: FieldRef<"SpecialistNote", 'Boolean'>
    readonly respVentModeText: FieldRef<"SpecialistNote", 'String'>
    readonly respFio2: FieldRef<"SpecialistNote", 'String'>
    readonly respPS: FieldRef<"SpecialistNote", 'String'>
    readonly intCVLine: FieldRef<"SpecialistNote", 'Boolean'>
    readonly intArtLine: FieldRef<"SpecialistNote", 'Boolean'>
    readonly intETT: FieldRef<"SpecialistNote", 'Boolean'>
    readonly intTrach: FieldRef<"SpecialistNote", 'Boolean'>
    readonly intDoubleLumen: FieldRef<"SpecialistNote", 'Boolean'>
    readonly hydNormovolemia: FieldRef<"SpecialistNote", 'Boolean'>
    readonly hydHypervolemia: FieldRef<"SpecialistNote", 'Boolean'>
    readonly hydHypovolemia: FieldRef<"SpecialistNote", 'Boolean'>
    readonly hydUOP: FieldRef<"SpecialistNote", 'String'>
    readonly hydIVC: FieldRef<"SpecialistNote", 'String'>
    readonly hydCVP: FieldRef<"SpecialistNote", 'String'>
    readonly hemoStable: FieldRef<"SpecialistNote", 'Boolean'>
    readonly hemoUnstable: FieldRef<"SpecialistNote", 'Boolean'>
    readonly hemoVasopressor: FieldRef<"SpecialistNote", 'Boolean'>
    readonly feedOral: FieldRef<"SpecialistNote", 'Boolean'>
    readonly feedNG: FieldRef<"SpecialistNote", 'Boolean'>
    readonly feedTPN: FieldRef<"SpecialistNote", 'Boolean'>
    readonly feedRate: FieldRef<"SpecialistNote", 'String'>
    readonly ivFluidsRate: FieldRef<"SpecialistNote", 'String'>
    readonly sedPropofol: FieldRef<"SpecialistNote", 'Boolean'>
    readonly sedKetamine: FieldRef<"SpecialistNote", 'Boolean'>
    readonly sedMidazolam: FieldRef<"SpecialistNote", 'Boolean'>
    readonly sedRemif: FieldRef<"SpecialistNote", 'Boolean'>
    readonly sedMR: FieldRef<"SpecialistNote", 'Boolean'>
    readonly sedOther: FieldRef<"SpecialistNote", 'String'>
    readonly clinicalNotes: FieldRef<"SpecialistNote", 'String'>
    readonly planVentilatory: FieldRef<"SpecialistNote", 'String'>
    readonly planPhysio: FieldRef<"SpecialistNote", 'String'>
    readonly planConsult: FieldRef<"SpecialistNote", 'String'>
    readonly planInvestigation: FieldRef<"SpecialistNote", 'String'>
    readonly planOther: FieldRef<"SpecialistNote", 'String'>
    readonly planFuture: FieldRef<"SpecialistNote", 'String'>
    readonly planHomeTeam: FieldRef<"SpecialistNote", 'String'>
    readonly createdAt: FieldRef<"SpecialistNote", 'DateTime'>
    readonly updatedAt: FieldRef<"SpecialistNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpecialistNote findUnique
   */
  export type SpecialistNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * Filter, which SpecialistNote to fetch.
     */
    where: SpecialistNoteWhereUniqueInput
  }

  /**
   * SpecialistNote findUniqueOrThrow
   */
  export type SpecialistNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * Filter, which SpecialistNote to fetch.
     */
    where: SpecialistNoteWhereUniqueInput
  }

  /**
   * SpecialistNote findFirst
   */
  export type SpecialistNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * Filter, which SpecialistNote to fetch.
     */
    where?: SpecialistNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialistNotes to fetch.
     */
    orderBy?: SpecialistNoteOrderByWithRelationInput | SpecialistNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialistNotes.
     */
    cursor?: SpecialistNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialistNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialistNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialistNotes.
     */
    distinct?: SpecialistNoteScalarFieldEnum | SpecialistNoteScalarFieldEnum[]
  }

  /**
   * SpecialistNote findFirstOrThrow
   */
  export type SpecialistNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * Filter, which SpecialistNote to fetch.
     */
    where?: SpecialistNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialistNotes to fetch.
     */
    orderBy?: SpecialistNoteOrderByWithRelationInput | SpecialistNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialistNotes.
     */
    cursor?: SpecialistNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialistNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialistNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialistNotes.
     */
    distinct?: SpecialistNoteScalarFieldEnum | SpecialistNoteScalarFieldEnum[]
  }

  /**
   * SpecialistNote findMany
   */
  export type SpecialistNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * Filter, which SpecialistNotes to fetch.
     */
    where?: SpecialistNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialistNotes to fetch.
     */
    orderBy?: SpecialistNoteOrderByWithRelationInput | SpecialistNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecialistNotes.
     */
    cursor?: SpecialistNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialistNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialistNotes.
     */
    skip?: number
    distinct?: SpecialistNoteScalarFieldEnum | SpecialistNoteScalarFieldEnum[]
  }

  /**
   * SpecialistNote create
   */
  export type SpecialistNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecialistNote.
     */
    data: XOR<SpecialistNoteCreateInput, SpecialistNoteUncheckedCreateInput>
  }

  /**
   * SpecialistNote createMany
   */
  export type SpecialistNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecialistNotes.
     */
    data: SpecialistNoteCreateManyInput | SpecialistNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecialistNote createManyAndReturn
   */
  export type SpecialistNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * The data used to create many SpecialistNotes.
     */
    data: SpecialistNoteCreateManyInput | SpecialistNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecialistNote update
   */
  export type SpecialistNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecialistNote.
     */
    data: XOR<SpecialistNoteUpdateInput, SpecialistNoteUncheckedUpdateInput>
    /**
     * Choose, which SpecialistNote to update.
     */
    where: SpecialistNoteWhereUniqueInput
  }

  /**
   * SpecialistNote updateMany
   */
  export type SpecialistNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecialistNotes.
     */
    data: XOR<SpecialistNoteUpdateManyMutationInput, SpecialistNoteUncheckedUpdateManyInput>
    /**
     * Filter which SpecialistNotes to update
     */
    where?: SpecialistNoteWhereInput
    /**
     * Limit how many SpecialistNotes to update.
     */
    limit?: number
  }

  /**
   * SpecialistNote updateManyAndReturn
   */
  export type SpecialistNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * The data used to update SpecialistNotes.
     */
    data: XOR<SpecialistNoteUpdateManyMutationInput, SpecialistNoteUncheckedUpdateManyInput>
    /**
     * Filter which SpecialistNotes to update
     */
    where?: SpecialistNoteWhereInput
    /**
     * Limit how many SpecialistNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecialistNote upsert
   */
  export type SpecialistNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecialistNote to update in case it exists.
     */
    where: SpecialistNoteWhereUniqueInput
    /**
     * In case the SpecialistNote found by the `where` argument doesn't exist, create a new SpecialistNote with this data.
     */
    create: XOR<SpecialistNoteCreateInput, SpecialistNoteUncheckedCreateInput>
    /**
     * In case the SpecialistNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialistNoteUpdateInput, SpecialistNoteUncheckedUpdateInput>
  }

  /**
   * SpecialistNote delete
   */
  export type SpecialistNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
    /**
     * Filter which SpecialistNote to delete.
     */
    where: SpecialistNoteWhereUniqueInput
  }

  /**
   * SpecialistNote deleteMany
   */
  export type SpecialistNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialistNotes to delete
     */
    where?: SpecialistNoteWhereInput
    /**
     * Limit how many SpecialistNotes to delete.
     */
    limit?: number
  }

  /**
   * SpecialistNote without action
   */
  export type SpecialistNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialistNote
     */
    select?: SpecialistNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialistNote
     */
    omit?: SpecialistNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialistNoteInclude<ExtArgs> | null
  }


  /**
   * Model Investigation
   */

  export type AggregateInvestigation = {
    _count: InvestigationCountAggregateOutputType | null
    _min: InvestigationMinAggregateOutputType | null
    _max: InvestigationMaxAggregateOutputType | null
  }

  export type InvestigationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    orderId: string | null
    authorId: string | null
    type: $Enums.OrderType | null
    category: string | null
    title: string | null
    status: $Enums.InvestigationStatus | null
    impression: string | null
    conductedAt: Date | null
    createdAt: Date | null
  }

  export type InvestigationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    orderId: string | null
    authorId: string | null
    type: $Enums.OrderType | null
    category: string | null
    title: string | null
    status: $Enums.InvestigationStatus | null
    impression: string | null
    conductedAt: Date | null
    createdAt: Date | null
  }

  export type InvestigationCountAggregateOutputType = {
    id: number
    patientId: number
    orderId: number
    authorId: number
    type: number
    category: number
    title: number
    status: number
    result: number
    impression: number
    conductedAt: number
    createdAt: number
    _all: number
  }


  export type InvestigationMinAggregateInputType = {
    id?: true
    patientId?: true
    orderId?: true
    authorId?: true
    type?: true
    category?: true
    title?: true
    status?: true
    impression?: true
    conductedAt?: true
    createdAt?: true
  }

  export type InvestigationMaxAggregateInputType = {
    id?: true
    patientId?: true
    orderId?: true
    authorId?: true
    type?: true
    category?: true
    title?: true
    status?: true
    impression?: true
    conductedAt?: true
    createdAt?: true
  }

  export type InvestigationCountAggregateInputType = {
    id?: true
    patientId?: true
    orderId?: true
    authorId?: true
    type?: true
    category?: true
    title?: true
    status?: true
    result?: true
    impression?: true
    conductedAt?: true
    createdAt?: true
    _all?: true
  }

  export type InvestigationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investigation to aggregate.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investigations
    **/
    _count?: true | InvestigationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestigationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestigationMaxAggregateInputType
  }

  export type GetInvestigationAggregateType<T extends InvestigationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestigation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestigation[P]>
      : GetScalarType<T[P], AggregateInvestigation[P]>
  }




  export type InvestigationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestigationWhereInput
    orderBy?: InvestigationOrderByWithAggregationInput | InvestigationOrderByWithAggregationInput[]
    by: InvestigationScalarFieldEnum[] | InvestigationScalarFieldEnum
    having?: InvestigationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestigationCountAggregateInputType | true
    _min?: InvestigationMinAggregateInputType
    _max?: InvestigationMaxAggregateInputType
  }

  export type InvestigationGroupByOutputType = {
    id: string
    patientId: string
    orderId: string | null
    authorId: string
    type: $Enums.OrderType
    category: string
    title: string
    status: $Enums.InvestigationStatus
    result: JsonValue | null
    impression: string | null
    conductedAt: Date
    createdAt: Date
    _count: InvestigationCountAggregateOutputType | null
    _min: InvestigationMinAggregateOutputType | null
    _max: InvestigationMaxAggregateOutputType | null
  }

  type GetInvestigationGroupByPayload<T extends InvestigationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestigationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestigationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestigationGroupByOutputType[P]>
            : GetScalarType<T[P], InvestigationGroupByOutputType[P]>
        }
      >
    >


  export type InvestigationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    orderId?: boolean
    authorId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    status?: boolean
    result?: boolean
    impression?: boolean
    conductedAt?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    order?: boolean | Investigation$orderArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigation"]>

  export type InvestigationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    orderId?: boolean
    authorId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    status?: boolean
    result?: boolean
    impression?: boolean
    conductedAt?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    order?: boolean | Investigation$orderArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigation"]>

  export type InvestigationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    orderId?: boolean
    authorId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    status?: boolean
    result?: boolean
    impression?: boolean
    conductedAt?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    order?: boolean | Investigation$orderArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigation"]>

  export type InvestigationSelectScalar = {
    id?: boolean
    patientId?: boolean
    orderId?: boolean
    authorId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    status?: boolean
    result?: boolean
    impression?: boolean
    conductedAt?: boolean
    createdAt?: boolean
  }

  export type InvestigationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "orderId" | "authorId" | "type" | "category" | "title" | "status" | "result" | "impression" | "conductedAt" | "createdAt", ExtArgs["result"]["investigation"]>
  export type InvestigationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    order?: boolean | Investigation$orderArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvestigationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    order?: boolean | Investigation$orderArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvestigationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    order?: boolean | Investigation$orderArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvestigationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investigation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      order: Prisma.$ClinicalOrderPayload<ExtArgs> | null
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      orderId: string | null
      authorId: string
      type: $Enums.OrderType
      category: string
      title: string
      status: $Enums.InvestigationStatus
      result: Prisma.JsonValue | null
      impression: string | null
      conductedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["investigation"]>
    composites: {}
  }

  type InvestigationGetPayload<S extends boolean | null | undefined | InvestigationDefaultArgs> = $Result.GetResult<Prisma.$InvestigationPayload, S>

  type InvestigationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestigationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestigationCountAggregateInputType | true
    }

  export interface InvestigationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investigation'], meta: { name: 'Investigation' } }
    /**
     * Find zero or one Investigation that matches the filter.
     * @param {InvestigationFindUniqueArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestigationFindUniqueArgs>(args: SelectSubset<T, InvestigationFindUniqueArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Investigation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestigationFindUniqueOrThrowArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestigationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestigationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investigation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationFindFirstArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestigationFindFirstArgs>(args?: SelectSubset<T, InvestigationFindFirstArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investigation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationFindFirstOrThrowArgs} args - Arguments to find a Investigation
     * @example
     * // Get one Investigation
     * const investigation = await prisma.investigation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestigationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestigationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investigations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investigations
     * const investigations = await prisma.investigation.findMany()
     * 
     * // Get first 10 Investigations
     * const investigations = await prisma.investigation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investigationWithIdOnly = await prisma.investigation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestigationFindManyArgs>(args?: SelectSubset<T, InvestigationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Investigation.
     * @param {InvestigationCreateArgs} args - Arguments to create a Investigation.
     * @example
     * // Create one Investigation
     * const Investigation = await prisma.investigation.create({
     *   data: {
     *     // ... data to create a Investigation
     *   }
     * })
     * 
     */
    create<T extends InvestigationCreateArgs>(args: SelectSubset<T, InvestigationCreateArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Investigations.
     * @param {InvestigationCreateManyArgs} args - Arguments to create many Investigations.
     * @example
     * // Create many Investigations
     * const investigation = await prisma.investigation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestigationCreateManyArgs>(args?: SelectSubset<T, InvestigationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Investigations and returns the data saved in the database.
     * @param {InvestigationCreateManyAndReturnArgs} args - Arguments to create many Investigations.
     * @example
     * // Create many Investigations
     * const investigation = await prisma.investigation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Investigations and only return the `id`
     * const investigationWithIdOnly = await prisma.investigation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestigationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestigationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Investigation.
     * @param {InvestigationDeleteArgs} args - Arguments to delete one Investigation.
     * @example
     * // Delete one Investigation
     * const Investigation = await prisma.investigation.delete({
     *   where: {
     *     // ... filter to delete one Investigation
     *   }
     * })
     * 
     */
    delete<T extends InvestigationDeleteArgs>(args: SelectSubset<T, InvestigationDeleteArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Investigation.
     * @param {InvestigationUpdateArgs} args - Arguments to update one Investigation.
     * @example
     * // Update one Investigation
     * const investigation = await prisma.investigation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestigationUpdateArgs>(args: SelectSubset<T, InvestigationUpdateArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Investigations.
     * @param {InvestigationDeleteManyArgs} args - Arguments to filter Investigations to delete.
     * @example
     * // Delete a few Investigations
     * const { count } = await prisma.investigation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestigationDeleteManyArgs>(args?: SelectSubset<T, InvestigationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investigations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investigations
     * const investigation = await prisma.investigation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestigationUpdateManyArgs>(args: SelectSubset<T, InvestigationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investigations and returns the data updated in the database.
     * @param {InvestigationUpdateManyAndReturnArgs} args - Arguments to update many Investigations.
     * @example
     * // Update many Investigations
     * const investigation = await prisma.investigation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Investigations and only return the `id`
     * const investigationWithIdOnly = await prisma.investigation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestigationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestigationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Investigation.
     * @param {InvestigationUpsertArgs} args - Arguments to update or create a Investigation.
     * @example
     * // Update or create a Investigation
     * const investigation = await prisma.investigation.upsert({
     *   create: {
     *     // ... data to create a Investigation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investigation we want to update
     *   }
     * })
     */
    upsert<T extends InvestigationUpsertArgs>(args: SelectSubset<T, InvestigationUpsertArgs<ExtArgs>>): Prisma__InvestigationClient<$Result.GetResult<Prisma.$InvestigationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Investigations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationCountArgs} args - Arguments to filter Investigations to count.
     * @example
     * // Count the number of Investigations
     * const count = await prisma.investigation.count({
     *   where: {
     *     // ... the filter for the Investigations we want to count
     *   }
     * })
    **/
    count<T extends InvestigationCountArgs>(
      args?: Subset<T, InvestigationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestigationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investigation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestigationAggregateArgs>(args: Subset<T, InvestigationAggregateArgs>): Prisma.PrismaPromise<GetInvestigationAggregateType<T>>

    /**
     * Group by Investigation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestigationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestigationGroupByArgs['orderBy'] }
        : { orderBy?: InvestigationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestigationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestigationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investigation model
   */
  readonly fields: InvestigationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investigation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestigationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Investigation$orderArgs<ExtArgs> = {}>(args?: Subset<T, Investigation$orderArgs<ExtArgs>>): Prisma__ClinicalOrderClient<$Result.GetResult<Prisma.$ClinicalOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investigation model
   */
  interface InvestigationFieldRefs {
    readonly id: FieldRef<"Investigation", 'String'>
    readonly patientId: FieldRef<"Investigation", 'String'>
    readonly orderId: FieldRef<"Investigation", 'String'>
    readonly authorId: FieldRef<"Investigation", 'String'>
    readonly type: FieldRef<"Investigation", 'OrderType'>
    readonly category: FieldRef<"Investigation", 'String'>
    readonly title: FieldRef<"Investigation", 'String'>
    readonly status: FieldRef<"Investigation", 'InvestigationStatus'>
    readonly result: FieldRef<"Investigation", 'Json'>
    readonly impression: FieldRef<"Investigation", 'String'>
    readonly conductedAt: FieldRef<"Investigation", 'DateTime'>
    readonly createdAt: FieldRef<"Investigation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Investigation findUnique
   */
  export type InvestigationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation findUniqueOrThrow
   */
  export type InvestigationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation findFirst
   */
  export type InvestigationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investigations.
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investigations.
     */
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Investigation findFirstOrThrow
   */
  export type InvestigationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigation to fetch.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investigations.
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investigations.
     */
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Investigation findMany
   */
  export type InvestigationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter, which Investigations to fetch.
     */
    where?: InvestigationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investigations to fetch.
     */
    orderBy?: InvestigationOrderByWithRelationInput | InvestigationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investigations.
     */
    cursor?: InvestigationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investigations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investigations.
     */
    skip?: number
    distinct?: InvestigationScalarFieldEnum | InvestigationScalarFieldEnum[]
  }

  /**
   * Investigation create
   */
  export type InvestigationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * The data needed to create a Investigation.
     */
    data: XOR<InvestigationCreateInput, InvestigationUncheckedCreateInput>
  }

  /**
   * Investigation createMany
   */
  export type InvestigationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investigations.
     */
    data: InvestigationCreateManyInput | InvestigationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Investigation createManyAndReturn
   */
  export type InvestigationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * The data used to create many Investigations.
     */
    data: InvestigationCreateManyInput | InvestigationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investigation update
   */
  export type InvestigationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * The data needed to update a Investigation.
     */
    data: XOR<InvestigationUpdateInput, InvestigationUncheckedUpdateInput>
    /**
     * Choose, which Investigation to update.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation updateMany
   */
  export type InvestigationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investigations.
     */
    data: XOR<InvestigationUpdateManyMutationInput, InvestigationUncheckedUpdateManyInput>
    /**
     * Filter which Investigations to update
     */
    where?: InvestigationWhereInput
    /**
     * Limit how many Investigations to update.
     */
    limit?: number
  }

  /**
   * Investigation updateManyAndReturn
   */
  export type InvestigationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * The data used to update Investigations.
     */
    data: XOR<InvestigationUpdateManyMutationInput, InvestigationUncheckedUpdateManyInput>
    /**
     * Filter which Investigations to update
     */
    where?: InvestigationWhereInput
    /**
     * Limit how many Investigations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investigation upsert
   */
  export type InvestigationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * The filter to search for the Investigation to update in case it exists.
     */
    where: InvestigationWhereUniqueInput
    /**
     * In case the Investigation found by the `where` argument doesn't exist, create a new Investigation with this data.
     */
    create: XOR<InvestigationCreateInput, InvestigationUncheckedCreateInput>
    /**
     * In case the Investigation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestigationUpdateInput, InvestigationUncheckedUpdateInput>
  }

  /**
   * Investigation delete
   */
  export type InvestigationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
    /**
     * Filter which Investigation to delete.
     */
    where: InvestigationWhereUniqueInput
  }

  /**
   * Investigation deleteMany
   */
  export type InvestigationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investigations to delete
     */
    where?: InvestigationWhereInput
    /**
     * Limit how many Investigations to delete.
     */
    limit?: number
  }

  /**
   * Investigation.order
   */
  export type Investigation$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalOrder
     */
    select?: ClinicalOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalOrder
     */
    omit?: ClinicalOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalOrderInclude<ExtArgs> | null
    where?: ClinicalOrderWhereInput
  }

  /**
   * Investigation without action
   */
  export type InvestigationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investigation
     */
    select?: InvestigationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investigation
     */
    omit?: InvestigationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    startTime: 'startTime',
    endTime: 'endTime',
    isActive: 'isActive'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    mrn: 'mrn',
    firstName: 'firstName',
    lastName: 'lastName',
    dob: 'dob',
    gender: 'gender',
    comorbidities: 'comorbidities',
    diagnosis: 'diagnosis',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AdmissionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    bed: 'bed',
    diagnosis: 'diagnosis',
    admittedAt: 'admittedAt',
    dischargedAt: 'dischargedAt'
  };

  export type AdmissionScalarFieldEnum = (typeof AdmissionScalarFieldEnum)[keyof typeof AdmissionScalarFieldEnum]


  export const ClinicalNoteScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    authorId: 'authorId',
    type: 'type',
    title: 'title',
    content: 'content',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicalNoteScalarFieldEnum = (typeof ClinicalNoteScalarFieldEnum)[keyof typeof ClinicalNoteScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    details: 'details',
    userId: 'userId',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const VitalSignScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    heartRate: 'heartRate',
    bpSys: 'bpSys',
    bpDia: 'bpDia',
    spo2: 'spo2',
    temp: 'temp',
    rbs: 'rbs',
    timestamp: 'timestamp'
  };

  export type VitalSignScalarFieldEnum = (typeof VitalSignScalarFieldEnum)[keyof typeof VitalSignScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    defaultDose: 'defaultDose',
    route: 'route',
    frequency: 'frequency',
    infusionRate: 'infusionRate',
    otherInstructions: 'otherInstructions',
    patientId: 'patientId'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const DrugCatalogScalarFieldEnum: {
    id: 'id',
    name: 'name',
    defaultDose: 'defaultDose',
    defaultRoute: 'defaultRoute',
    createdAt: 'createdAt'
  };

  export type DrugCatalogScalarFieldEnum = (typeof DrugCatalogScalarFieldEnum)[keyof typeof DrugCatalogScalarFieldEnum]


  export const MedicationAdministrationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    medicationId: 'medicationId',
    status: 'status',
    dose: 'dose',
    timestamp: 'timestamp',
    userId: 'userId'
  };

  export type MedicationAdministrationScalarFieldEnum = (typeof MedicationAdministrationScalarFieldEnum)[keyof typeof MedicationAdministrationScalarFieldEnum]


  export const IntakeOutputScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    userId: 'userId',
    shiftId: 'shiftId',
    type: 'type',
    category: 'category',
    amount: 'amount',
    notes: 'notes',
    timestamp: 'timestamp'
  };

  export type IntakeOutputScalarFieldEnum = (typeof IntakeOutputScalarFieldEnum)[keyof typeof IntakeOutputScalarFieldEnum]


  export const NurseCheckInScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    userId: 'userId',
    shiftId: 'shiftId',
    airwaySafe: 'airwaySafe',
    breathingOk: 'breathingOk',
    circulationOk: 'circulationOk',
    notes: 'notes',
    timestamp: 'timestamp'
  };

  export type NurseCheckInScalarFieldEnum = (typeof NurseCheckInScalarFieldEnum)[keyof typeof NurseCheckInScalarFieldEnum]


  export const GovernorateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GovernorateScalarFieldEnum = (typeof GovernorateScalarFieldEnum)[keyof typeof GovernorateScalarFieldEnum]


  export const ClinicalOrderScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    authorId: 'authorId',
    approverId: 'approverId',
    type: 'type',
    status: 'status',
    priority: 'priority',
    title: 'title',
    details: 'details',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicalOrderScalarFieldEnum = (typeof ClinicalOrderScalarFieldEnum)[keyof typeof ClinicalOrderScalarFieldEnum]


  export const SpecialistNoteScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    authorId: 'authorId',
    date: 'date',
    apacheScore: 'apacheScore',
    histHT: 'histHT',
    histDM: 'histDM',
    histAsthma: 'histAsthma',
    histCOPD: 'histCOPD',
    histIHD: 'histIHD',
    histStroke: 'histStroke',
    histOther: 'histOther',
    neuroGCS: 'neuroGCS',
    neuroRASS: 'neuroRASS',
    respChest: 'respChest',
    respRoomAir: 'respRoomAir',
    respO2Therapy: 'respO2Therapy',
    respVentMode: 'respVentMode',
    respVentModeText: 'respVentModeText',
    respFio2: 'respFio2',
    respPS: 'respPS',
    intCVLine: 'intCVLine',
    intArtLine: 'intArtLine',
    intETT: 'intETT',
    intTrach: 'intTrach',
    intDoubleLumen: 'intDoubleLumen',
    hydNormovolemia: 'hydNormovolemia',
    hydHypervolemia: 'hydHypervolemia',
    hydHypovolemia: 'hydHypovolemia',
    hydUOP: 'hydUOP',
    hydIVC: 'hydIVC',
    hydCVP: 'hydCVP',
    hemoStable: 'hemoStable',
    hemoUnstable: 'hemoUnstable',
    hemoVasopressor: 'hemoVasopressor',
    feedOral: 'feedOral',
    feedNG: 'feedNG',
    feedTPN: 'feedTPN',
    feedRate: 'feedRate',
    ivFluidsRate: 'ivFluidsRate',
    sedPropofol: 'sedPropofol',
    sedKetamine: 'sedKetamine',
    sedMidazolam: 'sedMidazolam',
    sedRemif: 'sedRemif',
    sedMR: 'sedMR',
    sedOther: 'sedOther',
    clinicalNotes: 'clinicalNotes',
    planVentilatory: 'planVentilatory',
    planPhysio: 'planPhysio',
    planConsult: 'planConsult',
    planInvestigation: 'planInvestigation',
    planOther: 'planOther',
    planFuture: 'planFuture',
    planHomeTeam: 'planHomeTeam',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialistNoteScalarFieldEnum = (typeof SpecialistNoteScalarFieldEnum)[keyof typeof SpecialistNoteScalarFieldEnum]


  export const InvestigationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    orderId: 'orderId',
    authorId: 'authorId',
    type: 'type',
    category: 'category',
    title: 'title',
    status: 'status',
    result: 'result',
    impression: 'impression',
    conductedAt: 'conductedAt',
    createdAt: 'createdAt'
  };

  export type InvestigationScalarFieldEnum = (typeof InvestigationScalarFieldEnum)[keyof typeof InvestigationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ShiftType'
   */
  export type EnumShiftTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftType'>
    


  /**
   * Reference to a field of type 'ShiftType[]'
   */
  export type ListEnumShiftTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'NoteType'
   */
  export type EnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType'>
    


  /**
   * Reference to a field of type 'NoteType[]'
   */
  export type ListEnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'OrderType'
   */
  export type EnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType'>
    


  /**
   * Reference to a field of type 'OrderType[]'
   */
  export type ListEnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'InvestigationStatus'
   */
  export type EnumInvestigationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestigationStatus'>
    


  /**
   * Reference to a field of type 'InvestigationStatus[]'
   */
  export type ListEnumInvestigationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestigationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    shifts?: ShiftListRelationFilter
    notes?: ClinicalNoteListRelationFilter
    audits?: AuditLogListRelationFilter
    ioEntries?: IntakeOutputListRelationFilter
    checkIns?: NurseCheckInListRelationFilter
    createdOrders?: ClinicalOrderListRelationFilter
    approvedOrders?: ClinicalOrderListRelationFilter
    investigations?: InvestigationListRelationFilter
    specialistNotes?: SpecialistNoteListRelationFilter
    administeredMeds?: MedicationAdministrationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shifts?: ShiftOrderByRelationAggregateInput
    notes?: ClinicalNoteOrderByRelationAggregateInput
    audits?: AuditLogOrderByRelationAggregateInput
    ioEntries?: IntakeOutputOrderByRelationAggregateInput
    checkIns?: NurseCheckInOrderByRelationAggregateInput
    createdOrders?: ClinicalOrderOrderByRelationAggregateInput
    approvedOrders?: ClinicalOrderOrderByRelationAggregateInput
    investigations?: InvestigationOrderByRelationAggregateInput
    specialistNotes?: SpecialistNoteOrderByRelationAggregateInput
    administeredMeds?: MedicationAdministrationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    shifts?: ShiftListRelationFilter
    notes?: ClinicalNoteListRelationFilter
    audits?: AuditLogListRelationFilter
    ioEntries?: IntakeOutputListRelationFilter
    checkIns?: NurseCheckInListRelationFilter
    createdOrders?: ClinicalOrderListRelationFilter
    approvedOrders?: ClinicalOrderListRelationFilter
    investigations?: InvestigationListRelationFilter
    specialistNotes?: SpecialistNoteListRelationFilter
    administeredMeds?: MedicationAdministrationListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    userId?: StringFilter<"Shift"> | string
    type?: EnumShiftTypeFilter<"Shift"> | $Enums.ShiftType
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeNullableFilter<"Shift"> | Date | string | null
    isActive?: BoolFilter<"Shift"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ioEntries?: IntakeOutputListRelationFilter
    checkIns?: NurseCheckInListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
    ioEntries?: IntakeOutputOrderByRelationAggregateInput
    checkIns?: NurseCheckInOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    userId?: StringFilter<"Shift"> | string
    type?: EnumShiftTypeFilter<"Shift"> | $Enums.ShiftType
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeNullableFilter<"Shift"> | Date | string | null
    isActive?: BoolFilter<"Shift"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ioEntries?: IntakeOutputListRelationFilter
    checkIns?: NurseCheckInListRelationFilter
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    userId?: StringWithAggregatesFilter<"Shift"> | string
    type?: EnumShiftTypeWithAggregatesFilter<"Shift"> | $Enums.ShiftType
    startTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Shift"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Shift"> | boolean
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    mrn?: StringFilter<"Patient"> | string
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    dob?: DateTimeFilter<"Patient"> | Date | string
    gender?: StringFilter<"Patient"> | string
    comorbidities?: StringNullableListFilter<"Patient">
    diagnosis?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    admissions?: AdmissionListRelationFilter
    notes?: ClinicalNoteListRelationFilter
    vitals?: VitalSignListRelationFilter
    medications?: MedicationAdministrationListRelationFilter
    prescriptions?: MedicationListRelationFilter
    ioEntries?: IntakeOutputListRelationFilter
    checkIns?: NurseCheckInListRelationFilter
    orders?: ClinicalOrderListRelationFilter
    investigations?: InvestigationListRelationFilter
    specialistNotes?: SpecialistNoteListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    mrn?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    comorbidities?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admissions?: AdmissionOrderByRelationAggregateInput
    notes?: ClinicalNoteOrderByRelationAggregateInput
    vitals?: VitalSignOrderByRelationAggregateInput
    medications?: MedicationAdministrationOrderByRelationAggregateInput
    prescriptions?: MedicationOrderByRelationAggregateInput
    ioEntries?: IntakeOutputOrderByRelationAggregateInput
    checkIns?: NurseCheckInOrderByRelationAggregateInput
    orders?: ClinicalOrderOrderByRelationAggregateInput
    investigations?: InvestigationOrderByRelationAggregateInput
    specialistNotes?: SpecialistNoteOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mrn?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    firstName?: StringFilter<"Patient"> | string
    lastName?: StringFilter<"Patient"> | string
    dob?: DateTimeFilter<"Patient"> | Date | string
    gender?: StringFilter<"Patient"> | string
    comorbidities?: StringNullableListFilter<"Patient">
    diagnosis?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    admissions?: AdmissionListRelationFilter
    notes?: ClinicalNoteListRelationFilter
    vitals?: VitalSignListRelationFilter
    medications?: MedicationAdministrationListRelationFilter
    prescriptions?: MedicationListRelationFilter
    ioEntries?: IntakeOutputListRelationFilter
    checkIns?: NurseCheckInListRelationFilter
    orders?: ClinicalOrderListRelationFilter
    investigations?: InvestigationListRelationFilter
    specialistNotes?: SpecialistNoteListRelationFilter
  }, "id" | "mrn">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    mrn?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    comorbidities?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    mrn?: StringWithAggregatesFilter<"Patient"> | string
    firstName?: StringWithAggregatesFilter<"Patient"> | string
    lastName?: StringWithAggregatesFilter<"Patient"> | string
    dob?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    gender?: StringWithAggregatesFilter<"Patient"> | string
    comorbidities?: StringNullableListFilter<"Patient">
    diagnosis?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type AdmissionWhereInput = {
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    id?: StringFilter<"Admission"> | string
    patientId?: StringFilter<"Admission"> | string
    bed?: StringNullableFilter<"Admission"> | string | null
    diagnosis?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type AdmissionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    bed?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type AdmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    patientId?: StringFilter<"Admission"> | string
    bed?: StringNullableFilter<"Admission"> | string | null
    diagnosis?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type AdmissionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    bed?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    _count?: AdmissionCountOrderByAggregateInput
    _max?: AdmissionMaxOrderByAggregateInput
    _min?: AdmissionMinOrderByAggregateInput
  }

  export type AdmissionScalarWhereWithAggregatesInput = {
    AND?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    OR?: AdmissionScalarWhereWithAggregatesInput[]
    NOT?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admission"> | string
    patientId?: StringWithAggregatesFilter<"Admission"> | string
    bed?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    diagnosis?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    admittedAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableWithAggregatesFilter<"Admission"> | Date | string | null
  }

  export type ClinicalNoteWhereInput = {
    AND?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    OR?: ClinicalNoteWhereInput[]
    NOT?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    id?: StringFilter<"ClinicalNote"> | string
    patientId?: StringFilter<"ClinicalNote"> | string
    authorId?: StringFilter<"ClinicalNote"> | string
    type?: EnumNoteTypeFilter<"ClinicalNote"> | $Enums.NoteType
    title?: StringFilter<"ClinicalNote"> | string
    content?: StringFilter<"ClinicalNote"> | string
    data?: JsonNullableFilter<"ClinicalNote">
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClinicalNoteOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ClinicalNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    OR?: ClinicalNoteWhereInput[]
    NOT?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    patientId?: StringFilter<"ClinicalNote"> | string
    authorId?: StringFilter<"ClinicalNote"> | string
    type?: EnumNoteTypeFilter<"ClinicalNote"> | $Enums.NoteType
    title?: StringFilter<"ClinicalNote"> | string
    content?: StringFilter<"ClinicalNote"> | string
    data?: JsonNullableFilter<"ClinicalNote">
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClinicalNoteOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicalNoteCountOrderByAggregateInput
    _max?: ClinicalNoteMaxOrderByAggregateInput
    _min?: ClinicalNoteMinOrderByAggregateInput
  }

  export type ClinicalNoteScalarWhereWithAggregatesInput = {
    AND?: ClinicalNoteScalarWhereWithAggregatesInput | ClinicalNoteScalarWhereWithAggregatesInput[]
    OR?: ClinicalNoteScalarWhereWithAggregatesInput[]
    NOT?: ClinicalNoteScalarWhereWithAggregatesInput | ClinicalNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicalNote"> | string
    patientId?: StringWithAggregatesFilter<"ClinicalNote"> | string
    authorId?: StringWithAggregatesFilter<"ClinicalNote"> | string
    type?: EnumNoteTypeWithAggregatesFilter<"ClinicalNote"> | $Enums.NoteType
    title?: StringWithAggregatesFilter<"ClinicalNote"> | string
    content?: StringWithAggregatesFilter<"ClinicalNote"> | string
    data?: JsonNullableWithAggregatesFilter<"ClinicalNote">
    createdAt?: DateTimeWithAggregatesFilter<"ClinicalNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicalNote"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type VitalSignWhereInput = {
    AND?: VitalSignWhereInput | VitalSignWhereInput[]
    OR?: VitalSignWhereInput[]
    NOT?: VitalSignWhereInput | VitalSignWhereInput[]
    id?: StringFilter<"VitalSign"> | string
    patientId?: StringFilter<"VitalSign"> | string
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    bpSys?: IntNullableFilter<"VitalSign"> | number | null
    bpDia?: IntNullableFilter<"VitalSign"> | number | null
    spo2?: IntNullableFilter<"VitalSign"> | number | null
    temp?: FloatNullableFilter<"VitalSign"> | number | null
    rbs?: FloatNullableFilter<"VitalSign"> | number | null
    timestamp?: DateTimeFilter<"VitalSign"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type VitalSignOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    heartRate?: SortOrderInput | SortOrder
    bpSys?: SortOrderInput | SortOrder
    bpDia?: SortOrderInput | SortOrder
    spo2?: SortOrderInput | SortOrder
    temp?: SortOrderInput | SortOrder
    rbs?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type VitalSignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VitalSignWhereInput | VitalSignWhereInput[]
    OR?: VitalSignWhereInput[]
    NOT?: VitalSignWhereInput | VitalSignWhereInput[]
    patientId?: StringFilter<"VitalSign"> | string
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    bpSys?: IntNullableFilter<"VitalSign"> | number | null
    bpDia?: IntNullableFilter<"VitalSign"> | number | null
    spo2?: IntNullableFilter<"VitalSign"> | number | null
    temp?: FloatNullableFilter<"VitalSign"> | number | null
    rbs?: FloatNullableFilter<"VitalSign"> | number | null
    timestamp?: DateTimeFilter<"VitalSign"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type VitalSignOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    heartRate?: SortOrderInput | SortOrder
    bpSys?: SortOrderInput | SortOrder
    bpDia?: SortOrderInput | SortOrder
    spo2?: SortOrderInput | SortOrder
    temp?: SortOrderInput | SortOrder
    rbs?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: VitalSignCountOrderByAggregateInput
    _avg?: VitalSignAvgOrderByAggregateInput
    _max?: VitalSignMaxOrderByAggregateInput
    _min?: VitalSignMinOrderByAggregateInput
    _sum?: VitalSignSumOrderByAggregateInput
  }

  export type VitalSignScalarWhereWithAggregatesInput = {
    AND?: VitalSignScalarWhereWithAggregatesInput | VitalSignScalarWhereWithAggregatesInput[]
    OR?: VitalSignScalarWhereWithAggregatesInput[]
    NOT?: VitalSignScalarWhereWithAggregatesInput | VitalSignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VitalSign"> | string
    patientId?: StringWithAggregatesFilter<"VitalSign"> | string
    heartRate?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    bpSys?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    bpDia?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    spo2?: IntNullableWithAggregatesFilter<"VitalSign"> | number | null
    temp?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    rbs?: FloatNullableWithAggregatesFilter<"VitalSign"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"VitalSign"> | Date | string
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    defaultDose?: StringFilter<"Medication"> | string
    route?: StringFilter<"Medication"> | string
    frequency?: StringNullableFilter<"Medication"> | string | null
    infusionRate?: StringNullableFilter<"Medication"> | string | null
    otherInstructions?: StringNullableFilter<"Medication"> | string | null
    patientId?: StringNullableFilter<"Medication"> | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    administrations?: MedicationAdministrationListRelationFilter
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    route?: SortOrder
    frequency?: SortOrderInput | SortOrder
    infusionRate?: SortOrderInput | SortOrder
    otherInstructions?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    administrations?: MedicationAdministrationOrderByRelationAggregateInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    name?: StringFilter<"Medication"> | string
    defaultDose?: StringFilter<"Medication"> | string
    route?: StringFilter<"Medication"> | string
    frequency?: StringNullableFilter<"Medication"> | string | null
    infusionRate?: StringNullableFilter<"Medication"> | string | null
    otherInstructions?: StringNullableFilter<"Medication"> | string | null
    patientId?: StringNullableFilter<"Medication"> | string | null
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
    administrations?: MedicationAdministrationListRelationFilter
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    route?: SortOrder
    frequency?: SortOrderInput | SortOrder
    infusionRate?: SortOrderInput | SortOrder
    otherInstructions?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medication"> | string
    name?: StringWithAggregatesFilter<"Medication"> | string
    defaultDose?: StringWithAggregatesFilter<"Medication"> | string
    route?: StringWithAggregatesFilter<"Medication"> | string
    frequency?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    infusionRate?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    otherInstructions?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    patientId?: StringNullableWithAggregatesFilter<"Medication"> | string | null
  }

  export type DrugCatalogWhereInput = {
    AND?: DrugCatalogWhereInput | DrugCatalogWhereInput[]
    OR?: DrugCatalogWhereInput[]
    NOT?: DrugCatalogWhereInput | DrugCatalogWhereInput[]
    id?: StringFilter<"DrugCatalog"> | string
    name?: StringFilter<"DrugCatalog"> | string
    defaultDose?: StringNullableFilter<"DrugCatalog"> | string | null
    defaultRoute?: StringNullableFilter<"DrugCatalog"> | string | null
    createdAt?: DateTimeFilter<"DrugCatalog"> | Date | string
  }

  export type DrugCatalogOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrderInput | SortOrder
    defaultRoute?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type DrugCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DrugCatalogWhereInput | DrugCatalogWhereInput[]
    OR?: DrugCatalogWhereInput[]
    NOT?: DrugCatalogWhereInput | DrugCatalogWhereInput[]
    defaultDose?: StringNullableFilter<"DrugCatalog"> | string | null
    defaultRoute?: StringNullableFilter<"DrugCatalog"> | string | null
    createdAt?: DateTimeFilter<"DrugCatalog"> | Date | string
  }, "id" | "name">

  export type DrugCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrderInput | SortOrder
    defaultRoute?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DrugCatalogCountOrderByAggregateInput
    _max?: DrugCatalogMaxOrderByAggregateInput
    _min?: DrugCatalogMinOrderByAggregateInput
  }

  export type DrugCatalogScalarWhereWithAggregatesInput = {
    AND?: DrugCatalogScalarWhereWithAggregatesInput | DrugCatalogScalarWhereWithAggregatesInput[]
    OR?: DrugCatalogScalarWhereWithAggregatesInput[]
    NOT?: DrugCatalogScalarWhereWithAggregatesInput | DrugCatalogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DrugCatalog"> | string
    name?: StringWithAggregatesFilter<"DrugCatalog"> | string
    defaultDose?: StringNullableWithAggregatesFilter<"DrugCatalog"> | string | null
    defaultRoute?: StringNullableWithAggregatesFilter<"DrugCatalog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DrugCatalog"> | Date | string
  }

  export type MedicationAdministrationWhereInput = {
    AND?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    OR?: MedicationAdministrationWhereInput[]
    NOT?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    id?: StringFilter<"MedicationAdministration"> | string
    patientId?: StringFilter<"MedicationAdministration"> | string
    medicationId?: StringFilter<"MedicationAdministration"> | string
    status?: StringFilter<"MedicationAdministration"> | string
    dose?: StringNullableFilter<"MedicationAdministration"> | string | null
    timestamp?: DateTimeFilter<"MedicationAdministration"> | Date | string
    userId?: StringNullableFilter<"MedicationAdministration"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MedicationAdministrationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dose?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    medication?: MedicationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MedicationAdministrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    OR?: MedicationAdministrationWhereInput[]
    NOT?: MedicationAdministrationWhereInput | MedicationAdministrationWhereInput[]
    patientId?: StringFilter<"MedicationAdministration"> | string
    medicationId?: StringFilter<"MedicationAdministration"> | string
    status?: StringFilter<"MedicationAdministration"> | string
    dose?: StringNullableFilter<"MedicationAdministration"> | string | null
    timestamp?: DateTimeFilter<"MedicationAdministration"> | Date | string
    userId?: StringNullableFilter<"MedicationAdministration"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type MedicationAdministrationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dose?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: MedicationAdministrationCountOrderByAggregateInput
    _max?: MedicationAdministrationMaxOrderByAggregateInput
    _min?: MedicationAdministrationMinOrderByAggregateInput
  }

  export type MedicationAdministrationScalarWhereWithAggregatesInput = {
    AND?: MedicationAdministrationScalarWhereWithAggregatesInput | MedicationAdministrationScalarWhereWithAggregatesInput[]
    OR?: MedicationAdministrationScalarWhereWithAggregatesInput[]
    NOT?: MedicationAdministrationScalarWhereWithAggregatesInput | MedicationAdministrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    patientId?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    medicationId?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    status?: StringWithAggregatesFilter<"MedicationAdministration"> | string
    dose?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"MedicationAdministration"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"MedicationAdministration"> | string | null
  }

  export type IntakeOutputWhereInput = {
    AND?: IntakeOutputWhereInput | IntakeOutputWhereInput[]
    OR?: IntakeOutputWhereInput[]
    NOT?: IntakeOutputWhereInput | IntakeOutputWhereInput[]
    id?: StringFilter<"IntakeOutput"> | string
    patientId?: StringFilter<"IntakeOutput"> | string
    userId?: StringFilter<"IntakeOutput"> | string
    shiftId?: StringNullableFilter<"IntakeOutput"> | string | null
    type?: StringFilter<"IntakeOutput"> | string
    category?: StringFilter<"IntakeOutput"> | string
    amount?: FloatFilter<"IntakeOutput"> | number
    notes?: StringNullableFilter<"IntakeOutput"> | string | null
    timestamp?: DateTimeFilter<"IntakeOutput"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
  }

  export type IntakeOutputOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    patient?: PatientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
  }

  export type IntakeOutputWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntakeOutputWhereInput | IntakeOutputWhereInput[]
    OR?: IntakeOutputWhereInput[]
    NOT?: IntakeOutputWhereInput | IntakeOutputWhereInput[]
    patientId?: StringFilter<"IntakeOutput"> | string
    userId?: StringFilter<"IntakeOutput"> | string
    shiftId?: StringNullableFilter<"IntakeOutput"> | string | null
    type?: StringFilter<"IntakeOutput"> | string
    category?: StringFilter<"IntakeOutput"> | string
    amount?: FloatFilter<"IntakeOutput"> | number
    notes?: StringNullableFilter<"IntakeOutput"> | string | null
    timestamp?: DateTimeFilter<"IntakeOutput"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
  }, "id">

  export type IntakeOutputOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: IntakeOutputCountOrderByAggregateInput
    _avg?: IntakeOutputAvgOrderByAggregateInput
    _max?: IntakeOutputMaxOrderByAggregateInput
    _min?: IntakeOutputMinOrderByAggregateInput
    _sum?: IntakeOutputSumOrderByAggregateInput
  }

  export type IntakeOutputScalarWhereWithAggregatesInput = {
    AND?: IntakeOutputScalarWhereWithAggregatesInput | IntakeOutputScalarWhereWithAggregatesInput[]
    OR?: IntakeOutputScalarWhereWithAggregatesInput[]
    NOT?: IntakeOutputScalarWhereWithAggregatesInput | IntakeOutputScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntakeOutput"> | string
    patientId?: StringWithAggregatesFilter<"IntakeOutput"> | string
    userId?: StringWithAggregatesFilter<"IntakeOutput"> | string
    shiftId?: StringNullableWithAggregatesFilter<"IntakeOutput"> | string | null
    type?: StringWithAggregatesFilter<"IntakeOutput"> | string
    category?: StringWithAggregatesFilter<"IntakeOutput"> | string
    amount?: FloatWithAggregatesFilter<"IntakeOutput"> | number
    notes?: StringNullableWithAggregatesFilter<"IntakeOutput"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"IntakeOutput"> | Date | string
  }

  export type NurseCheckInWhereInput = {
    AND?: NurseCheckInWhereInput | NurseCheckInWhereInput[]
    OR?: NurseCheckInWhereInput[]
    NOT?: NurseCheckInWhereInput | NurseCheckInWhereInput[]
    id?: StringFilter<"NurseCheckIn"> | string
    patientId?: StringFilter<"NurseCheckIn"> | string
    userId?: StringFilter<"NurseCheckIn"> | string
    shiftId?: StringNullableFilter<"NurseCheckIn"> | string | null
    airwaySafe?: BoolFilter<"NurseCheckIn"> | boolean
    breathingOk?: BoolFilter<"NurseCheckIn"> | boolean
    circulationOk?: BoolFilter<"NurseCheckIn"> | boolean
    notes?: StringNullableFilter<"NurseCheckIn"> | string | null
    timestamp?: DateTimeFilter<"NurseCheckIn"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
  }

  export type NurseCheckInOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    airwaySafe?: SortOrder
    breathingOk?: SortOrder
    circulationOk?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    patient?: PatientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
  }

  export type NurseCheckInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NurseCheckInWhereInput | NurseCheckInWhereInput[]
    OR?: NurseCheckInWhereInput[]
    NOT?: NurseCheckInWhereInput | NurseCheckInWhereInput[]
    patientId?: StringFilter<"NurseCheckIn"> | string
    userId?: StringFilter<"NurseCheckIn"> | string
    shiftId?: StringNullableFilter<"NurseCheckIn"> | string | null
    airwaySafe?: BoolFilter<"NurseCheckIn"> | boolean
    breathingOk?: BoolFilter<"NurseCheckIn"> | boolean
    circulationOk?: BoolFilter<"NurseCheckIn"> | boolean
    notes?: StringNullableFilter<"NurseCheckIn"> | string | null
    timestamp?: DateTimeFilter<"NurseCheckIn"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
  }, "id">

  export type NurseCheckInOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    airwaySafe?: SortOrder
    breathingOk?: SortOrder
    circulationOk?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: NurseCheckInCountOrderByAggregateInput
    _max?: NurseCheckInMaxOrderByAggregateInput
    _min?: NurseCheckInMinOrderByAggregateInput
  }

  export type NurseCheckInScalarWhereWithAggregatesInput = {
    AND?: NurseCheckInScalarWhereWithAggregatesInput | NurseCheckInScalarWhereWithAggregatesInput[]
    OR?: NurseCheckInScalarWhereWithAggregatesInput[]
    NOT?: NurseCheckInScalarWhereWithAggregatesInput | NurseCheckInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NurseCheckIn"> | string
    patientId?: StringWithAggregatesFilter<"NurseCheckIn"> | string
    userId?: StringWithAggregatesFilter<"NurseCheckIn"> | string
    shiftId?: StringNullableWithAggregatesFilter<"NurseCheckIn"> | string | null
    airwaySafe?: BoolWithAggregatesFilter<"NurseCheckIn"> | boolean
    breathingOk?: BoolWithAggregatesFilter<"NurseCheckIn"> | boolean
    circulationOk?: BoolWithAggregatesFilter<"NurseCheckIn"> | boolean
    notes?: StringNullableWithAggregatesFilter<"NurseCheckIn"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"NurseCheckIn"> | Date | string
  }

  export type GovernorateWhereInput = {
    AND?: GovernorateWhereInput | GovernorateWhereInput[]
    OR?: GovernorateWhereInput[]
    NOT?: GovernorateWhereInput | GovernorateWhereInput[]
    id?: StringFilter<"Governorate"> | string
    name?: StringFilter<"Governorate"> | string
    createdAt?: DateTimeFilter<"Governorate"> | Date | string
    updatedAt?: DateTimeFilter<"Governorate"> | Date | string
  }

  export type GovernorateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernorateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GovernorateWhereInput | GovernorateWhereInput[]
    OR?: GovernorateWhereInput[]
    NOT?: GovernorateWhereInput | GovernorateWhereInput[]
    createdAt?: DateTimeFilter<"Governorate"> | Date | string
    updatedAt?: DateTimeFilter<"Governorate"> | Date | string
  }, "id" | "name">

  export type GovernorateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GovernorateCountOrderByAggregateInput
    _max?: GovernorateMaxOrderByAggregateInput
    _min?: GovernorateMinOrderByAggregateInput
  }

  export type GovernorateScalarWhereWithAggregatesInput = {
    AND?: GovernorateScalarWhereWithAggregatesInput | GovernorateScalarWhereWithAggregatesInput[]
    OR?: GovernorateScalarWhereWithAggregatesInput[]
    NOT?: GovernorateScalarWhereWithAggregatesInput | GovernorateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Governorate"> | string
    name?: StringWithAggregatesFilter<"Governorate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Governorate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Governorate"> | Date | string
  }

  export type ClinicalOrderWhereInput = {
    AND?: ClinicalOrderWhereInput | ClinicalOrderWhereInput[]
    OR?: ClinicalOrderWhereInput[]
    NOT?: ClinicalOrderWhereInput | ClinicalOrderWhereInput[]
    id?: StringFilter<"ClinicalOrder"> | string
    patientId?: StringFilter<"ClinicalOrder"> | string
    authorId?: StringFilter<"ClinicalOrder"> | string
    approverId?: StringNullableFilter<"ClinicalOrder"> | string | null
    type?: EnumOrderTypeFilter<"ClinicalOrder"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"ClinicalOrder"> | $Enums.OrderStatus
    priority?: EnumPriorityFilter<"ClinicalOrder"> | $Enums.Priority
    title?: StringFilter<"ClinicalOrder"> | string
    details?: JsonNullableFilter<"ClinicalOrder">
    notes?: StringNullableFilter<"ClinicalOrder"> | string | null
    createdAt?: DateTimeFilter<"ClinicalOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalOrder"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    investigations?: InvestigationListRelationFilter
  }

  export type ClinicalOrderOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    details?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    investigations?: InvestigationOrderByRelationAggregateInput
  }

  export type ClinicalOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicalOrderWhereInput | ClinicalOrderWhereInput[]
    OR?: ClinicalOrderWhereInput[]
    NOT?: ClinicalOrderWhereInput | ClinicalOrderWhereInput[]
    patientId?: StringFilter<"ClinicalOrder"> | string
    authorId?: StringFilter<"ClinicalOrder"> | string
    approverId?: StringNullableFilter<"ClinicalOrder"> | string | null
    type?: EnumOrderTypeFilter<"ClinicalOrder"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"ClinicalOrder"> | $Enums.OrderStatus
    priority?: EnumPriorityFilter<"ClinicalOrder"> | $Enums.Priority
    title?: StringFilter<"ClinicalOrder"> | string
    details?: JsonNullableFilter<"ClinicalOrder">
    notes?: StringNullableFilter<"ClinicalOrder"> | string | null
    createdAt?: DateTimeFilter<"ClinicalOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalOrder"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    investigations?: InvestigationListRelationFilter
  }, "id">

  export type ClinicalOrderOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    details?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicalOrderCountOrderByAggregateInput
    _max?: ClinicalOrderMaxOrderByAggregateInput
    _min?: ClinicalOrderMinOrderByAggregateInput
  }

  export type ClinicalOrderScalarWhereWithAggregatesInput = {
    AND?: ClinicalOrderScalarWhereWithAggregatesInput | ClinicalOrderScalarWhereWithAggregatesInput[]
    OR?: ClinicalOrderScalarWhereWithAggregatesInput[]
    NOT?: ClinicalOrderScalarWhereWithAggregatesInput | ClinicalOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicalOrder"> | string
    patientId?: StringWithAggregatesFilter<"ClinicalOrder"> | string
    authorId?: StringWithAggregatesFilter<"ClinicalOrder"> | string
    approverId?: StringNullableWithAggregatesFilter<"ClinicalOrder"> | string | null
    type?: EnumOrderTypeWithAggregatesFilter<"ClinicalOrder"> | $Enums.OrderType
    status?: EnumOrderStatusWithAggregatesFilter<"ClinicalOrder"> | $Enums.OrderStatus
    priority?: EnumPriorityWithAggregatesFilter<"ClinicalOrder"> | $Enums.Priority
    title?: StringWithAggregatesFilter<"ClinicalOrder"> | string
    details?: JsonNullableWithAggregatesFilter<"ClinicalOrder">
    notes?: StringNullableWithAggregatesFilter<"ClinicalOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClinicalOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicalOrder"> | Date | string
  }

  export type SpecialistNoteWhereInput = {
    AND?: SpecialistNoteWhereInput | SpecialistNoteWhereInput[]
    OR?: SpecialistNoteWhereInput[]
    NOT?: SpecialistNoteWhereInput | SpecialistNoteWhereInput[]
    id?: StringFilter<"SpecialistNote"> | string
    patientId?: StringFilter<"SpecialistNote"> | string
    authorId?: StringFilter<"SpecialistNote"> | string
    date?: DateTimeFilter<"SpecialistNote"> | Date | string
    apacheScore?: StringNullableFilter<"SpecialistNote"> | string | null
    histHT?: BoolFilter<"SpecialistNote"> | boolean
    histDM?: BoolFilter<"SpecialistNote"> | boolean
    histAsthma?: BoolFilter<"SpecialistNote"> | boolean
    histCOPD?: BoolFilter<"SpecialistNote"> | boolean
    histIHD?: BoolFilter<"SpecialistNote"> | boolean
    histStroke?: BoolFilter<"SpecialistNote"> | boolean
    histOther?: StringNullableFilter<"SpecialistNote"> | string | null
    neuroGCS?: StringNullableFilter<"SpecialistNote"> | string | null
    neuroRASS?: StringNullableFilter<"SpecialistNote"> | string | null
    respChest?: StringNullableFilter<"SpecialistNote"> | string | null
    respRoomAir?: BoolFilter<"SpecialistNote"> | boolean
    respO2Therapy?: BoolFilter<"SpecialistNote"> | boolean
    respVentMode?: BoolFilter<"SpecialistNote"> | boolean
    respVentModeText?: StringNullableFilter<"SpecialistNote"> | string | null
    respFio2?: StringNullableFilter<"SpecialistNote"> | string | null
    respPS?: StringNullableFilter<"SpecialistNote"> | string | null
    intCVLine?: BoolFilter<"SpecialistNote"> | boolean
    intArtLine?: BoolFilter<"SpecialistNote"> | boolean
    intETT?: BoolFilter<"SpecialistNote"> | boolean
    intTrach?: BoolFilter<"SpecialistNote"> | boolean
    intDoubleLumen?: BoolFilter<"SpecialistNote"> | boolean
    hydNormovolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydHypervolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydHypovolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydUOP?: StringNullableFilter<"SpecialistNote"> | string | null
    hydIVC?: StringNullableFilter<"SpecialistNote"> | string | null
    hydCVP?: StringNullableFilter<"SpecialistNote"> | string | null
    hemoStable?: BoolFilter<"SpecialistNote"> | boolean
    hemoUnstable?: BoolFilter<"SpecialistNote"> | boolean
    hemoVasopressor?: BoolFilter<"SpecialistNote"> | boolean
    feedOral?: BoolFilter<"SpecialistNote"> | boolean
    feedNG?: BoolFilter<"SpecialistNote"> | boolean
    feedTPN?: BoolFilter<"SpecialistNote"> | boolean
    feedRate?: StringNullableFilter<"SpecialistNote"> | string | null
    ivFluidsRate?: StringNullableFilter<"SpecialistNote"> | string | null
    sedPropofol?: BoolFilter<"SpecialistNote"> | boolean
    sedKetamine?: BoolFilter<"SpecialistNote"> | boolean
    sedMidazolam?: BoolFilter<"SpecialistNote"> | boolean
    sedRemif?: BoolFilter<"SpecialistNote"> | boolean
    sedMR?: BoolFilter<"SpecialistNote"> | boolean
    sedOther?: StringNullableFilter<"SpecialistNote"> | string | null
    clinicalNotes?: StringNullableFilter<"SpecialistNote"> | string | null
    planVentilatory?: StringNullableFilter<"SpecialistNote"> | string | null
    planPhysio?: StringNullableFilter<"SpecialistNote"> | string | null
    planConsult?: StringNullableFilter<"SpecialistNote"> | string | null
    planInvestigation?: StringNullableFilter<"SpecialistNote"> | string | null
    planOther?: StringNullableFilter<"SpecialistNote"> | string | null
    planFuture?: StringNullableFilter<"SpecialistNote"> | string | null
    planHomeTeam?: StringNullableFilter<"SpecialistNote"> | string | null
    createdAt?: DateTimeFilter<"SpecialistNote"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialistNote"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SpecialistNoteOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    apacheScore?: SortOrderInput | SortOrder
    histHT?: SortOrder
    histDM?: SortOrder
    histAsthma?: SortOrder
    histCOPD?: SortOrder
    histIHD?: SortOrder
    histStroke?: SortOrder
    histOther?: SortOrderInput | SortOrder
    neuroGCS?: SortOrderInput | SortOrder
    neuroRASS?: SortOrderInput | SortOrder
    respChest?: SortOrderInput | SortOrder
    respRoomAir?: SortOrder
    respO2Therapy?: SortOrder
    respVentMode?: SortOrder
    respVentModeText?: SortOrderInput | SortOrder
    respFio2?: SortOrderInput | SortOrder
    respPS?: SortOrderInput | SortOrder
    intCVLine?: SortOrder
    intArtLine?: SortOrder
    intETT?: SortOrder
    intTrach?: SortOrder
    intDoubleLumen?: SortOrder
    hydNormovolemia?: SortOrder
    hydHypervolemia?: SortOrder
    hydHypovolemia?: SortOrder
    hydUOP?: SortOrderInput | SortOrder
    hydIVC?: SortOrderInput | SortOrder
    hydCVP?: SortOrderInput | SortOrder
    hemoStable?: SortOrder
    hemoUnstable?: SortOrder
    hemoVasopressor?: SortOrder
    feedOral?: SortOrder
    feedNG?: SortOrder
    feedTPN?: SortOrder
    feedRate?: SortOrderInput | SortOrder
    ivFluidsRate?: SortOrderInput | SortOrder
    sedPropofol?: SortOrder
    sedKetamine?: SortOrder
    sedMidazolam?: SortOrder
    sedRemif?: SortOrder
    sedMR?: SortOrder
    sedOther?: SortOrderInput | SortOrder
    clinicalNotes?: SortOrderInput | SortOrder
    planVentilatory?: SortOrderInput | SortOrder
    planPhysio?: SortOrderInput | SortOrder
    planConsult?: SortOrderInput | SortOrder
    planInvestigation?: SortOrderInput | SortOrder
    planOther?: SortOrderInput | SortOrder
    planFuture?: SortOrderInput | SortOrder
    planHomeTeam?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type SpecialistNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpecialistNoteWhereInput | SpecialistNoteWhereInput[]
    OR?: SpecialistNoteWhereInput[]
    NOT?: SpecialistNoteWhereInput | SpecialistNoteWhereInput[]
    patientId?: StringFilter<"SpecialistNote"> | string
    authorId?: StringFilter<"SpecialistNote"> | string
    date?: DateTimeFilter<"SpecialistNote"> | Date | string
    apacheScore?: StringNullableFilter<"SpecialistNote"> | string | null
    histHT?: BoolFilter<"SpecialistNote"> | boolean
    histDM?: BoolFilter<"SpecialistNote"> | boolean
    histAsthma?: BoolFilter<"SpecialistNote"> | boolean
    histCOPD?: BoolFilter<"SpecialistNote"> | boolean
    histIHD?: BoolFilter<"SpecialistNote"> | boolean
    histStroke?: BoolFilter<"SpecialistNote"> | boolean
    histOther?: StringNullableFilter<"SpecialistNote"> | string | null
    neuroGCS?: StringNullableFilter<"SpecialistNote"> | string | null
    neuroRASS?: StringNullableFilter<"SpecialistNote"> | string | null
    respChest?: StringNullableFilter<"SpecialistNote"> | string | null
    respRoomAir?: BoolFilter<"SpecialistNote"> | boolean
    respO2Therapy?: BoolFilter<"SpecialistNote"> | boolean
    respVentMode?: BoolFilter<"SpecialistNote"> | boolean
    respVentModeText?: StringNullableFilter<"SpecialistNote"> | string | null
    respFio2?: StringNullableFilter<"SpecialistNote"> | string | null
    respPS?: StringNullableFilter<"SpecialistNote"> | string | null
    intCVLine?: BoolFilter<"SpecialistNote"> | boolean
    intArtLine?: BoolFilter<"SpecialistNote"> | boolean
    intETT?: BoolFilter<"SpecialistNote"> | boolean
    intTrach?: BoolFilter<"SpecialistNote"> | boolean
    intDoubleLumen?: BoolFilter<"SpecialistNote"> | boolean
    hydNormovolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydHypervolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydHypovolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydUOP?: StringNullableFilter<"SpecialistNote"> | string | null
    hydIVC?: StringNullableFilter<"SpecialistNote"> | string | null
    hydCVP?: StringNullableFilter<"SpecialistNote"> | string | null
    hemoStable?: BoolFilter<"SpecialistNote"> | boolean
    hemoUnstable?: BoolFilter<"SpecialistNote"> | boolean
    hemoVasopressor?: BoolFilter<"SpecialistNote"> | boolean
    feedOral?: BoolFilter<"SpecialistNote"> | boolean
    feedNG?: BoolFilter<"SpecialistNote"> | boolean
    feedTPN?: BoolFilter<"SpecialistNote"> | boolean
    feedRate?: StringNullableFilter<"SpecialistNote"> | string | null
    ivFluidsRate?: StringNullableFilter<"SpecialistNote"> | string | null
    sedPropofol?: BoolFilter<"SpecialistNote"> | boolean
    sedKetamine?: BoolFilter<"SpecialistNote"> | boolean
    sedMidazolam?: BoolFilter<"SpecialistNote"> | boolean
    sedRemif?: BoolFilter<"SpecialistNote"> | boolean
    sedMR?: BoolFilter<"SpecialistNote"> | boolean
    sedOther?: StringNullableFilter<"SpecialistNote"> | string | null
    clinicalNotes?: StringNullableFilter<"SpecialistNote"> | string | null
    planVentilatory?: StringNullableFilter<"SpecialistNote"> | string | null
    planPhysio?: StringNullableFilter<"SpecialistNote"> | string | null
    planConsult?: StringNullableFilter<"SpecialistNote"> | string | null
    planInvestigation?: StringNullableFilter<"SpecialistNote"> | string | null
    planOther?: StringNullableFilter<"SpecialistNote"> | string | null
    planFuture?: StringNullableFilter<"SpecialistNote"> | string | null
    planHomeTeam?: StringNullableFilter<"SpecialistNote"> | string | null
    createdAt?: DateTimeFilter<"SpecialistNote"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialistNote"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SpecialistNoteOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    apacheScore?: SortOrderInput | SortOrder
    histHT?: SortOrder
    histDM?: SortOrder
    histAsthma?: SortOrder
    histCOPD?: SortOrder
    histIHD?: SortOrder
    histStroke?: SortOrder
    histOther?: SortOrderInput | SortOrder
    neuroGCS?: SortOrderInput | SortOrder
    neuroRASS?: SortOrderInput | SortOrder
    respChest?: SortOrderInput | SortOrder
    respRoomAir?: SortOrder
    respO2Therapy?: SortOrder
    respVentMode?: SortOrder
    respVentModeText?: SortOrderInput | SortOrder
    respFio2?: SortOrderInput | SortOrder
    respPS?: SortOrderInput | SortOrder
    intCVLine?: SortOrder
    intArtLine?: SortOrder
    intETT?: SortOrder
    intTrach?: SortOrder
    intDoubleLumen?: SortOrder
    hydNormovolemia?: SortOrder
    hydHypervolemia?: SortOrder
    hydHypovolemia?: SortOrder
    hydUOP?: SortOrderInput | SortOrder
    hydIVC?: SortOrderInput | SortOrder
    hydCVP?: SortOrderInput | SortOrder
    hemoStable?: SortOrder
    hemoUnstable?: SortOrder
    hemoVasopressor?: SortOrder
    feedOral?: SortOrder
    feedNG?: SortOrder
    feedTPN?: SortOrder
    feedRate?: SortOrderInput | SortOrder
    ivFluidsRate?: SortOrderInput | SortOrder
    sedPropofol?: SortOrder
    sedKetamine?: SortOrder
    sedMidazolam?: SortOrder
    sedRemif?: SortOrder
    sedMR?: SortOrder
    sedOther?: SortOrderInput | SortOrder
    clinicalNotes?: SortOrderInput | SortOrder
    planVentilatory?: SortOrderInput | SortOrder
    planPhysio?: SortOrderInput | SortOrder
    planConsult?: SortOrderInput | SortOrder
    planInvestigation?: SortOrderInput | SortOrder
    planOther?: SortOrderInput | SortOrder
    planFuture?: SortOrderInput | SortOrder
    planHomeTeam?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialistNoteCountOrderByAggregateInput
    _max?: SpecialistNoteMaxOrderByAggregateInput
    _min?: SpecialistNoteMinOrderByAggregateInput
  }

  export type SpecialistNoteScalarWhereWithAggregatesInput = {
    AND?: SpecialistNoteScalarWhereWithAggregatesInput | SpecialistNoteScalarWhereWithAggregatesInput[]
    OR?: SpecialistNoteScalarWhereWithAggregatesInput[]
    NOT?: SpecialistNoteScalarWhereWithAggregatesInput | SpecialistNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpecialistNote"> | string
    patientId?: StringWithAggregatesFilter<"SpecialistNote"> | string
    authorId?: StringWithAggregatesFilter<"SpecialistNote"> | string
    date?: DateTimeWithAggregatesFilter<"SpecialistNote"> | Date | string
    apacheScore?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    histHT?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    histDM?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    histAsthma?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    histCOPD?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    histIHD?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    histStroke?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    histOther?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    neuroGCS?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    neuroRASS?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    respChest?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    respRoomAir?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    respO2Therapy?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    respVentMode?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    respVentModeText?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    respFio2?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    respPS?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    intCVLine?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    intArtLine?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    intETT?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    intTrach?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    intDoubleLumen?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    hydNormovolemia?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    hydHypervolemia?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    hydHypovolemia?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    hydUOP?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    hydIVC?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    hydCVP?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    hemoStable?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    hemoUnstable?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    hemoVasopressor?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    feedOral?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    feedNG?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    feedTPN?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    feedRate?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    ivFluidsRate?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    sedPropofol?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    sedKetamine?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    sedMidazolam?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    sedRemif?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    sedMR?: BoolWithAggregatesFilter<"SpecialistNote"> | boolean
    sedOther?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    clinicalNotes?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    planVentilatory?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    planPhysio?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    planConsult?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    planInvestigation?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    planOther?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    planFuture?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    planHomeTeam?: StringNullableWithAggregatesFilter<"SpecialistNote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SpecialistNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SpecialistNote"> | Date | string
  }

  export type InvestigationWhereInput = {
    AND?: InvestigationWhereInput | InvestigationWhereInput[]
    OR?: InvestigationWhereInput[]
    NOT?: InvestigationWhereInput | InvestigationWhereInput[]
    id?: StringFilter<"Investigation"> | string
    patientId?: StringFilter<"Investigation"> | string
    orderId?: StringNullableFilter<"Investigation"> | string | null
    authorId?: StringFilter<"Investigation"> | string
    type?: EnumOrderTypeFilter<"Investigation"> | $Enums.OrderType
    category?: StringFilter<"Investigation"> | string
    title?: StringFilter<"Investigation"> | string
    status?: EnumInvestigationStatusFilter<"Investigation"> | $Enums.InvestigationStatus
    result?: JsonNullableFilter<"Investigation">
    impression?: StringNullableFilter<"Investigation"> | string | null
    conductedAt?: DateTimeFilter<"Investigation"> | Date | string
    createdAt?: DateTimeFilter<"Investigation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    order?: XOR<ClinicalOrderNullableScalarRelationFilter, ClinicalOrderWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvestigationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    impression?: SortOrderInput | SortOrder
    conductedAt?: SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    order?: ClinicalOrderOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type InvestigationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestigationWhereInput | InvestigationWhereInput[]
    OR?: InvestigationWhereInput[]
    NOT?: InvestigationWhereInput | InvestigationWhereInput[]
    patientId?: StringFilter<"Investigation"> | string
    orderId?: StringNullableFilter<"Investigation"> | string | null
    authorId?: StringFilter<"Investigation"> | string
    type?: EnumOrderTypeFilter<"Investigation"> | $Enums.OrderType
    category?: StringFilter<"Investigation"> | string
    title?: StringFilter<"Investigation"> | string
    status?: EnumInvestigationStatusFilter<"Investigation"> | $Enums.InvestigationStatus
    result?: JsonNullableFilter<"Investigation">
    impression?: StringNullableFilter<"Investigation"> | string | null
    conductedAt?: DateTimeFilter<"Investigation"> | Date | string
    createdAt?: DateTimeFilter<"Investigation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    order?: XOR<ClinicalOrderNullableScalarRelationFilter, ClinicalOrderWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InvestigationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    impression?: SortOrderInput | SortOrder
    conductedAt?: SortOrder
    createdAt?: SortOrder
    _count?: InvestigationCountOrderByAggregateInput
    _max?: InvestigationMaxOrderByAggregateInput
    _min?: InvestigationMinOrderByAggregateInput
  }

  export type InvestigationScalarWhereWithAggregatesInput = {
    AND?: InvestigationScalarWhereWithAggregatesInput | InvestigationScalarWhereWithAggregatesInput[]
    OR?: InvestigationScalarWhereWithAggregatesInput[]
    NOT?: InvestigationScalarWhereWithAggregatesInput | InvestigationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investigation"> | string
    patientId?: StringWithAggregatesFilter<"Investigation"> | string
    orderId?: StringNullableWithAggregatesFilter<"Investigation"> | string | null
    authorId?: StringWithAggregatesFilter<"Investigation"> | string
    type?: EnumOrderTypeWithAggregatesFilter<"Investigation"> | $Enums.OrderType
    category?: StringWithAggregatesFilter<"Investigation"> | string
    title?: StringWithAggregatesFilter<"Investigation"> | string
    status?: EnumInvestigationStatusWithAggregatesFilter<"Investigation"> | $Enums.InvestigationStatus
    result?: JsonNullableWithAggregatesFilter<"Investigation">
    impression?: StringNullableWithAggregatesFilter<"Investigation"> | string | null
    conductedAt?: DateTimeWithAggregatesFilter<"Investigation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Investigation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    id?: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutShiftsInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutShiftInput
    checkIns?: NurseCheckInCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutShiftInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutShiftNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutShiftNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PatientCreateInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateInput = {
    id?: string
    bed?: string | null
    diagnosis?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateInput = {
    id?: string
    patientId: string
    bed?: string | null
    diagnosis?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
  }

  export type AdmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bed?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    bed?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdmissionCreateManyInput = {
    id?: string
    patientId: string
    bed?: string | null
    diagnosis?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
  }

  export type AdmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bed?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    bed?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicalNoteCreateInput = {
    id?: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
  }

  export type ClinicalNoteUncheckedCreateInput = {
    id?: string
    patientId: string
    authorId: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalNoteCreateManyInput = {
    id?: string
    patientId: string
    authorId: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    details?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAuditsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    details?: string | null
    userId: string
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    details?: string | null
    userId: string
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignCreateInput = {
    id?: string
    heartRate?: number | null
    bpSys?: number | null
    bpDia?: number | null
    spo2?: number | null
    temp?: number | null
    rbs?: number | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutVitalsInput
  }

  export type VitalSignUncheckedCreateInput = {
    id?: string
    patientId: string
    heartRate?: number | null
    bpSys?: number | null
    bpDia?: number | null
    spo2?: number | null
    temp?: number | null
    rbs?: number | null
    timestamp?: Date | string
  }

  export type VitalSignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    bpSys?: NullableIntFieldUpdateOperationsInput | number | null
    bpDia?: NullableIntFieldUpdateOperationsInput | number | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    temp?: NullableFloatFieldUpdateOperationsInput | number | null
    rbs?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutVitalsNestedInput
  }

  export type VitalSignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    bpSys?: NullableIntFieldUpdateOperationsInput | number | null
    bpDia?: NullableIntFieldUpdateOperationsInput | number | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    temp?: NullableFloatFieldUpdateOperationsInput | number | null
    rbs?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignCreateManyInput = {
    id?: string
    patientId: string
    heartRate?: number | null
    bpSys?: number | null
    bpDia?: number | null
    spo2?: number | null
    temp?: number | null
    rbs?: number | null
    timestamp?: Date | string
  }

  export type VitalSignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    bpSys?: NullableIntFieldUpdateOperationsInput | number | null
    bpDia?: NullableIntFieldUpdateOperationsInput | number | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    temp?: NullableFloatFieldUpdateOperationsInput | number | null
    rbs?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    bpSys?: NullableIntFieldUpdateOperationsInput | number | null
    bpDia?: NullableIntFieldUpdateOperationsInput | number | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    temp?: NullableFloatFieldUpdateOperationsInput | number | null
    rbs?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
    patient?: PatientCreateNestedOneWithoutPrescriptionsInput
    administrations?: MedicationAdministrationCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
    patientId?: string | null
    administrations?: MedicationAdministrationUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneWithoutPrescriptionsNestedInput
    administrations?: MedicationAdministrationUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    administrations?: MedicationAdministrationUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationCreateManyInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
    patientId?: string | null
  }

  export type MedicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DrugCatalogCreateInput = {
    id?: string
    name: string
    defaultDose?: string | null
    defaultRoute?: string | null
    createdAt?: Date | string
  }

  export type DrugCatalogUncheckedCreateInput = {
    id?: string
    name: string
    defaultDose?: string | null
    defaultRoute?: string | null
    createdAt?: Date | string
  }

  export type DrugCatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: NullableStringFieldUpdateOperationsInput | string | null
    defaultRoute?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrugCatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: NullableStringFieldUpdateOperationsInput | string | null
    defaultRoute?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrugCatalogCreateManyInput = {
    id?: string
    name: string
    defaultDose?: string | null
    defaultRoute?: string | null
    createdAt?: Date | string
  }

  export type DrugCatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: NullableStringFieldUpdateOperationsInput | string | null
    defaultRoute?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrugCatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: NullableStringFieldUpdateOperationsInput | string | null
    defaultRoute?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationCreateInput = {
    id?: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutMedicationsInput
    medication: MedicationCreateNestedOneWithoutAdministrationsInput
    user?: UserCreateNestedOneWithoutAdministeredMedsInput
  }

  export type MedicationAdministrationUncheckedCreateInput = {
    id?: string
    patientId: string
    medicationId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type MedicationAdministrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicationsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutAdministrationsNestedInput
    user?: UserUpdateOneWithoutAdministeredMedsNestedInput
  }

  export type MedicationAdministrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationAdministrationCreateManyInput = {
    id?: string
    patientId: string
    medicationId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type MedicationAdministrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntakeOutputCreateInput = {
    id?: string
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutIoEntriesInput
    user: UserCreateNestedOneWithoutIoEntriesInput
    shift?: ShiftCreateNestedOneWithoutIoEntriesInput
  }

  export type IntakeOutputUncheckedCreateInput = {
    id?: string
    patientId: string
    userId: string
    shiftId?: string | null
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type IntakeOutputUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutIoEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutIoEntriesNestedInput
    shift?: ShiftUpdateOneWithoutIoEntriesNestedInput
  }

  export type IntakeOutputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntakeOutputCreateManyInput = {
    id?: string
    patientId: string
    userId: string
    shiftId?: string | null
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type IntakeOutputUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntakeOutputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInCreateInput = {
    id?: string
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutCheckInsInput
    user: UserCreateNestedOneWithoutCheckInsInput
    shift?: ShiftCreateNestedOneWithoutCheckInsInput
  }

  export type NurseCheckInUncheckedCreateInput = {
    id?: string
    patientId: string
    userId: string
    shiftId?: string | null
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutCheckInsNestedInput
    user?: UserUpdateOneRequiredWithoutCheckInsNestedInput
    shift?: ShiftUpdateOneWithoutCheckInsNestedInput
  }

  export type NurseCheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInCreateManyInput = {
    id?: string
    patientId: string
    userId: string
    shiftId?: string | null
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernorateCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernorateUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernorateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernorateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernorateCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernorateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernorateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalOrderCreateInput = {
    id?: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutOrdersInput
    author: UserCreateNestedOneWithoutCreatedOrdersInput
    approver?: UserCreateNestedOneWithoutApprovedOrdersInput
    investigations?: InvestigationCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderUncheckedCreateInput = {
    id?: string
    patientId: string
    authorId: string
    approverId?: string | null
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investigations?: InvestigationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutOrdersNestedInput
    author?: UserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    approver?: UserUpdateOneWithoutApprovedOrdersNestedInput
    investigations?: InvestigationUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigations?: InvestigationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderCreateManyInput = {
    id?: string
    patientId: string
    authorId: string
    approverId?: string | null
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialistNoteCreateInput = {
    id?: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutSpecialistNotesInput
    author: UserCreateNestedOneWithoutSpecialistNotesInput
  }

  export type SpecialistNoteUncheckedCreateInput = {
    id?: string
    patientId: string
    authorId: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialistNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutSpecialistNotesNestedInput
    author?: UserUpdateOneRequiredWithoutSpecialistNotesNestedInput
  }

  export type SpecialistNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialistNoteCreateManyInput = {
    id?: string
    patientId: string
    authorId: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialistNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialistNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationCreateInput = {
    id?: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvestigationsInput
    order?: ClinicalOrderCreateNestedOneWithoutInvestigationsInput
    author: UserCreateNestedOneWithoutInvestigationsInput
  }

  export type InvestigationUncheckedCreateInput = {
    id?: string
    patientId: string
    orderId?: string | null
    authorId: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type InvestigationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvestigationsNestedInput
    order?: ClinicalOrderUpdateOneWithoutInvestigationsNestedInput
    author?: UserUpdateOneRequiredWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationCreateManyInput = {
    id?: string
    patientId: string
    orderId?: string | null
    authorId: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type InvestigationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type ClinicalNoteListRelationFilter = {
    every?: ClinicalNoteWhereInput
    some?: ClinicalNoteWhereInput
    none?: ClinicalNoteWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type IntakeOutputListRelationFilter = {
    every?: IntakeOutputWhereInput
    some?: IntakeOutputWhereInput
    none?: IntakeOutputWhereInput
  }

  export type NurseCheckInListRelationFilter = {
    every?: NurseCheckInWhereInput
    some?: NurseCheckInWhereInput
    none?: NurseCheckInWhereInput
  }

  export type ClinicalOrderListRelationFilter = {
    every?: ClinicalOrderWhereInput
    some?: ClinicalOrderWhereInput
    none?: ClinicalOrderWhereInput
  }

  export type InvestigationListRelationFilter = {
    every?: InvestigationWhereInput
    some?: InvestigationWhereInput
    none?: InvestigationWhereInput
  }

  export type SpecialistNoteListRelationFilter = {
    every?: SpecialistNoteWhereInput
    some?: SpecialistNoteWhereInput
    none?: SpecialistNoteWhereInput
  }

  export type MedicationAdministrationListRelationFilter = {
    every?: MedicationAdministrationWhereInput
    some?: MedicationAdministrationWhereInput
    none?: MedicationAdministrationWhereInput
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicalNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntakeOutputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NurseCheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicalOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestigationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialistNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationAdministrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumShiftTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftType | EnumShiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftTypeFilter<$PrismaModel> | $Enums.ShiftType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
  }

  export type EnumShiftTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftType | EnumShiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShiftType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftTypeFilter<$PrismaModel>
    _max?: NestedEnumShiftTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AdmissionListRelationFilter = {
    every?: AdmissionWhereInput
    some?: AdmissionWhereInput
    none?: AdmissionWhereInput
  }

  export type VitalSignListRelationFilter = {
    every?: VitalSignWhereInput
    some?: VitalSignWhereInput
    none?: VitalSignWhereInput
  }

  export type MedicationListRelationFilter = {
    every?: MedicationWhereInput
    some?: MedicationWhereInput
    none?: MedicationWhereInput
  }

  export type AdmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitalSignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    mrn?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    comorbidities?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    mrn?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    mrn?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    diagnosis?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AdmissionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    bed?: SortOrder
    diagnosis?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
  }

  export type AdmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    bed?: SortOrder
    diagnosis?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
  }

  export type AdmissionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    bed?: SortOrder
    diagnosis?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
  }

  export type EnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClinicalNoteCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicalNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicalNoteMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VitalSignCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    heartRate?: SortOrder
    bpSys?: SortOrder
    bpDia?: SortOrder
    spo2?: SortOrder
    temp?: SortOrder
    rbs?: SortOrder
    timestamp?: SortOrder
  }

  export type VitalSignAvgOrderByAggregateInput = {
    heartRate?: SortOrder
    bpSys?: SortOrder
    bpDia?: SortOrder
    spo2?: SortOrder
    temp?: SortOrder
    rbs?: SortOrder
  }

  export type VitalSignMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    heartRate?: SortOrder
    bpSys?: SortOrder
    bpDia?: SortOrder
    spo2?: SortOrder
    temp?: SortOrder
    rbs?: SortOrder
    timestamp?: SortOrder
  }

  export type VitalSignMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    heartRate?: SortOrder
    bpSys?: SortOrder
    bpDia?: SortOrder
    spo2?: SortOrder
    temp?: SortOrder
    rbs?: SortOrder
    timestamp?: SortOrder
  }

  export type VitalSignSumOrderByAggregateInput = {
    heartRate?: SortOrder
    bpSys?: SortOrder
    bpDia?: SortOrder
    spo2?: SortOrder
    temp?: SortOrder
    rbs?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    infusionRate?: SortOrder
    otherInstructions?: SortOrder
    patientId?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    infusionRate?: SortOrder
    otherInstructions?: SortOrder
    patientId?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    route?: SortOrder
    frequency?: SortOrder
    infusionRate?: SortOrder
    otherInstructions?: SortOrder
    patientId?: SortOrder
  }

  export type DrugCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    defaultRoute?: SortOrder
    createdAt?: SortOrder
  }

  export type DrugCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    defaultRoute?: SortOrder
    createdAt?: SortOrder
  }

  export type DrugCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    defaultDose?: SortOrder
    defaultRoute?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicationScalarRelationFilter = {
    is?: MedicationWhereInput
    isNot?: MedicationWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MedicationAdministrationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dose?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type MedicationAdministrationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dose?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type MedicationAdministrationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dose?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ShiftNullableScalarRelationFilter = {
    is?: ShiftWhereInput | null
    isNot?: ShiftWhereInput | null
  }

  export type IntakeOutputCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type IntakeOutputAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntakeOutputMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type IntakeOutputMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type IntakeOutputSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NurseCheckInCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    airwaySafe?: SortOrder
    breathingOk?: SortOrder
    circulationOk?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type NurseCheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    airwaySafe?: SortOrder
    breathingOk?: SortOrder
    circulationOk?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type NurseCheckInMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    userId?: SortOrder
    shiftId?: SortOrder
    airwaySafe?: SortOrder
    breathingOk?: SortOrder
    circulationOk?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type GovernorateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernorateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernorateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type ClinicalOrderCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    approverId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    details?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicalOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    approverId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicalOrderMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    approverId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type SpecialistNoteCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    apacheScore?: SortOrder
    histHT?: SortOrder
    histDM?: SortOrder
    histAsthma?: SortOrder
    histCOPD?: SortOrder
    histIHD?: SortOrder
    histStroke?: SortOrder
    histOther?: SortOrder
    neuroGCS?: SortOrder
    neuroRASS?: SortOrder
    respChest?: SortOrder
    respRoomAir?: SortOrder
    respO2Therapy?: SortOrder
    respVentMode?: SortOrder
    respVentModeText?: SortOrder
    respFio2?: SortOrder
    respPS?: SortOrder
    intCVLine?: SortOrder
    intArtLine?: SortOrder
    intETT?: SortOrder
    intTrach?: SortOrder
    intDoubleLumen?: SortOrder
    hydNormovolemia?: SortOrder
    hydHypervolemia?: SortOrder
    hydHypovolemia?: SortOrder
    hydUOP?: SortOrder
    hydIVC?: SortOrder
    hydCVP?: SortOrder
    hemoStable?: SortOrder
    hemoUnstable?: SortOrder
    hemoVasopressor?: SortOrder
    feedOral?: SortOrder
    feedNG?: SortOrder
    feedTPN?: SortOrder
    feedRate?: SortOrder
    ivFluidsRate?: SortOrder
    sedPropofol?: SortOrder
    sedKetamine?: SortOrder
    sedMidazolam?: SortOrder
    sedRemif?: SortOrder
    sedMR?: SortOrder
    sedOther?: SortOrder
    clinicalNotes?: SortOrder
    planVentilatory?: SortOrder
    planPhysio?: SortOrder
    planConsult?: SortOrder
    planInvestigation?: SortOrder
    planOther?: SortOrder
    planFuture?: SortOrder
    planHomeTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialistNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    apacheScore?: SortOrder
    histHT?: SortOrder
    histDM?: SortOrder
    histAsthma?: SortOrder
    histCOPD?: SortOrder
    histIHD?: SortOrder
    histStroke?: SortOrder
    histOther?: SortOrder
    neuroGCS?: SortOrder
    neuroRASS?: SortOrder
    respChest?: SortOrder
    respRoomAir?: SortOrder
    respO2Therapy?: SortOrder
    respVentMode?: SortOrder
    respVentModeText?: SortOrder
    respFio2?: SortOrder
    respPS?: SortOrder
    intCVLine?: SortOrder
    intArtLine?: SortOrder
    intETT?: SortOrder
    intTrach?: SortOrder
    intDoubleLumen?: SortOrder
    hydNormovolemia?: SortOrder
    hydHypervolemia?: SortOrder
    hydHypovolemia?: SortOrder
    hydUOP?: SortOrder
    hydIVC?: SortOrder
    hydCVP?: SortOrder
    hemoStable?: SortOrder
    hemoUnstable?: SortOrder
    hemoVasopressor?: SortOrder
    feedOral?: SortOrder
    feedNG?: SortOrder
    feedTPN?: SortOrder
    feedRate?: SortOrder
    ivFluidsRate?: SortOrder
    sedPropofol?: SortOrder
    sedKetamine?: SortOrder
    sedMidazolam?: SortOrder
    sedRemif?: SortOrder
    sedMR?: SortOrder
    sedOther?: SortOrder
    clinicalNotes?: SortOrder
    planVentilatory?: SortOrder
    planPhysio?: SortOrder
    planConsult?: SortOrder
    planInvestigation?: SortOrder
    planOther?: SortOrder
    planFuture?: SortOrder
    planHomeTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialistNoteMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    apacheScore?: SortOrder
    histHT?: SortOrder
    histDM?: SortOrder
    histAsthma?: SortOrder
    histCOPD?: SortOrder
    histIHD?: SortOrder
    histStroke?: SortOrder
    histOther?: SortOrder
    neuroGCS?: SortOrder
    neuroRASS?: SortOrder
    respChest?: SortOrder
    respRoomAir?: SortOrder
    respO2Therapy?: SortOrder
    respVentMode?: SortOrder
    respVentModeText?: SortOrder
    respFio2?: SortOrder
    respPS?: SortOrder
    intCVLine?: SortOrder
    intArtLine?: SortOrder
    intETT?: SortOrder
    intTrach?: SortOrder
    intDoubleLumen?: SortOrder
    hydNormovolemia?: SortOrder
    hydHypervolemia?: SortOrder
    hydHypovolemia?: SortOrder
    hydUOP?: SortOrder
    hydIVC?: SortOrder
    hydCVP?: SortOrder
    hemoStable?: SortOrder
    hemoUnstable?: SortOrder
    hemoVasopressor?: SortOrder
    feedOral?: SortOrder
    feedNG?: SortOrder
    feedTPN?: SortOrder
    feedRate?: SortOrder
    ivFluidsRate?: SortOrder
    sedPropofol?: SortOrder
    sedKetamine?: SortOrder
    sedMidazolam?: SortOrder
    sedRemif?: SortOrder
    sedMR?: SortOrder
    sedOther?: SortOrder
    clinicalNotes?: SortOrder
    planVentilatory?: SortOrder
    planPhysio?: SortOrder
    planConsult?: SortOrder
    planInvestigation?: SortOrder
    planOther?: SortOrder
    planFuture?: SortOrder
    planHomeTeam?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvestigationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestigationStatus | EnumInvestigationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestigationStatusFilter<$PrismaModel> | $Enums.InvestigationStatus
  }

  export type ClinicalOrderNullableScalarRelationFilter = {
    is?: ClinicalOrderWhereInput | null
    isNot?: ClinicalOrderWhereInput | null
  }

  export type InvestigationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    status?: SortOrder
    result?: SortOrder
    impression?: SortOrder
    conductedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvestigationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    status?: SortOrder
    impression?: SortOrder
    conductedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvestigationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    orderId?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    status?: SortOrder
    impression?: SortOrder
    conductedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInvestigationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestigationStatus | EnumInvestigationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestigationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestigationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestigationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestigationStatusFilter<$PrismaModel>
  }

  export type ShiftCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ClinicalNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClinicalNoteCreateWithoutAuthorInput, ClinicalNoteUncheckedCreateWithoutAuthorInput> | ClinicalNoteCreateWithoutAuthorInput[] | ClinicalNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAuthorInput | ClinicalNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: ClinicalNoteCreateManyAuthorInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type IntakeOutputCreateNestedManyWithoutUserInput = {
    create?: XOR<IntakeOutputCreateWithoutUserInput, IntakeOutputUncheckedCreateWithoutUserInput> | IntakeOutputCreateWithoutUserInput[] | IntakeOutputUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutUserInput | IntakeOutputCreateOrConnectWithoutUserInput[]
    createMany?: IntakeOutputCreateManyUserInputEnvelope
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
  }

  export type NurseCheckInCreateNestedManyWithoutUserInput = {
    create?: XOR<NurseCheckInCreateWithoutUserInput, NurseCheckInUncheckedCreateWithoutUserInput> | NurseCheckInCreateWithoutUserInput[] | NurseCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutUserInput | NurseCheckInCreateOrConnectWithoutUserInput[]
    createMany?: NurseCheckInCreateManyUserInputEnvelope
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
  }

  export type ClinicalOrderCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClinicalOrderCreateWithoutAuthorInput, ClinicalOrderUncheckedCreateWithoutAuthorInput> | ClinicalOrderCreateWithoutAuthorInput[] | ClinicalOrderUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutAuthorInput | ClinicalOrderCreateOrConnectWithoutAuthorInput[]
    createMany?: ClinicalOrderCreateManyAuthorInputEnvelope
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
  }

  export type ClinicalOrderCreateNestedManyWithoutApproverInput = {
    create?: XOR<ClinicalOrderCreateWithoutApproverInput, ClinicalOrderUncheckedCreateWithoutApproverInput> | ClinicalOrderCreateWithoutApproverInput[] | ClinicalOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutApproverInput | ClinicalOrderCreateOrConnectWithoutApproverInput[]
    createMany?: ClinicalOrderCreateManyApproverInputEnvelope
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
  }

  export type InvestigationCreateNestedManyWithoutAuthorInput = {
    create?: XOR<InvestigationCreateWithoutAuthorInput, InvestigationUncheckedCreateWithoutAuthorInput> | InvestigationCreateWithoutAuthorInput[] | InvestigationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutAuthorInput | InvestigationCreateOrConnectWithoutAuthorInput[]
    createMany?: InvestigationCreateManyAuthorInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type SpecialistNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<SpecialistNoteCreateWithoutAuthorInput, SpecialistNoteUncheckedCreateWithoutAuthorInput> | SpecialistNoteCreateWithoutAuthorInput[] | SpecialistNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutAuthorInput | SpecialistNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: SpecialistNoteCreateManyAuthorInputEnvelope
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
  }

  export type MedicationAdministrationCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicationAdministrationCreateWithoutUserInput, MedicationAdministrationUncheckedCreateWithoutUserInput> | MedicationAdministrationCreateWithoutUserInput[] | MedicationAdministrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutUserInput | MedicationAdministrationCreateOrConnectWithoutUserInput[]
    createMany?: MedicationAdministrationCreateManyUserInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClinicalNoteCreateWithoutAuthorInput, ClinicalNoteUncheckedCreateWithoutAuthorInput> | ClinicalNoteCreateWithoutAuthorInput[] | ClinicalNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAuthorInput | ClinicalNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: ClinicalNoteCreateManyAuthorInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type IntakeOutputUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IntakeOutputCreateWithoutUserInput, IntakeOutputUncheckedCreateWithoutUserInput> | IntakeOutputCreateWithoutUserInput[] | IntakeOutputUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutUserInput | IntakeOutputCreateOrConnectWithoutUserInput[]
    createMany?: IntakeOutputCreateManyUserInputEnvelope
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
  }

  export type NurseCheckInUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NurseCheckInCreateWithoutUserInput, NurseCheckInUncheckedCreateWithoutUserInput> | NurseCheckInCreateWithoutUserInput[] | NurseCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutUserInput | NurseCheckInCreateOrConnectWithoutUserInput[]
    createMany?: NurseCheckInCreateManyUserInputEnvelope
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
  }

  export type ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ClinicalOrderCreateWithoutAuthorInput, ClinicalOrderUncheckedCreateWithoutAuthorInput> | ClinicalOrderCreateWithoutAuthorInput[] | ClinicalOrderUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutAuthorInput | ClinicalOrderCreateOrConnectWithoutAuthorInput[]
    createMany?: ClinicalOrderCreateManyAuthorInputEnvelope
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
  }

  export type ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ClinicalOrderCreateWithoutApproverInput, ClinicalOrderUncheckedCreateWithoutApproverInput> | ClinicalOrderCreateWithoutApproverInput[] | ClinicalOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutApproverInput | ClinicalOrderCreateOrConnectWithoutApproverInput[]
    createMany?: ClinicalOrderCreateManyApproverInputEnvelope
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
  }

  export type InvestigationUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<InvestigationCreateWithoutAuthorInput, InvestigationUncheckedCreateWithoutAuthorInput> | InvestigationCreateWithoutAuthorInput[] | InvestigationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutAuthorInput | InvestigationCreateOrConnectWithoutAuthorInput[]
    createMany?: InvestigationCreateManyAuthorInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<SpecialistNoteCreateWithoutAuthorInput, SpecialistNoteUncheckedCreateWithoutAuthorInput> | SpecialistNoteCreateWithoutAuthorInput[] | SpecialistNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutAuthorInput | SpecialistNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: SpecialistNoteCreateManyAuthorInputEnvelope
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
  }

  export type MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicationAdministrationCreateWithoutUserInput, MedicationAdministrationUncheckedCreateWithoutUserInput> | MedicationAdministrationCreateWithoutUserInput[] | MedicationAdministrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutUserInput | MedicationAdministrationCreateOrConnectWithoutUserInput[]
    createMany?: MedicationAdministrationCreateManyUserInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ShiftUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutUserInput | ShiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutUserInput | ShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutUserInput | ShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ClinicalNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutAuthorInput, ClinicalNoteUncheckedCreateWithoutAuthorInput> | ClinicalNoteCreateWithoutAuthorInput[] | ClinicalNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAuthorInput | ClinicalNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutAuthorInput | ClinicalNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClinicalNoteCreateManyAuthorInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutAuthorInput | ClinicalNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutAuthorInput | ClinicalNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type IntakeOutputUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntakeOutputCreateWithoutUserInput, IntakeOutputUncheckedCreateWithoutUserInput> | IntakeOutputCreateWithoutUserInput[] | IntakeOutputUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutUserInput | IntakeOutputCreateOrConnectWithoutUserInput[]
    upsert?: IntakeOutputUpsertWithWhereUniqueWithoutUserInput | IntakeOutputUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntakeOutputCreateManyUserInputEnvelope
    set?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    disconnect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    delete?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    update?: IntakeOutputUpdateWithWhereUniqueWithoutUserInput | IntakeOutputUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntakeOutputUpdateManyWithWhereWithoutUserInput | IntakeOutputUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
  }

  export type NurseCheckInUpdateManyWithoutUserNestedInput = {
    create?: XOR<NurseCheckInCreateWithoutUserInput, NurseCheckInUncheckedCreateWithoutUserInput> | NurseCheckInCreateWithoutUserInput[] | NurseCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutUserInput | NurseCheckInCreateOrConnectWithoutUserInput[]
    upsert?: NurseCheckInUpsertWithWhereUniqueWithoutUserInput | NurseCheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NurseCheckInCreateManyUserInputEnvelope
    set?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    disconnect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    delete?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    update?: NurseCheckInUpdateWithWhereUniqueWithoutUserInput | NurseCheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NurseCheckInUpdateManyWithWhereWithoutUserInput | NurseCheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
  }

  export type ClinicalOrderUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClinicalOrderCreateWithoutAuthorInput, ClinicalOrderUncheckedCreateWithoutAuthorInput> | ClinicalOrderCreateWithoutAuthorInput[] | ClinicalOrderUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutAuthorInput | ClinicalOrderCreateOrConnectWithoutAuthorInput[]
    upsert?: ClinicalOrderUpsertWithWhereUniqueWithoutAuthorInput | ClinicalOrderUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClinicalOrderCreateManyAuthorInputEnvelope
    set?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    disconnect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    delete?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    update?: ClinicalOrderUpdateWithWhereUniqueWithoutAuthorInput | ClinicalOrderUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClinicalOrderUpdateManyWithWhereWithoutAuthorInput | ClinicalOrderUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
  }

  export type ClinicalOrderUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ClinicalOrderCreateWithoutApproverInput, ClinicalOrderUncheckedCreateWithoutApproverInput> | ClinicalOrderCreateWithoutApproverInput[] | ClinicalOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutApproverInput | ClinicalOrderCreateOrConnectWithoutApproverInput[]
    upsert?: ClinicalOrderUpsertWithWhereUniqueWithoutApproverInput | ClinicalOrderUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ClinicalOrderCreateManyApproverInputEnvelope
    set?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    disconnect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    delete?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    update?: ClinicalOrderUpdateWithWhereUniqueWithoutApproverInput | ClinicalOrderUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ClinicalOrderUpdateManyWithWhereWithoutApproverInput | ClinicalOrderUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
  }

  export type InvestigationUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<InvestigationCreateWithoutAuthorInput, InvestigationUncheckedCreateWithoutAuthorInput> | InvestigationCreateWithoutAuthorInput[] | InvestigationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutAuthorInput | InvestigationCreateOrConnectWithoutAuthorInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutAuthorInput | InvestigationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: InvestigationCreateManyAuthorInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutAuthorInput | InvestigationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutAuthorInput | InvestigationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type SpecialistNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<SpecialistNoteCreateWithoutAuthorInput, SpecialistNoteUncheckedCreateWithoutAuthorInput> | SpecialistNoteCreateWithoutAuthorInput[] | SpecialistNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutAuthorInput | SpecialistNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: SpecialistNoteUpsertWithWhereUniqueWithoutAuthorInput | SpecialistNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: SpecialistNoteCreateManyAuthorInputEnvelope
    set?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    disconnect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    delete?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    update?: SpecialistNoteUpdateWithWhereUniqueWithoutAuthorInput | SpecialistNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: SpecialistNoteUpdateManyWithWhereWithoutAuthorInput | SpecialistNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: SpecialistNoteScalarWhereInput | SpecialistNoteScalarWhereInput[]
  }

  export type MedicationAdministrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutUserInput, MedicationAdministrationUncheckedCreateWithoutUserInput> | MedicationAdministrationCreateWithoutUserInput[] | MedicationAdministrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutUserInput | MedicationAdministrationCreateOrConnectWithoutUserInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutUserInput | MedicationAdministrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicationAdministrationCreateManyUserInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutUserInput | MedicationAdministrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutUserInput | MedicationAdministrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutUserInput | ShiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutUserInput | ShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutUserInput | ShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutAuthorInput, ClinicalNoteUncheckedCreateWithoutAuthorInput> | ClinicalNoteCreateWithoutAuthorInput[] | ClinicalNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAuthorInput | ClinicalNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutAuthorInput | ClinicalNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClinicalNoteCreateManyAuthorInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutAuthorInput | ClinicalNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutAuthorInput | ClinicalNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type IntakeOutputUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntakeOutputCreateWithoutUserInput, IntakeOutputUncheckedCreateWithoutUserInput> | IntakeOutputCreateWithoutUserInput[] | IntakeOutputUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutUserInput | IntakeOutputCreateOrConnectWithoutUserInput[]
    upsert?: IntakeOutputUpsertWithWhereUniqueWithoutUserInput | IntakeOutputUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntakeOutputCreateManyUserInputEnvelope
    set?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    disconnect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    delete?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    update?: IntakeOutputUpdateWithWhereUniqueWithoutUserInput | IntakeOutputUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntakeOutputUpdateManyWithWhereWithoutUserInput | IntakeOutputUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
  }

  export type NurseCheckInUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NurseCheckInCreateWithoutUserInput, NurseCheckInUncheckedCreateWithoutUserInput> | NurseCheckInCreateWithoutUserInput[] | NurseCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutUserInput | NurseCheckInCreateOrConnectWithoutUserInput[]
    upsert?: NurseCheckInUpsertWithWhereUniqueWithoutUserInput | NurseCheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NurseCheckInCreateManyUserInputEnvelope
    set?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    disconnect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    delete?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    update?: NurseCheckInUpdateWithWhereUniqueWithoutUserInput | NurseCheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NurseCheckInUpdateManyWithWhereWithoutUserInput | NurseCheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
  }

  export type ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ClinicalOrderCreateWithoutAuthorInput, ClinicalOrderUncheckedCreateWithoutAuthorInput> | ClinicalOrderCreateWithoutAuthorInput[] | ClinicalOrderUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutAuthorInput | ClinicalOrderCreateOrConnectWithoutAuthorInput[]
    upsert?: ClinicalOrderUpsertWithWhereUniqueWithoutAuthorInput | ClinicalOrderUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ClinicalOrderCreateManyAuthorInputEnvelope
    set?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    disconnect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    delete?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    update?: ClinicalOrderUpdateWithWhereUniqueWithoutAuthorInput | ClinicalOrderUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ClinicalOrderUpdateManyWithWhereWithoutAuthorInput | ClinicalOrderUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
  }

  export type ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ClinicalOrderCreateWithoutApproverInput, ClinicalOrderUncheckedCreateWithoutApproverInput> | ClinicalOrderCreateWithoutApproverInput[] | ClinicalOrderUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutApproverInput | ClinicalOrderCreateOrConnectWithoutApproverInput[]
    upsert?: ClinicalOrderUpsertWithWhereUniqueWithoutApproverInput | ClinicalOrderUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ClinicalOrderCreateManyApproverInputEnvelope
    set?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    disconnect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    delete?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    update?: ClinicalOrderUpdateWithWhereUniqueWithoutApproverInput | ClinicalOrderUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ClinicalOrderUpdateManyWithWhereWithoutApproverInput | ClinicalOrderUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
  }

  export type InvestigationUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<InvestigationCreateWithoutAuthorInput, InvestigationUncheckedCreateWithoutAuthorInput> | InvestigationCreateWithoutAuthorInput[] | InvestigationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutAuthorInput | InvestigationCreateOrConnectWithoutAuthorInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutAuthorInput | InvestigationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: InvestigationCreateManyAuthorInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutAuthorInput | InvestigationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutAuthorInput | InvestigationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<SpecialistNoteCreateWithoutAuthorInput, SpecialistNoteUncheckedCreateWithoutAuthorInput> | SpecialistNoteCreateWithoutAuthorInput[] | SpecialistNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutAuthorInput | SpecialistNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: SpecialistNoteUpsertWithWhereUniqueWithoutAuthorInput | SpecialistNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: SpecialistNoteCreateManyAuthorInputEnvelope
    set?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    disconnect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    delete?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    update?: SpecialistNoteUpdateWithWhereUniqueWithoutAuthorInput | SpecialistNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: SpecialistNoteUpdateManyWithWhereWithoutAuthorInput | SpecialistNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: SpecialistNoteScalarWhereInput | SpecialistNoteScalarWhereInput[]
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutUserInput, MedicationAdministrationUncheckedCreateWithoutUserInput> | MedicationAdministrationCreateWithoutUserInput[] | MedicationAdministrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutUserInput | MedicationAdministrationCreateOrConnectWithoutUserInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutUserInput | MedicationAdministrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicationAdministrationCreateManyUserInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutUserInput | MedicationAdministrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutUserInput | MedicationAdministrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutShiftsInput = {
    create?: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsInput
    connect?: UserWhereUniqueInput
  }

  export type IntakeOutputCreateNestedManyWithoutShiftInput = {
    create?: XOR<IntakeOutputCreateWithoutShiftInput, IntakeOutputUncheckedCreateWithoutShiftInput> | IntakeOutputCreateWithoutShiftInput[] | IntakeOutputUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutShiftInput | IntakeOutputCreateOrConnectWithoutShiftInput[]
    createMany?: IntakeOutputCreateManyShiftInputEnvelope
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
  }

  export type NurseCheckInCreateNestedManyWithoutShiftInput = {
    create?: XOR<NurseCheckInCreateWithoutShiftInput, NurseCheckInUncheckedCreateWithoutShiftInput> | NurseCheckInCreateWithoutShiftInput[] | NurseCheckInUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutShiftInput | NurseCheckInCreateOrConnectWithoutShiftInput[]
    createMany?: NurseCheckInCreateManyShiftInputEnvelope
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
  }

  export type IntakeOutputUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<IntakeOutputCreateWithoutShiftInput, IntakeOutputUncheckedCreateWithoutShiftInput> | IntakeOutputCreateWithoutShiftInput[] | IntakeOutputUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutShiftInput | IntakeOutputCreateOrConnectWithoutShiftInput[]
    createMany?: IntakeOutputCreateManyShiftInputEnvelope
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
  }

  export type NurseCheckInUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<NurseCheckInCreateWithoutShiftInput, NurseCheckInUncheckedCreateWithoutShiftInput> | NurseCheckInCreateWithoutShiftInput[] | NurseCheckInUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutShiftInput | NurseCheckInCreateOrConnectWithoutShiftInput[]
    createMany?: NurseCheckInCreateManyShiftInputEnvelope
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
  }

  export type EnumShiftTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShiftType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsInput
    upsert?: UserUpsertWithoutShiftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftsInput, UserUpdateWithoutShiftsInput>, UserUncheckedUpdateWithoutShiftsInput>
  }

  export type IntakeOutputUpdateManyWithoutShiftNestedInput = {
    create?: XOR<IntakeOutputCreateWithoutShiftInput, IntakeOutputUncheckedCreateWithoutShiftInput> | IntakeOutputCreateWithoutShiftInput[] | IntakeOutputUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutShiftInput | IntakeOutputCreateOrConnectWithoutShiftInput[]
    upsert?: IntakeOutputUpsertWithWhereUniqueWithoutShiftInput | IntakeOutputUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: IntakeOutputCreateManyShiftInputEnvelope
    set?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    disconnect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    delete?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    update?: IntakeOutputUpdateWithWhereUniqueWithoutShiftInput | IntakeOutputUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: IntakeOutputUpdateManyWithWhereWithoutShiftInput | IntakeOutputUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
  }

  export type NurseCheckInUpdateManyWithoutShiftNestedInput = {
    create?: XOR<NurseCheckInCreateWithoutShiftInput, NurseCheckInUncheckedCreateWithoutShiftInput> | NurseCheckInCreateWithoutShiftInput[] | NurseCheckInUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutShiftInput | NurseCheckInCreateOrConnectWithoutShiftInput[]
    upsert?: NurseCheckInUpsertWithWhereUniqueWithoutShiftInput | NurseCheckInUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: NurseCheckInCreateManyShiftInputEnvelope
    set?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    disconnect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    delete?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    update?: NurseCheckInUpdateWithWhereUniqueWithoutShiftInput | NurseCheckInUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: NurseCheckInUpdateManyWithWhereWithoutShiftInput | NurseCheckInUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
  }

  export type IntakeOutputUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<IntakeOutputCreateWithoutShiftInput, IntakeOutputUncheckedCreateWithoutShiftInput> | IntakeOutputCreateWithoutShiftInput[] | IntakeOutputUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutShiftInput | IntakeOutputCreateOrConnectWithoutShiftInput[]
    upsert?: IntakeOutputUpsertWithWhereUniqueWithoutShiftInput | IntakeOutputUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: IntakeOutputCreateManyShiftInputEnvelope
    set?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    disconnect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    delete?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    update?: IntakeOutputUpdateWithWhereUniqueWithoutShiftInput | IntakeOutputUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: IntakeOutputUpdateManyWithWhereWithoutShiftInput | IntakeOutputUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
  }

  export type NurseCheckInUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<NurseCheckInCreateWithoutShiftInput, NurseCheckInUncheckedCreateWithoutShiftInput> | NurseCheckInCreateWithoutShiftInput[] | NurseCheckInUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutShiftInput | NurseCheckInCreateOrConnectWithoutShiftInput[]
    upsert?: NurseCheckInUpsertWithWhereUniqueWithoutShiftInput | NurseCheckInUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: NurseCheckInCreateManyShiftInputEnvelope
    set?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    disconnect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    delete?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    update?: NurseCheckInUpdateWithWhereUniqueWithoutShiftInput | NurseCheckInUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: NurseCheckInUpdateManyWithWhereWithoutShiftInput | NurseCheckInUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
  }

  export type PatientCreatecomorbiditiesInput = {
    set: string[]
  }

  export type AdmissionCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ClinicalNoteCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type VitalSignCreateNestedManyWithoutPatientInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type MedicationAdministrationCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationAdministrationCreateWithoutPatientInput, MedicationAdministrationUncheckedCreateWithoutPatientInput> | MedicationAdministrationCreateWithoutPatientInput[] | MedicationAdministrationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutPatientInput | MedicationAdministrationCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationAdministrationCreateManyPatientInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type MedicationCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type IntakeOutputCreateNestedManyWithoutPatientInput = {
    create?: XOR<IntakeOutputCreateWithoutPatientInput, IntakeOutputUncheckedCreateWithoutPatientInput> | IntakeOutputCreateWithoutPatientInput[] | IntakeOutputUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutPatientInput | IntakeOutputCreateOrConnectWithoutPatientInput[]
    createMany?: IntakeOutputCreateManyPatientInputEnvelope
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
  }

  export type NurseCheckInCreateNestedManyWithoutPatientInput = {
    create?: XOR<NurseCheckInCreateWithoutPatientInput, NurseCheckInUncheckedCreateWithoutPatientInput> | NurseCheckInCreateWithoutPatientInput[] | NurseCheckInUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutPatientInput | NurseCheckInCreateOrConnectWithoutPatientInput[]
    createMany?: NurseCheckInCreateManyPatientInputEnvelope
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
  }

  export type ClinicalOrderCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalOrderCreateWithoutPatientInput, ClinicalOrderUncheckedCreateWithoutPatientInput> | ClinicalOrderCreateWithoutPatientInput[] | ClinicalOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutPatientInput | ClinicalOrderCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalOrderCreateManyPatientInputEnvelope
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
  }

  export type InvestigationCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvestigationCreateWithoutPatientInput, InvestigationUncheckedCreateWithoutPatientInput> | InvestigationCreateWithoutPatientInput[] | InvestigationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutPatientInput | InvestigationCreateOrConnectWithoutPatientInput[]
    createMany?: InvestigationCreateManyPatientInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type SpecialistNoteCreateNestedManyWithoutPatientInput = {
    create?: XOR<SpecialistNoteCreateWithoutPatientInput, SpecialistNoteUncheckedCreateWithoutPatientInput> | SpecialistNoteCreateWithoutPatientInput[] | SpecialistNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutPatientInput | SpecialistNoteCreateOrConnectWithoutPatientInput[]
    createMany?: SpecialistNoteCreateManyPatientInputEnvelope
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type VitalSignUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
  }

  export type MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationAdministrationCreateWithoutPatientInput, MedicationAdministrationUncheckedCreateWithoutPatientInput> | MedicationAdministrationCreateWithoutPatientInput[] | MedicationAdministrationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutPatientInput | MedicationAdministrationCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationAdministrationCreateManyPatientInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type MedicationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type IntakeOutputUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<IntakeOutputCreateWithoutPatientInput, IntakeOutputUncheckedCreateWithoutPatientInput> | IntakeOutputCreateWithoutPatientInput[] | IntakeOutputUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutPatientInput | IntakeOutputCreateOrConnectWithoutPatientInput[]
    createMany?: IntakeOutputCreateManyPatientInputEnvelope
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
  }

  export type NurseCheckInUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<NurseCheckInCreateWithoutPatientInput, NurseCheckInUncheckedCreateWithoutPatientInput> | NurseCheckInCreateWithoutPatientInput[] | NurseCheckInUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutPatientInput | NurseCheckInCreateOrConnectWithoutPatientInput[]
    createMany?: NurseCheckInCreateManyPatientInputEnvelope
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
  }

  export type ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalOrderCreateWithoutPatientInput, ClinicalOrderUncheckedCreateWithoutPatientInput> | ClinicalOrderCreateWithoutPatientInput[] | ClinicalOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutPatientInput | ClinicalOrderCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalOrderCreateManyPatientInputEnvelope
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
  }

  export type InvestigationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvestigationCreateWithoutPatientInput, InvestigationUncheckedCreateWithoutPatientInput> | InvestigationCreateWithoutPatientInput[] | InvestigationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutPatientInput | InvestigationCreateOrConnectWithoutPatientInput[]
    createMany?: InvestigationCreateManyPatientInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<SpecialistNoteCreateWithoutPatientInput, SpecialistNoteUncheckedCreateWithoutPatientInput> | SpecialistNoteCreateWithoutPatientInput[] | SpecialistNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutPatientInput | SpecialistNoteCreateOrConnectWithoutPatientInput[]
    createMany?: SpecialistNoteCreateManyPatientInputEnvelope
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
  }

  export type PatientUpdatecomorbiditiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AdmissionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ClinicalNoteUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput | ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput | ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutPatientInput | ClinicalNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type VitalSignUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutPatientInput | VitalSignUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutPatientInput | VitalSignUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutPatientInput | VitalSignUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type MedicationAdministrationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutPatientInput, MedicationAdministrationUncheckedCreateWithoutPatientInput> | MedicationAdministrationCreateWithoutPatientInput[] | MedicationAdministrationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutPatientInput | MedicationAdministrationCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutPatientInput | MedicationAdministrationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationAdministrationCreateManyPatientInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutPatientInput | MedicationAdministrationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutPatientInput | MedicationAdministrationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type MedicationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPatientInput | MedicationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPatientInput | MedicationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPatientInput | MedicationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type IntakeOutputUpdateManyWithoutPatientNestedInput = {
    create?: XOR<IntakeOutputCreateWithoutPatientInput, IntakeOutputUncheckedCreateWithoutPatientInput> | IntakeOutputCreateWithoutPatientInput[] | IntakeOutputUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutPatientInput | IntakeOutputCreateOrConnectWithoutPatientInput[]
    upsert?: IntakeOutputUpsertWithWhereUniqueWithoutPatientInput | IntakeOutputUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: IntakeOutputCreateManyPatientInputEnvelope
    set?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    disconnect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    delete?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    update?: IntakeOutputUpdateWithWhereUniqueWithoutPatientInput | IntakeOutputUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: IntakeOutputUpdateManyWithWhereWithoutPatientInput | IntakeOutputUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
  }

  export type NurseCheckInUpdateManyWithoutPatientNestedInput = {
    create?: XOR<NurseCheckInCreateWithoutPatientInput, NurseCheckInUncheckedCreateWithoutPatientInput> | NurseCheckInCreateWithoutPatientInput[] | NurseCheckInUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutPatientInput | NurseCheckInCreateOrConnectWithoutPatientInput[]
    upsert?: NurseCheckInUpsertWithWhereUniqueWithoutPatientInput | NurseCheckInUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: NurseCheckInCreateManyPatientInputEnvelope
    set?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    disconnect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    delete?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    update?: NurseCheckInUpdateWithWhereUniqueWithoutPatientInput | NurseCheckInUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: NurseCheckInUpdateManyWithWhereWithoutPatientInput | NurseCheckInUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
  }

  export type ClinicalOrderUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalOrderCreateWithoutPatientInput, ClinicalOrderUncheckedCreateWithoutPatientInput> | ClinicalOrderCreateWithoutPatientInput[] | ClinicalOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutPatientInput | ClinicalOrderCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalOrderUpsertWithWhereUniqueWithoutPatientInput | ClinicalOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalOrderCreateManyPatientInputEnvelope
    set?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    disconnect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    delete?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    update?: ClinicalOrderUpdateWithWhereUniqueWithoutPatientInput | ClinicalOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalOrderUpdateManyWithWhereWithoutPatientInput | ClinicalOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
  }

  export type InvestigationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvestigationCreateWithoutPatientInput, InvestigationUncheckedCreateWithoutPatientInput> | InvestigationCreateWithoutPatientInput[] | InvestigationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutPatientInput | InvestigationCreateOrConnectWithoutPatientInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutPatientInput | InvestigationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvestigationCreateManyPatientInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutPatientInput | InvestigationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutPatientInput | InvestigationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type SpecialistNoteUpdateManyWithoutPatientNestedInput = {
    create?: XOR<SpecialistNoteCreateWithoutPatientInput, SpecialistNoteUncheckedCreateWithoutPatientInput> | SpecialistNoteCreateWithoutPatientInput[] | SpecialistNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutPatientInput | SpecialistNoteCreateOrConnectWithoutPatientInput[]
    upsert?: SpecialistNoteUpsertWithWhereUniqueWithoutPatientInput | SpecialistNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: SpecialistNoteCreateManyPatientInputEnvelope
    set?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    disconnect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    delete?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    update?: SpecialistNoteUpdateWithWhereUniqueWithoutPatientInput | SpecialistNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: SpecialistNoteUpdateManyWithWhereWithoutPatientInput | SpecialistNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: SpecialistNoteScalarWhereInput | SpecialistNoteScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput | ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput | ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutPatientInput | ClinicalNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type VitalSignUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput> | VitalSignCreateWithoutPatientInput[] | VitalSignUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VitalSignCreateOrConnectWithoutPatientInput | VitalSignCreateOrConnectWithoutPatientInput[]
    upsert?: VitalSignUpsertWithWhereUniqueWithoutPatientInput | VitalSignUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VitalSignCreateManyPatientInputEnvelope
    set?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    disconnect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    delete?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    connect?: VitalSignWhereUniqueInput | VitalSignWhereUniqueInput[]
    update?: VitalSignUpdateWithWhereUniqueWithoutPatientInput | VitalSignUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VitalSignUpdateManyWithWhereWithoutPatientInput | VitalSignUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutPatientInput, MedicationAdministrationUncheckedCreateWithoutPatientInput> | MedicationAdministrationCreateWithoutPatientInput[] | MedicationAdministrationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutPatientInput | MedicationAdministrationCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutPatientInput | MedicationAdministrationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationAdministrationCreateManyPatientInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutPatientInput | MedicationAdministrationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutPatientInput | MedicationAdministrationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type MedicationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput> | MedicationCreateWithoutPatientInput[] | MedicationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutPatientInput | MedicationCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutPatientInput | MedicationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationCreateManyPatientInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutPatientInput | MedicationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutPatientInput | MedicationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<IntakeOutputCreateWithoutPatientInput, IntakeOutputUncheckedCreateWithoutPatientInput> | IntakeOutputCreateWithoutPatientInput[] | IntakeOutputUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: IntakeOutputCreateOrConnectWithoutPatientInput | IntakeOutputCreateOrConnectWithoutPatientInput[]
    upsert?: IntakeOutputUpsertWithWhereUniqueWithoutPatientInput | IntakeOutputUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: IntakeOutputCreateManyPatientInputEnvelope
    set?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    disconnect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    delete?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    connect?: IntakeOutputWhereUniqueInput | IntakeOutputWhereUniqueInput[]
    update?: IntakeOutputUpdateWithWhereUniqueWithoutPatientInput | IntakeOutputUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: IntakeOutputUpdateManyWithWhereWithoutPatientInput | IntakeOutputUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
  }

  export type NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<NurseCheckInCreateWithoutPatientInput, NurseCheckInUncheckedCreateWithoutPatientInput> | NurseCheckInCreateWithoutPatientInput[] | NurseCheckInUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: NurseCheckInCreateOrConnectWithoutPatientInput | NurseCheckInCreateOrConnectWithoutPatientInput[]
    upsert?: NurseCheckInUpsertWithWhereUniqueWithoutPatientInput | NurseCheckInUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: NurseCheckInCreateManyPatientInputEnvelope
    set?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    disconnect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    delete?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    connect?: NurseCheckInWhereUniqueInput | NurseCheckInWhereUniqueInput[]
    update?: NurseCheckInUpdateWithWhereUniqueWithoutPatientInput | NurseCheckInUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: NurseCheckInUpdateManyWithWhereWithoutPatientInput | NurseCheckInUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
  }

  export type ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalOrderCreateWithoutPatientInput, ClinicalOrderUncheckedCreateWithoutPatientInput> | ClinicalOrderCreateWithoutPatientInput[] | ClinicalOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutPatientInput | ClinicalOrderCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalOrderUpsertWithWhereUniqueWithoutPatientInput | ClinicalOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalOrderCreateManyPatientInputEnvelope
    set?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    disconnect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    delete?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    connect?: ClinicalOrderWhereUniqueInput | ClinicalOrderWhereUniqueInput[]
    update?: ClinicalOrderUpdateWithWhereUniqueWithoutPatientInput | ClinicalOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalOrderUpdateManyWithWhereWithoutPatientInput | ClinicalOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
  }

  export type InvestigationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvestigationCreateWithoutPatientInput, InvestigationUncheckedCreateWithoutPatientInput> | InvestigationCreateWithoutPatientInput[] | InvestigationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutPatientInput | InvestigationCreateOrConnectWithoutPatientInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutPatientInput | InvestigationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvestigationCreateManyPatientInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutPatientInput | InvestigationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutPatientInput | InvestigationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<SpecialistNoteCreateWithoutPatientInput, SpecialistNoteUncheckedCreateWithoutPatientInput> | SpecialistNoteCreateWithoutPatientInput[] | SpecialistNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: SpecialistNoteCreateOrConnectWithoutPatientInput | SpecialistNoteCreateOrConnectWithoutPatientInput[]
    upsert?: SpecialistNoteUpsertWithWhereUniqueWithoutPatientInput | SpecialistNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: SpecialistNoteCreateManyPatientInputEnvelope
    set?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    disconnect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    delete?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    connect?: SpecialistNoteWhereUniqueInput | SpecialistNoteWhereUniqueInput[]
    update?: SpecialistNoteUpdateWithWhereUniqueWithoutPatientInput | SpecialistNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: SpecialistNoteUpdateManyWithWhereWithoutPatientInput | SpecialistNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: SpecialistNoteScalarWhereInput | SpecialistNoteScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutAdmissionsNestedInput = {
    create?: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionsInput
    upsert?: PatientUpsertWithoutAdmissionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAdmissionsInput, PatientUpdateWithoutAdmissionsInput>, PatientUncheckedUpdateWithoutAdmissionsInput>
  }

  export type PatientCreateNestedOneWithoutNotesInput = {
    create?: XOR<PatientCreateWithoutNotesInput, PatientUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutNotesInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.NoteType
  }

  export type PatientUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<PatientCreateWithoutNotesInput, PatientUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutNotesInput
    upsert?: PatientUpsertWithoutNotesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutNotesInput, PatientUpdateWithoutNotesInput>, PatientUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserCreateNestedOneWithoutAuditsInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditsInput
    upsert?: UserUpsertWithoutAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditsInput, UserUpdateWithoutAuditsInput>, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type PatientCreateNestedOneWithoutVitalsInput = {
    create?: XOR<PatientCreateWithoutVitalsInput, PatientUncheckedCreateWithoutVitalsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVitalsInput
    connect?: PatientWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientUpdateOneRequiredWithoutVitalsNestedInput = {
    create?: XOR<PatientCreateWithoutVitalsInput, PatientUncheckedCreateWithoutVitalsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVitalsInput
    upsert?: PatientUpsertWithoutVitalsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutVitalsInput, PatientUpdateWithoutVitalsInput>, PatientUncheckedUpdateWithoutVitalsInput>
  }

  export type PatientCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicationAdministrationCreateNestedManyWithoutMedicationInput = {
    create?: XOR<MedicationAdministrationCreateWithoutMedicationInput, MedicationAdministrationUncheckedCreateWithoutMedicationInput> | MedicationAdministrationCreateWithoutMedicationInput[] | MedicationAdministrationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutMedicationInput | MedicationAdministrationCreateOrConnectWithoutMedicationInput[]
    createMany?: MedicationAdministrationCreateManyMedicationInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type MedicationAdministrationUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<MedicationAdministrationCreateWithoutMedicationInput, MedicationAdministrationUncheckedCreateWithoutMedicationInput> | MedicationAdministrationCreateWithoutMedicationInput[] | MedicationAdministrationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutMedicationInput | MedicationAdministrationCreateOrConnectWithoutMedicationInput[]
    createMany?: MedicationAdministrationCreateManyMedicationInputEnvelope
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
  }

  export type PatientUpdateOneWithoutPrescriptionsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    upsert?: PatientUpsertWithoutPrescriptionsInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionsInput, PatientUpdateWithoutPrescriptionsInput>, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type MedicationAdministrationUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutMedicationInput, MedicationAdministrationUncheckedCreateWithoutMedicationInput> | MedicationAdministrationCreateWithoutMedicationInput[] | MedicationAdministrationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutMedicationInput | MedicationAdministrationCreateOrConnectWithoutMedicationInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutMedicationInput | MedicationAdministrationUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: MedicationAdministrationCreateManyMedicationInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutMedicationInput | MedicationAdministrationUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutMedicationInput | MedicationAdministrationUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<MedicationAdministrationCreateWithoutMedicationInput, MedicationAdministrationUncheckedCreateWithoutMedicationInput> | MedicationAdministrationCreateWithoutMedicationInput[] | MedicationAdministrationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicationAdministrationCreateOrConnectWithoutMedicationInput | MedicationAdministrationCreateOrConnectWithoutMedicationInput[]
    upsert?: MedicationAdministrationUpsertWithWhereUniqueWithoutMedicationInput | MedicationAdministrationUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: MedicationAdministrationCreateManyMedicationInputEnvelope
    set?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    disconnect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    delete?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    connect?: MedicationAdministrationWhereUniqueInput | MedicationAdministrationWhereUniqueInput[]
    update?: MedicationAdministrationUpdateWithWhereUniqueWithoutMedicationInput | MedicationAdministrationUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: MedicationAdministrationUpdateManyWithWhereWithoutMedicationInput | MedicationAdministrationUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationsInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicationCreateNestedOneWithoutAdministrationsInput = {
    create?: XOR<MedicationCreateWithoutAdministrationsInput, MedicationUncheckedCreateWithoutAdministrationsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutAdministrationsInput
    connect?: MedicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdministeredMedsInput = {
    create?: XOR<UserCreateWithoutAdministeredMedsInput, UserUncheckedCreateWithoutAdministeredMedsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdministeredMedsInput
    connect?: UserWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationsInput
    upsert?: PatientUpsertWithoutMedicationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicationsInput, PatientUpdateWithoutMedicationsInput>, PatientUncheckedUpdateWithoutMedicationsInput>
  }

  export type MedicationUpdateOneRequiredWithoutAdministrationsNestedInput = {
    create?: XOR<MedicationCreateWithoutAdministrationsInput, MedicationUncheckedCreateWithoutAdministrationsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutAdministrationsInput
    upsert?: MedicationUpsertWithoutAdministrationsInput
    connect?: MedicationWhereUniqueInput
    update?: XOR<XOR<MedicationUpdateToOneWithWhereWithoutAdministrationsInput, MedicationUpdateWithoutAdministrationsInput>, MedicationUncheckedUpdateWithoutAdministrationsInput>
  }

  export type UserUpdateOneWithoutAdministeredMedsNestedInput = {
    create?: XOR<UserCreateWithoutAdministeredMedsInput, UserUncheckedCreateWithoutAdministeredMedsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdministeredMedsInput
    upsert?: UserUpsertWithoutAdministeredMedsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdministeredMedsInput, UserUpdateWithoutAdministeredMedsInput>, UserUncheckedUpdateWithoutAdministeredMedsInput>
  }

  export type PatientCreateNestedOneWithoutIoEntriesInput = {
    create?: XOR<PatientCreateWithoutIoEntriesInput, PatientUncheckedCreateWithoutIoEntriesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutIoEntriesInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIoEntriesInput = {
    create?: XOR<UserCreateWithoutIoEntriesInput, UserUncheckedCreateWithoutIoEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIoEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutIoEntriesInput = {
    create?: XOR<ShiftCreateWithoutIoEntriesInput, ShiftUncheckedCreateWithoutIoEntriesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutIoEntriesInput
    connect?: ShiftWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientUpdateOneRequiredWithoutIoEntriesNestedInput = {
    create?: XOR<PatientCreateWithoutIoEntriesInput, PatientUncheckedCreateWithoutIoEntriesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutIoEntriesInput
    upsert?: PatientUpsertWithoutIoEntriesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutIoEntriesInput, PatientUpdateWithoutIoEntriesInput>, PatientUncheckedUpdateWithoutIoEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutIoEntriesNestedInput = {
    create?: XOR<UserCreateWithoutIoEntriesInput, UserUncheckedCreateWithoutIoEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIoEntriesInput
    upsert?: UserUpsertWithoutIoEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIoEntriesInput, UserUpdateWithoutIoEntriesInput>, UserUncheckedUpdateWithoutIoEntriesInput>
  }

  export type ShiftUpdateOneWithoutIoEntriesNestedInput = {
    create?: XOR<ShiftCreateWithoutIoEntriesInput, ShiftUncheckedCreateWithoutIoEntriesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutIoEntriesInput
    upsert?: ShiftUpsertWithoutIoEntriesInput
    disconnect?: ShiftWhereInput | boolean
    delete?: ShiftWhereInput | boolean
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutIoEntriesInput, ShiftUpdateWithoutIoEntriesInput>, ShiftUncheckedUpdateWithoutIoEntriesInput>
  }

  export type PatientCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<PatientCreateWithoutCheckInsInput, PatientUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCheckInsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckInsInput
    connect?: UserWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<ShiftCreateWithoutCheckInsInput, ShiftUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutCheckInsInput
    connect?: ShiftWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutCheckInsNestedInput = {
    create?: XOR<PatientCreateWithoutCheckInsInput, PatientUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutCheckInsInput
    upsert?: PatientUpsertWithoutCheckInsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutCheckInsInput, PatientUpdateWithoutCheckInsInput>, PatientUncheckedUpdateWithoutCheckInsInput>
  }

  export type UserUpdateOneRequiredWithoutCheckInsNestedInput = {
    create?: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckInsInput
    upsert?: UserUpsertWithoutCheckInsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCheckInsInput, UserUpdateWithoutCheckInsInput>, UserUncheckedUpdateWithoutCheckInsInput>
  }

  export type ShiftUpdateOneWithoutCheckInsNestedInput = {
    create?: XOR<ShiftCreateWithoutCheckInsInput, ShiftUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutCheckInsInput
    upsert?: ShiftUpsertWithoutCheckInsInput
    disconnect?: ShiftWhereInput | boolean
    delete?: ShiftWhereInput | boolean
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutCheckInsInput, ShiftUpdateWithoutCheckInsInput>, ShiftUncheckedUpdateWithoutCheckInsInput>
  }

  export type PatientCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PatientCreateWithoutOrdersInput, PatientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutOrdersInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedOrdersInput = {
    create?: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedOrdersInput = {
    create?: XOR<UserCreateWithoutApprovedOrdersInput, UserUncheckedCreateWithoutApprovedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type InvestigationCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvestigationCreateWithoutOrderInput, InvestigationUncheckedCreateWithoutOrderInput> | InvestigationCreateWithoutOrderInput[] | InvestigationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutOrderInput | InvestigationCreateOrConnectWithoutOrderInput[]
    createMany?: InvestigationCreateManyOrderInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type InvestigationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvestigationCreateWithoutOrderInput, InvestigationUncheckedCreateWithoutOrderInput> | InvestigationCreateWithoutOrderInput[] | InvestigationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutOrderInput | InvestigationCreateOrConnectWithoutOrderInput[]
    createMany?: InvestigationCreateManyOrderInputEnvelope
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
  }

  export type EnumOrderTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderType
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type PatientUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<PatientCreateWithoutOrdersInput, PatientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutOrdersInput
    upsert?: PatientUpsertWithoutOrdersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutOrdersInput, PatientUpdateWithoutOrdersInput>, PatientUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedOrdersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedOrdersInput
    upsert?: UserUpsertWithoutCreatedOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedOrdersInput, UserUpdateWithoutCreatedOrdersInput>, UserUncheckedUpdateWithoutCreatedOrdersInput>
  }

  export type UserUpdateOneWithoutApprovedOrdersNestedInput = {
    create?: XOR<UserCreateWithoutApprovedOrdersInput, UserUncheckedCreateWithoutApprovedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedOrdersInput
    upsert?: UserUpsertWithoutApprovedOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedOrdersInput, UserUpdateWithoutApprovedOrdersInput>, UserUncheckedUpdateWithoutApprovedOrdersInput>
  }

  export type InvestigationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvestigationCreateWithoutOrderInput, InvestigationUncheckedCreateWithoutOrderInput> | InvestigationCreateWithoutOrderInput[] | InvestigationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutOrderInput | InvestigationCreateOrConnectWithoutOrderInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutOrderInput | InvestigationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvestigationCreateManyOrderInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutOrderInput | InvestigationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutOrderInput | InvestigationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type InvestigationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvestigationCreateWithoutOrderInput, InvestigationUncheckedCreateWithoutOrderInput> | InvestigationCreateWithoutOrderInput[] | InvestigationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvestigationCreateOrConnectWithoutOrderInput | InvestigationCreateOrConnectWithoutOrderInput[]
    upsert?: InvestigationUpsertWithWhereUniqueWithoutOrderInput | InvestigationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvestigationCreateManyOrderInputEnvelope
    set?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    disconnect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    delete?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    connect?: InvestigationWhereUniqueInput | InvestigationWhereUniqueInput[]
    update?: InvestigationUpdateWithWhereUniqueWithoutOrderInput | InvestigationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvestigationUpdateManyWithWhereWithoutOrderInput | InvestigationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutSpecialistNotesInput = {
    create?: XOR<PatientCreateWithoutSpecialistNotesInput, PatientUncheckedCreateWithoutSpecialistNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSpecialistNotesInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSpecialistNotesInput = {
    create?: XOR<UserCreateWithoutSpecialistNotesInput, UserUncheckedCreateWithoutSpecialistNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialistNotesInput
    connect?: UserWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutSpecialistNotesNestedInput = {
    create?: XOR<PatientCreateWithoutSpecialistNotesInput, PatientUncheckedCreateWithoutSpecialistNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSpecialistNotesInput
    upsert?: PatientUpsertWithoutSpecialistNotesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutSpecialistNotesInput, PatientUpdateWithoutSpecialistNotesInput>, PatientUncheckedUpdateWithoutSpecialistNotesInput>
  }

  export type UserUpdateOneRequiredWithoutSpecialistNotesNestedInput = {
    create?: XOR<UserCreateWithoutSpecialistNotesInput, UserUncheckedCreateWithoutSpecialistNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialistNotesInput
    upsert?: UserUpsertWithoutSpecialistNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpecialistNotesInput, UserUpdateWithoutSpecialistNotesInput>, UserUncheckedUpdateWithoutSpecialistNotesInput>
  }

  export type PatientCreateNestedOneWithoutInvestigationsInput = {
    create?: XOR<PatientCreateWithoutInvestigationsInput, PatientUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvestigationsInput
    connect?: PatientWhereUniqueInput
  }

  export type ClinicalOrderCreateNestedOneWithoutInvestigationsInput = {
    create?: XOR<ClinicalOrderCreateWithoutInvestigationsInput, ClinicalOrderUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutInvestigationsInput
    connect?: ClinicalOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvestigationsInput = {
    create?: XOR<UserCreateWithoutInvestigationsInput, UserUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestigationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInvestigationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvestigationStatus
  }

  export type PatientUpdateOneRequiredWithoutInvestigationsNestedInput = {
    create?: XOR<PatientCreateWithoutInvestigationsInput, PatientUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvestigationsInput
    upsert?: PatientUpsertWithoutInvestigationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvestigationsInput, PatientUpdateWithoutInvestigationsInput>, PatientUncheckedUpdateWithoutInvestigationsInput>
  }

  export type ClinicalOrderUpdateOneWithoutInvestigationsNestedInput = {
    create?: XOR<ClinicalOrderCreateWithoutInvestigationsInput, ClinicalOrderUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: ClinicalOrderCreateOrConnectWithoutInvestigationsInput
    upsert?: ClinicalOrderUpsertWithoutInvestigationsInput
    disconnect?: ClinicalOrderWhereInput | boolean
    delete?: ClinicalOrderWhereInput | boolean
    connect?: ClinicalOrderWhereUniqueInput
    update?: XOR<XOR<ClinicalOrderUpdateToOneWithWhereWithoutInvestigationsInput, ClinicalOrderUpdateWithoutInvestigationsInput>, ClinicalOrderUncheckedUpdateWithoutInvestigationsInput>
  }

  export type UserUpdateOneRequiredWithoutInvestigationsNestedInput = {
    create?: XOR<UserCreateWithoutInvestigationsInput, UserUncheckedCreateWithoutInvestigationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestigationsInput
    upsert?: UserUpsertWithoutInvestigationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestigationsInput, UserUpdateWithoutInvestigationsInput>, UserUncheckedUpdateWithoutInvestigationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumShiftTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftType | EnumShiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftTypeFilter<$PrismaModel> | $Enums.ShiftType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumShiftTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftType | EnumShiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftType[] | ListEnumShiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShiftType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftTypeFilter<$PrismaModel>
    _max?: NestedEnumShiftTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumInvestigationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestigationStatus | EnumInvestigationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestigationStatusFilter<$PrismaModel> | $Enums.InvestigationStatus
  }

  export type NestedEnumInvestigationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestigationStatus | EnumInvestigationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestigationStatus[] | ListEnumInvestigationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestigationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestigationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestigationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestigationStatusFilter<$PrismaModel>
  }

  export type ShiftCreateWithoutUserInput = {
    id?: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    ioEntries?: IntakeOutputCreateNestedManyWithoutShiftInput
    checkIns?: NurseCheckInCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutShiftInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutUserInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput>
  }

  export type ShiftCreateManyUserInputEnvelope = {
    data: ShiftCreateManyUserInput | ShiftCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalNoteCreateWithoutAuthorInput = {
    id?: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutNotesInput
  }

  export type ClinicalNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    patientId: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalNoteCreateOrConnectWithoutAuthorInput = {
    where: ClinicalNoteWhereUniqueInput
    create: XOR<ClinicalNoteCreateWithoutAuthorInput, ClinicalNoteUncheckedCreateWithoutAuthorInput>
  }

  export type ClinicalNoteCreateManyAuthorInputEnvelope = {
    data: ClinicalNoteCreateManyAuthorInput | ClinicalNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    details?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    details?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IntakeOutputCreateWithoutUserInput = {
    id?: string
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutIoEntriesInput
    shift?: ShiftCreateNestedOneWithoutIoEntriesInput
  }

  export type IntakeOutputUncheckedCreateWithoutUserInput = {
    id?: string
    patientId: string
    shiftId?: string | null
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type IntakeOutputCreateOrConnectWithoutUserInput = {
    where: IntakeOutputWhereUniqueInput
    create: XOR<IntakeOutputCreateWithoutUserInput, IntakeOutputUncheckedCreateWithoutUserInput>
  }

  export type IntakeOutputCreateManyUserInputEnvelope = {
    data: IntakeOutputCreateManyUserInput | IntakeOutputCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NurseCheckInCreateWithoutUserInput = {
    id?: string
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutCheckInsInput
    shift?: ShiftCreateNestedOneWithoutCheckInsInput
  }

  export type NurseCheckInUncheckedCreateWithoutUserInput = {
    id?: string
    patientId: string
    shiftId?: string | null
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInCreateOrConnectWithoutUserInput = {
    where: NurseCheckInWhereUniqueInput
    create: XOR<NurseCheckInCreateWithoutUserInput, NurseCheckInUncheckedCreateWithoutUserInput>
  }

  export type NurseCheckInCreateManyUserInputEnvelope = {
    data: NurseCheckInCreateManyUserInput | NurseCheckInCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalOrderCreateWithoutAuthorInput = {
    id?: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutOrdersInput
    approver?: UserCreateNestedOneWithoutApprovedOrdersInput
    investigations?: InvestigationCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderUncheckedCreateWithoutAuthorInput = {
    id?: string
    patientId: string
    approverId?: string | null
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investigations?: InvestigationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderCreateOrConnectWithoutAuthorInput = {
    where: ClinicalOrderWhereUniqueInput
    create: XOR<ClinicalOrderCreateWithoutAuthorInput, ClinicalOrderUncheckedCreateWithoutAuthorInput>
  }

  export type ClinicalOrderCreateManyAuthorInputEnvelope = {
    data: ClinicalOrderCreateManyAuthorInput | ClinicalOrderCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalOrderCreateWithoutApproverInput = {
    id?: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutOrdersInput
    author: UserCreateNestedOneWithoutCreatedOrdersInput
    investigations?: InvestigationCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderUncheckedCreateWithoutApproverInput = {
    id?: string
    patientId: string
    authorId: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investigations?: InvestigationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderCreateOrConnectWithoutApproverInput = {
    where: ClinicalOrderWhereUniqueInput
    create: XOR<ClinicalOrderCreateWithoutApproverInput, ClinicalOrderUncheckedCreateWithoutApproverInput>
  }

  export type ClinicalOrderCreateManyApproverInputEnvelope = {
    data: ClinicalOrderCreateManyApproverInput | ClinicalOrderCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type InvestigationCreateWithoutAuthorInput = {
    id?: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvestigationsInput
    order?: ClinicalOrderCreateNestedOneWithoutInvestigationsInput
  }

  export type InvestigationUncheckedCreateWithoutAuthorInput = {
    id?: string
    patientId: string
    orderId?: string | null
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type InvestigationCreateOrConnectWithoutAuthorInput = {
    where: InvestigationWhereUniqueInput
    create: XOR<InvestigationCreateWithoutAuthorInput, InvestigationUncheckedCreateWithoutAuthorInput>
  }

  export type InvestigationCreateManyAuthorInputEnvelope = {
    data: InvestigationCreateManyAuthorInput | InvestigationCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SpecialistNoteCreateWithoutAuthorInput = {
    id?: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutSpecialistNotesInput
  }

  export type SpecialistNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    patientId: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialistNoteCreateOrConnectWithoutAuthorInput = {
    where: SpecialistNoteWhereUniqueInput
    create: XOR<SpecialistNoteCreateWithoutAuthorInput, SpecialistNoteUncheckedCreateWithoutAuthorInput>
  }

  export type SpecialistNoteCreateManyAuthorInputEnvelope = {
    data: SpecialistNoteCreateManyAuthorInput | SpecialistNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type MedicationAdministrationCreateWithoutUserInput = {
    id?: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutMedicationsInput
    medication: MedicationCreateNestedOneWithoutAdministrationsInput
  }

  export type MedicationAdministrationUncheckedCreateWithoutUserInput = {
    id?: string
    patientId: string
    medicationId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
  }

  export type MedicationAdministrationCreateOrConnectWithoutUserInput = {
    where: MedicationAdministrationWhereUniqueInput
    create: XOR<MedicationAdministrationCreateWithoutUserInput, MedicationAdministrationUncheckedCreateWithoutUserInput>
  }

  export type MedicationAdministrationCreateManyUserInputEnvelope = {
    data: MedicationAdministrationCreateManyUserInput | MedicationAdministrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUpsertWithWhereUniqueWithoutUserInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutUserInput, ShiftUncheckedUpdateWithoutUserInput>
    create: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutUserInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutUserInput, ShiftUncheckedUpdateWithoutUserInput>
  }

  export type ShiftUpdateManyWithWhereWithoutUserInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutUserInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: StringFilter<"Shift"> | string
    userId?: StringFilter<"Shift"> | string
    type?: EnumShiftTypeFilter<"Shift"> | $Enums.ShiftType
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeNullableFilter<"Shift"> | Date | string | null
    isActive?: BoolFilter<"Shift"> | boolean
  }

  export type ClinicalNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ClinicalNoteWhereUniqueInput
    update: XOR<ClinicalNoteUpdateWithoutAuthorInput, ClinicalNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<ClinicalNoteCreateWithoutAuthorInput, ClinicalNoteUncheckedCreateWithoutAuthorInput>
  }

  export type ClinicalNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ClinicalNoteWhereUniqueInput
    data: XOR<ClinicalNoteUpdateWithoutAuthorInput, ClinicalNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type ClinicalNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: ClinicalNoteScalarWhereInput
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ClinicalNoteScalarWhereInput = {
    AND?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
    OR?: ClinicalNoteScalarWhereInput[]
    NOT?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
    id?: StringFilter<"ClinicalNote"> | string
    patientId?: StringFilter<"ClinicalNote"> | string
    authorId?: StringFilter<"ClinicalNote"> | string
    type?: EnumNoteTypeFilter<"ClinicalNote"> | $Enums.NoteType
    title?: StringFilter<"ClinicalNote"> | string
    content?: StringFilter<"ClinicalNote"> | string
    data?: JsonNullableFilter<"ClinicalNote">
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalNote"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type IntakeOutputUpsertWithWhereUniqueWithoutUserInput = {
    where: IntakeOutputWhereUniqueInput
    update: XOR<IntakeOutputUpdateWithoutUserInput, IntakeOutputUncheckedUpdateWithoutUserInput>
    create: XOR<IntakeOutputCreateWithoutUserInput, IntakeOutputUncheckedCreateWithoutUserInput>
  }

  export type IntakeOutputUpdateWithWhereUniqueWithoutUserInput = {
    where: IntakeOutputWhereUniqueInput
    data: XOR<IntakeOutputUpdateWithoutUserInput, IntakeOutputUncheckedUpdateWithoutUserInput>
  }

  export type IntakeOutputUpdateManyWithWhereWithoutUserInput = {
    where: IntakeOutputScalarWhereInput
    data: XOR<IntakeOutputUpdateManyMutationInput, IntakeOutputUncheckedUpdateManyWithoutUserInput>
  }

  export type IntakeOutputScalarWhereInput = {
    AND?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
    OR?: IntakeOutputScalarWhereInput[]
    NOT?: IntakeOutputScalarWhereInput | IntakeOutputScalarWhereInput[]
    id?: StringFilter<"IntakeOutput"> | string
    patientId?: StringFilter<"IntakeOutput"> | string
    userId?: StringFilter<"IntakeOutput"> | string
    shiftId?: StringNullableFilter<"IntakeOutput"> | string | null
    type?: StringFilter<"IntakeOutput"> | string
    category?: StringFilter<"IntakeOutput"> | string
    amount?: FloatFilter<"IntakeOutput"> | number
    notes?: StringNullableFilter<"IntakeOutput"> | string | null
    timestamp?: DateTimeFilter<"IntakeOutput"> | Date | string
  }

  export type NurseCheckInUpsertWithWhereUniqueWithoutUserInput = {
    where: NurseCheckInWhereUniqueInput
    update: XOR<NurseCheckInUpdateWithoutUserInput, NurseCheckInUncheckedUpdateWithoutUserInput>
    create: XOR<NurseCheckInCreateWithoutUserInput, NurseCheckInUncheckedCreateWithoutUserInput>
  }

  export type NurseCheckInUpdateWithWhereUniqueWithoutUserInput = {
    where: NurseCheckInWhereUniqueInput
    data: XOR<NurseCheckInUpdateWithoutUserInput, NurseCheckInUncheckedUpdateWithoutUserInput>
  }

  export type NurseCheckInUpdateManyWithWhereWithoutUserInput = {
    where: NurseCheckInScalarWhereInput
    data: XOR<NurseCheckInUpdateManyMutationInput, NurseCheckInUncheckedUpdateManyWithoutUserInput>
  }

  export type NurseCheckInScalarWhereInput = {
    AND?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
    OR?: NurseCheckInScalarWhereInput[]
    NOT?: NurseCheckInScalarWhereInput | NurseCheckInScalarWhereInput[]
    id?: StringFilter<"NurseCheckIn"> | string
    patientId?: StringFilter<"NurseCheckIn"> | string
    userId?: StringFilter<"NurseCheckIn"> | string
    shiftId?: StringNullableFilter<"NurseCheckIn"> | string | null
    airwaySafe?: BoolFilter<"NurseCheckIn"> | boolean
    breathingOk?: BoolFilter<"NurseCheckIn"> | boolean
    circulationOk?: BoolFilter<"NurseCheckIn"> | boolean
    notes?: StringNullableFilter<"NurseCheckIn"> | string | null
    timestamp?: DateTimeFilter<"NurseCheckIn"> | Date | string
  }

  export type ClinicalOrderUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ClinicalOrderWhereUniqueInput
    update: XOR<ClinicalOrderUpdateWithoutAuthorInput, ClinicalOrderUncheckedUpdateWithoutAuthorInput>
    create: XOR<ClinicalOrderCreateWithoutAuthorInput, ClinicalOrderUncheckedCreateWithoutAuthorInput>
  }

  export type ClinicalOrderUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ClinicalOrderWhereUniqueInput
    data: XOR<ClinicalOrderUpdateWithoutAuthorInput, ClinicalOrderUncheckedUpdateWithoutAuthorInput>
  }

  export type ClinicalOrderUpdateManyWithWhereWithoutAuthorInput = {
    where: ClinicalOrderScalarWhereInput
    data: XOR<ClinicalOrderUpdateManyMutationInput, ClinicalOrderUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ClinicalOrderScalarWhereInput = {
    AND?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
    OR?: ClinicalOrderScalarWhereInput[]
    NOT?: ClinicalOrderScalarWhereInput | ClinicalOrderScalarWhereInput[]
    id?: StringFilter<"ClinicalOrder"> | string
    patientId?: StringFilter<"ClinicalOrder"> | string
    authorId?: StringFilter<"ClinicalOrder"> | string
    approverId?: StringNullableFilter<"ClinicalOrder"> | string | null
    type?: EnumOrderTypeFilter<"ClinicalOrder"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"ClinicalOrder"> | $Enums.OrderStatus
    priority?: EnumPriorityFilter<"ClinicalOrder"> | $Enums.Priority
    title?: StringFilter<"ClinicalOrder"> | string
    details?: JsonNullableFilter<"ClinicalOrder">
    notes?: StringNullableFilter<"ClinicalOrder"> | string | null
    createdAt?: DateTimeFilter<"ClinicalOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalOrder"> | Date | string
  }

  export type ClinicalOrderUpsertWithWhereUniqueWithoutApproverInput = {
    where: ClinicalOrderWhereUniqueInput
    update: XOR<ClinicalOrderUpdateWithoutApproverInput, ClinicalOrderUncheckedUpdateWithoutApproverInput>
    create: XOR<ClinicalOrderCreateWithoutApproverInput, ClinicalOrderUncheckedCreateWithoutApproverInput>
  }

  export type ClinicalOrderUpdateWithWhereUniqueWithoutApproverInput = {
    where: ClinicalOrderWhereUniqueInput
    data: XOR<ClinicalOrderUpdateWithoutApproverInput, ClinicalOrderUncheckedUpdateWithoutApproverInput>
  }

  export type ClinicalOrderUpdateManyWithWhereWithoutApproverInput = {
    where: ClinicalOrderScalarWhereInput
    data: XOR<ClinicalOrderUpdateManyMutationInput, ClinicalOrderUncheckedUpdateManyWithoutApproverInput>
  }

  export type InvestigationUpsertWithWhereUniqueWithoutAuthorInput = {
    where: InvestigationWhereUniqueInput
    update: XOR<InvestigationUpdateWithoutAuthorInput, InvestigationUncheckedUpdateWithoutAuthorInput>
    create: XOR<InvestigationCreateWithoutAuthorInput, InvestigationUncheckedCreateWithoutAuthorInput>
  }

  export type InvestigationUpdateWithWhereUniqueWithoutAuthorInput = {
    where: InvestigationWhereUniqueInput
    data: XOR<InvestigationUpdateWithoutAuthorInput, InvestigationUncheckedUpdateWithoutAuthorInput>
  }

  export type InvestigationUpdateManyWithWhereWithoutAuthorInput = {
    where: InvestigationScalarWhereInput
    data: XOR<InvestigationUpdateManyMutationInput, InvestigationUncheckedUpdateManyWithoutAuthorInput>
  }

  export type InvestigationScalarWhereInput = {
    AND?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
    OR?: InvestigationScalarWhereInput[]
    NOT?: InvestigationScalarWhereInput | InvestigationScalarWhereInput[]
    id?: StringFilter<"Investigation"> | string
    patientId?: StringFilter<"Investigation"> | string
    orderId?: StringNullableFilter<"Investigation"> | string | null
    authorId?: StringFilter<"Investigation"> | string
    type?: EnumOrderTypeFilter<"Investigation"> | $Enums.OrderType
    category?: StringFilter<"Investigation"> | string
    title?: StringFilter<"Investigation"> | string
    status?: EnumInvestigationStatusFilter<"Investigation"> | $Enums.InvestigationStatus
    result?: JsonNullableFilter<"Investigation">
    impression?: StringNullableFilter<"Investigation"> | string | null
    conductedAt?: DateTimeFilter<"Investigation"> | Date | string
    createdAt?: DateTimeFilter<"Investigation"> | Date | string
  }

  export type SpecialistNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: SpecialistNoteWhereUniqueInput
    update: XOR<SpecialistNoteUpdateWithoutAuthorInput, SpecialistNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<SpecialistNoteCreateWithoutAuthorInput, SpecialistNoteUncheckedCreateWithoutAuthorInput>
  }

  export type SpecialistNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: SpecialistNoteWhereUniqueInput
    data: XOR<SpecialistNoteUpdateWithoutAuthorInput, SpecialistNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type SpecialistNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: SpecialistNoteScalarWhereInput
    data: XOR<SpecialistNoteUpdateManyMutationInput, SpecialistNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type SpecialistNoteScalarWhereInput = {
    AND?: SpecialistNoteScalarWhereInput | SpecialistNoteScalarWhereInput[]
    OR?: SpecialistNoteScalarWhereInput[]
    NOT?: SpecialistNoteScalarWhereInput | SpecialistNoteScalarWhereInput[]
    id?: StringFilter<"SpecialistNote"> | string
    patientId?: StringFilter<"SpecialistNote"> | string
    authorId?: StringFilter<"SpecialistNote"> | string
    date?: DateTimeFilter<"SpecialistNote"> | Date | string
    apacheScore?: StringNullableFilter<"SpecialistNote"> | string | null
    histHT?: BoolFilter<"SpecialistNote"> | boolean
    histDM?: BoolFilter<"SpecialistNote"> | boolean
    histAsthma?: BoolFilter<"SpecialistNote"> | boolean
    histCOPD?: BoolFilter<"SpecialistNote"> | boolean
    histIHD?: BoolFilter<"SpecialistNote"> | boolean
    histStroke?: BoolFilter<"SpecialistNote"> | boolean
    histOther?: StringNullableFilter<"SpecialistNote"> | string | null
    neuroGCS?: StringNullableFilter<"SpecialistNote"> | string | null
    neuroRASS?: StringNullableFilter<"SpecialistNote"> | string | null
    respChest?: StringNullableFilter<"SpecialistNote"> | string | null
    respRoomAir?: BoolFilter<"SpecialistNote"> | boolean
    respO2Therapy?: BoolFilter<"SpecialistNote"> | boolean
    respVentMode?: BoolFilter<"SpecialistNote"> | boolean
    respVentModeText?: StringNullableFilter<"SpecialistNote"> | string | null
    respFio2?: StringNullableFilter<"SpecialistNote"> | string | null
    respPS?: StringNullableFilter<"SpecialistNote"> | string | null
    intCVLine?: BoolFilter<"SpecialistNote"> | boolean
    intArtLine?: BoolFilter<"SpecialistNote"> | boolean
    intETT?: BoolFilter<"SpecialistNote"> | boolean
    intTrach?: BoolFilter<"SpecialistNote"> | boolean
    intDoubleLumen?: BoolFilter<"SpecialistNote"> | boolean
    hydNormovolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydHypervolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydHypovolemia?: BoolFilter<"SpecialistNote"> | boolean
    hydUOP?: StringNullableFilter<"SpecialistNote"> | string | null
    hydIVC?: StringNullableFilter<"SpecialistNote"> | string | null
    hydCVP?: StringNullableFilter<"SpecialistNote"> | string | null
    hemoStable?: BoolFilter<"SpecialistNote"> | boolean
    hemoUnstable?: BoolFilter<"SpecialistNote"> | boolean
    hemoVasopressor?: BoolFilter<"SpecialistNote"> | boolean
    feedOral?: BoolFilter<"SpecialistNote"> | boolean
    feedNG?: BoolFilter<"SpecialistNote"> | boolean
    feedTPN?: BoolFilter<"SpecialistNote"> | boolean
    feedRate?: StringNullableFilter<"SpecialistNote"> | string | null
    ivFluidsRate?: StringNullableFilter<"SpecialistNote"> | string | null
    sedPropofol?: BoolFilter<"SpecialistNote"> | boolean
    sedKetamine?: BoolFilter<"SpecialistNote"> | boolean
    sedMidazolam?: BoolFilter<"SpecialistNote"> | boolean
    sedRemif?: BoolFilter<"SpecialistNote"> | boolean
    sedMR?: BoolFilter<"SpecialistNote"> | boolean
    sedOther?: StringNullableFilter<"SpecialistNote"> | string | null
    clinicalNotes?: StringNullableFilter<"SpecialistNote"> | string | null
    planVentilatory?: StringNullableFilter<"SpecialistNote"> | string | null
    planPhysio?: StringNullableFilter<"SpecialistNote"> | string | null
    planConsult?: StringNullableFilter<"SpecialistNote"> | string | null
    planInvestigation?: StringNullableFilter<"SpecialistNote"> | string | null
    planOther?: StringNullableFilter<"SpecialistNote"> | string | null
    planFuture?: StringNullableFilter<"SpecialistNote"> | string | null
    planHomeTeam?: StringNullableFilter<"SpecialistNote"> | string | null
    createdAt?: DateTimeFilter<"SpecialistNote"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialistNote"> | Date | string
  }

  export type MedicationAdministrationUpsertWithWhereUniqueWithoutUserInput = {
    where: MedicationAdministrationWhereUniqueInput
    update: XOR<MedicationAdministrationUpdateWithoutUserInput, MedicationAdministrationUncheckedUpdateWithoutUserInput>
    create: XOR<MedicationAdministrationCreateWithoutUserInput, MedicationAdministrationUncheckedCreateWithoutUserInput>
  }

  export type MedicationAdministrationUpdateWithWhereUniqueWithoutUserInput = {
    where: MedicationAdministrationWhereUniqueInput
    data: XOR<MedicationAdministrationUpdateWithoutUserInput, MedicationAdministrationUncheckedUpdateWithoutUserInput>
  }

  export type MedicationAdministrationUpdateManyWithWhereWithoutUserInput = {
    where: MedicationAdministrationScalarWhereInput
    data: XOR<MedicationAdministrationUpdateManyMutationInput, MedicationAdministrationUncheckedUpdateManyWithoutUserInput>
  }

  export type MedicationAdministrationScalarWhereInput = {
    AND?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
    OR?: MedicationAdministrationScalarWhereInput[]
    NOT?: MedicationAdministrationScalarWhereInput | MedicationAdministrationScalarWhereInput[]
    id?: StringFilter<"MedicationAdministration"> | string
    patientId?: StringFilter<"MedicationAdministration"> | string
    medicationId?: StringFilter<"MedicationAdministration"> | string
    status?: StringFilter<"MedicationAdministration"> | string
    dose?: StringNullableFilter<"MedicationAdministration"> | string | null
    timestamp?: DateTimeFilter<"MedicationAdministration"> | Date | string
    userId?: StringNullableFilter<"MedicationAdministration"> | string | null
  }

  export type UserCreateWithoutShiftsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShiftsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShiftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
  }

  export type IntakeOutputCreateWithoutShiftInput = {
    id?: string
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutIoEntriesInput
    user: UserCreateNestedOneWithoutIoEntriesInput
  }

  export type IntakeOutputUncheckedCreateWithoutShiftInput = {
    id?: string
    patientId: string
    userId: string
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type IntakeOutputCreateOrConnectWithoutShiftInput = {
    where: IntakeOutputWhereUniqueInput
    create: XOR<IntakeOutputCreateWithoutShiftInput, IntakeOutputUncheckedCreateWithoutShiftInput>
  }

  export type IntakeOutputCreateManyShiftInputEnvelope = {
    data: IntakeOutputCreateManyShiftInput | IntakeOutputCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type NurseCheckInCreateWithoutShiftInput = {
    id?: string
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutCheckInsInput
    user: UserCreateNestedOneWithoutCheckInsInput
  }

  export type NurseCheckInUncheckedCreateWithoutShiftInput = {
    id?: string
    patientId: string
    userId: string
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInCreateOrConnectWithoutShiftInput = {
    where: NurseCheckInWhereUniqueInput
    create: XOR<NurseCheckInCreateWithoutShiftInput, NurseCheckInUncheckedCreateWithoutShiftInput>
  }

  export type NurseCheckInCreateManyShiftInputEnvelope = {
    data: NurseCheckInCreateManyShiftInput | NurseCheckInCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutShiftsInput = {
    update: XOR<UserUpdateWithoutShiftsInput, UserUncheckedUpdateWithoutShiftsInput>
    create: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftsInput, UserUncheckedUpdateWithoutShiftsInput>
  }

  export type UserUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IntakeOutputUpsertWithWhereUniqueWithoutShiftInput = {
    where: IntakeOutputWhereUniqueInput
    update: XOR<IntakeOutputUpdateWithoutShiftInput, IntakeOutputUncheckedUpdateWithoutShiftInput>
    create: XOR<IntakeOutputCreateWithoutShiftInput, IntakeOutputUncheckedCreateWithoutShiftInput>
  }

  export type IntakeOutputUpdateWithWhereUniqueWithoutShiftInput = {
    where: IntakeOutputWhereUniqueInput
    data: XOR<IntakeOutputUpdateWithoutShiftInput, IntakeOutputUncheckedUpdateWithoutShiftInput>
  }

  export type IntakeOutputUpdateManyWithWhereWithoutShiftInput = {
    where: IntakeOutputScalarWhereInput
    data: XOR<IntakeOutputUpdateManyMutationInput, IntakeOutputUncheckedUpdateManyWithoutShiftInput>
  }

  export type NurseCheckInUpsertWithWhereUniqueWithoutShiftInput = {
    where: NurseCheckInWhereUniqueInput
    update: XOR<NurseCheckInUpdateWithoutShiftInput, NurseCheckInUncheckedUpdateWithoutShiftInput>
    create: XOR<NurseCheckInCreateWithoutShiftInput, NurseCheckInUncheckedCreateWithoutShiftInput>
  }

  export type NurseCheckInUpdateWithWhereUniqueWithoutShiftInput = {
    where: NurseCheckInWhereUniqueInput
    data: XOR<NurseCheckInUpdateWithoutShiftInput, NurseCheckInUncheckedUpdateWithoutShiftInput>
  }

  export type NurseCheckInUpdateManyWithWhereWithoutShiftInput = {
    where: NurseCheckInScalarWhereInput
    data: XOR<NurseCheckInUpdateManyMutationInput, NurseCheckInUncheckedUpdateManyWithoutShiftInput>
  }

  export type AdmissionCreateWithoutPatientInput = {
    id?: string
    bed?: string | null
    diagnosis?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
  }

  export type AdmissionUncheckedCreateWithoutPatientInput = {
    id?: string
    bed?: string | null
    diagnosis?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
  }

  export type AdmissionCreateOrConnectWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionCreateManyPatientInputEnvelope = {
    data: AdmissionCreateManyPatientInput | AdmissionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalNoteCreateWithoutPatientInput = {
    id?: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutNotesInput
  }

  export type ClinicalNoteUncheckedCreateWithoutPatientInput = {
    id?: string
    authorId: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalNoteCreateOrConnectWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    create: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalNoteCreateManyPatientInputEnvelope = {
    data: ClinicalNoteCreateManyPatientInput | ClinicalNoteCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type VitalSignCreateWithoutPatientInput = {
    id?: string
    heartRate?: number | null
    bpSys?: number | null
    bpDia?: number | null
    spo2?: number | null
    temp?: number | null
    rbs?: number | null
    timestamp?: Date | string
  }

  export type VitalSignUncheckedCreateWithoutPatientInput = {
    id?: string
    heartRate?: number | null
    bpSys?: number | null
    bpDia?: number | null
    spo2?: number | null
    temp?: number | null
    rbs?: number | null
    timestamp?: Date | string
  }

  export type VitalSignCreateOrConnectWithoutPatientInput = {
    where: VitalSignWhereUniqueInput
    create: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput>
  }

  export type VitalSignCreateManyPatientInputEnvelope = {
    data: VitalSignCreateManyPatientInput | VitalSignCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicationAdministrationCreateWithoutPatientInput = {
    id?: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    medication: MedicationCreateNestedOneWithoutAdministrationsInput
    user?: UserCreateNestedOneWithoutAdministeredMedsInput
  }

  export type MedicationAdministrationUncheckedCreateWithoutPatientInput = {
    id?: string
    medicationId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type MedicationAdministrationCreateOrConnectWithoutPatientInput = {
    where: MedicationAdministrationWhereUniqueInput
    create: XOR<MedicationAdministrationCreateWithoutPatientInput, MedicationAdministrationUncheckedCreateWithoutPatientInput>
  }

  export type MedicationAdministrationCreateManyPatientInputEnvelope = {
    data: MedicationAdministrationCreateManyPatientInput | MedicationAdministrationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicationCreateWithoutPatientInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
    administrations?: MedicationAdministrationCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateWithoutPatientInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
    administrations?: MedicationAdministrationUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationCreateOrConnectWithoutPatientInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput>
  }

  export type MedicationCreateManyPatientInputEnvelope = {
    data: MedicationCreateManyPatientInput | MedicationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type IntakeOutputCreateWithoutPatientInput = {
    id?: string
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutIoEntriesInput
    shift?: ShiftCreateNestedOneWithoutIoEntriesInput
  }

  export type IntakeOutputUncheckedCreateWithoutPatientInput = {
    id?: string
    userId: string
    shiftId?: string | null
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type IntakeOutputCreateOrConnectWithoutPatientInput = {
    where: IntakeOutputWhereUniqueInput
    create: XOR<IntakeOutputCreateWithoutPatientInput, IntakeOutputUncheckedCreateWithoutPatientInput>
  }

  export type IntakeOutputCreateManyPatientInputEnvelope = {
    data: IntakeOutputCreateManyPatientInput | IntakeOutputCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type NurseCheckInCreateWithoutPatientInput = {
    id?: string
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutCheckInsInput
    shift?: ShiftCreateNestedOneWithoutCheckInsInput
  }

  export type NurseCheckInUncheckedCreateWithoutPatientInput = {
    id?: string
    userId: string
    shiftId?: string | null
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInCreateOrConnectWithoutPatientInput = {
    where: NurseCheckInWhereUniqueInput
    create: XOR<NurseCheckInCreateWithoutPatientInput, NurseCheckInUncheckedCreateWithoutPatientInput>
  }

  export type NurseCheckInCreateManyPatientInputEnvelope = {
    data: NurseCheckInCreateManyPatientInput | NurseCheckInCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalOrderCreateWithoutPatientInput = {
    id?: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCreatedOrdersInput
    approver?: UserCreateNestedOneWithoutApprovedOrdersInput
    investigations?: InvestigationCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderUncheckedCreateWithoutPatientInput = {
    id?: string
    authorId: string
    approverId?: string | null
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investigations?: InvestigationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ClinicalOrderCreateOrConnectWithoutPatientInput = {
    where: ClinicalOrderWhereUniqueInput
    create: XOR<ClinicalOrderCreateWithoutPatientInput, ClinicalOrderUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalOrderCreateManyPatientInputEnvelope = {
    data: ClinicalOrderCreateManyPatientInput | ClinicalOrderCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvestigationCreateWithoutPatientInput = {
    id?: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
    order?: ClinicalOrderCreateNestedOneWithoutInvestigationsInput
    author: UserCreateNestedOneWithoutInvestigationsInput
  }

  export type InvestigationUncheckedCreateWithoutPatientInput = {
    id?: string
    orderId?: string | null
    authorId: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type InvestigationCreateOrConnectWithoutPatientInput = {
    where: InvestigationWhereUniqueInput
    create: XOR<InvestigationCreateWithoutPatientInput, InvestigationUncheckedCreateWithoutPatientInput>
  }

  export type InvestigationCreateManyPatientInputEnvelope = {
    data: InvestigationCreateManyPatientInput | InvestigationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type SpecialistNoteCreateWithoutPatientInput = {
    id?: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutSpecialistNotesInput
  }

  export type SpecialistNoteUncheckedCreateWithoutPatientInput = {
    id?: string
    authorId: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialistNoteCreateOrConnectWithoutPatientInput = {
    where: SpecialistNoteWhereUniqueInput
    create: XOR<SpecialistNoteCreateWithoutPatientInput, SpecialistNoteUncheckedCreateWithoutPatientInput>
  }

  export type SpecialistNoteCreateManyPatientInputEnvelope = {
    data: SpecialistNoteCreateManyPatientInput | SpecialistNoteCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionUpsertWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutPatientInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutPatientInput>
  }

  export type AdmissionScalarWhereInput = {
    AND?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    OR?: AdmissionScalarWhereInput[]
    NOT?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    id?: StringFilter<"Admission"> | string
    patientId?: StringFilter<"Admission"> | string
    bed?: StringNullableFilter<"Admission"> | string | null
    diagnosis?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
  }

  export type ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    update: XOR<ClinicalNoteUpdateWithoutPatientInput, ClinicalNoteUncheckedUpdateWithoutPatientInput>
    create: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    data: XOR<ClinicalNoteUpdateWithoutPatientInput, ClinicalNoteUncheckedUpdateWithoutPatientInput>
  }

  export type ClinicalNoteUpdateManyWithWhereWithoutPatientInput = {
    where: ClinicalNoteScalarWhereInput
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyWithoutPatientInput>
  }

  export type VitalSignUpsertWithWhereUniqueWithoutPatientInput = {
    where: VitalSignWhereUniqueInput
    update: XOR<VitalSignUpdateWithoutPatientInput, VitalSignUncheckedUpdateWithoutPatientInput>
    create: XOR<VitalSignCreateWithoutPatientInput, VitalSignUncheckedCreateWithoutPatientInput>
  }

  export type VitalSignUpdateWithWhereUniqueWithoutPatientInput = {
    where: VitalSignWhereUniqueInput
    data: XOR<VitalSignUpdateWithoutPatientInput, VitalSignUncheckedUpdateWithoutPatientInput>
  }

  export type VitalSignUpdateManyWithWhereWithoutPatientInput = {
    where: VitalSignScalarWhereInput
    data: XOR<VitalSignUpdateManyMutationInput, VitalSignUncheckedUpdateManyWithoutPatientInput>
  }

  export type VitalSignScalarWhereInput = {
    AND?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
    OR?: VitalSignScalarWhereInput[]
    NOT?: VitalSignScalarWhereInput | VitalSignScalarWhereInput[]
    id?: StringFilter<"VitalSign"> | string
    patientId?: StringFilter<"VitalSign"> | string
    heartRate?: IntNullableFilter<"VitalSign"> | number | null
    bpSys?: IntNullableFilter<"VitalSign"> | number | null
    bpDia?: IntNullableFilter<"VitalSign"> | number | null
    spo2?: IntNullableFilter<"VitalSign"> | number | null
    temp?: FloatNullableFilter<"VitalSign"> | number | null
    rbs?: FloatNullableFilter<"VitalSign"> | number | null
    timestamp?: DateTimeFilter<"VitalSign"> | Date | string
  }

  export type MedicationAdministrationUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicationAdministrationWhereUniqueInput
    update: XOR<MedicationAdministrationUpdateWithoutPatientInput, MedicationAdministrationUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicationAdministrationCreateWithoutPatientInput, MedicationAdministrationUncheckedCreateWithoutPatientInput>
  }

  export type MedicationAdministrationUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicationAdministrationWhereUniqueInput
    data: XOR<MedicationAdministrationUpdateWithoutPatientInput, MedicationAdministrationUncheckedUpdateWithoutPatientInput>
  }

  export type MedicationAdministrationUpdateManyWithWhereWithoutPatientInput = {
    where: MedicationAdministrationScalarWhereInput
    data: XOR<MedicationAdministrationUpdateManyMutationInput, MedicationAdministrationUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicationUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutPatientInput, MedicationUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicationCreateWithoutPatientInput, MedicationUncheckedCreateWithoutPatientInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutPatientInput, MedicationUncheckedUpdateWithoutPatientInput>
  }

  export type MedicationUpdateManyWithWhereWithoutPatientInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicationScalarWhereInput = {
    AND?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    OR?: MedicationScalarWhereInput[]
    NOT?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    id?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    defaultDose?: StringFilter<"Medication"> | string
    route?: StringFilter<"Medication"> | string
    frequency?: StringNullableFilter<"Medication"> | string | null
    infusionRate?: StringNullableFilter<"Medication"> | string | null
    otherInstructions?: StringNullableFilter<"Medication"> | string | null
    patientId?: StringNullableFilter<"Medication"> | string | null
  }

  export type IntakeOutputUpsertWithWhereUniqueWithoutPatientInput = {
    where: IntakeOutputWhereUniqueInput
    update: XOR<IntakeOutputUpdateWithoutPatientInput, IntakeOutputUncheckedUpdateWithoutPatientInput>
    create: XOR<IntakeOutputCreateWithoutPatientInput, IntakeOutputUncheckedCreateWithoutPatientInput>
  }

  export type IntakeOutputUpdateWithWhereUniqueWithoutPatientInput = {
    where: IntakeOutputWhereUniqueInput
    data: XOR<IntakeOutputUpdateWithoutPatientInput, IntakeOutputUncheckedUpdateWithoutPatientInput>
  }

  export type IntakeOutputUpdateManyWithWhereWithoutPatientInput = {
    where: IntakeOutputScalarWhereInput
    data: XOR<IntakeOutputUpdateManyMutationInput, IntakeOutputUncheckedUpdateManyWithoutPatientInput>
  }

  export type NurseCheckInUpsertWithWhereUniqueWithoutPatientInput = {
    where: NurseCheckInWhereUniqueInput
    update: XOR<NurseCheckInUpdateWithoutPatientInput, NurseCheckInUncheckedUpdateWithoutPatientInput>
    create: XOR<NurseCheckInCreateWithoutPatientInput, NurseCheckInUncheckedCreateWithoutPatientInput>
  }

  export type NurseCheckInUpdateWithWhereUniqueWithoutPatientInput = {
    where: NurseCheckInWhereUniqueInput
    data: XOR<NurseCheckInUpdateWithoutPatientInput, NurseCheckInUncheckedUpdateWithoutPatientInput>
  }

  export type NurseCheckInUpdateManyWithWhereWithoutPatientInput = {
    where: NurseCheckInScalarWhereInput
    data: XOR<NurseCheckInUpdateManyMutationInput, NurseCheckInUncheckedUpdateManyWithoutPatientInput>
  }

  export type ClinicalOrderUpsertWithWhereUniqueWithoutPatientInput = {
    where: ClinicalOrderWhereUniqueInput
    update: XOR<ClinicalOrderUpdateWithoutPatientInput, ClinicalOrderUncheckedUpdateWithoutPatientInput>
    create: XOR<ClinicalOrderCreateWithoutPatientInput, ClinicalOrderUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalOrderUpdateWithWhereUniqueWithoutPatientInput = {
    where: ClinicalOrderWhereUniqueInput
    data: XOR<ClinicalOrderUpdateWithoutPatientInput, ClinicalOrderUncheckedUpdateWithoutPatientInput>
  }

  export type ClinicalOrderUpdateManyWithWhereWithoutPatientInput = {
    where: ClinicalOrderScalarWhereInput
    data: XOR<ClinicalOrderUpdateManyMutationInput, ClinicalOrderUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvestigationUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvestigationWhereUniqueInput
    update: XOR<InvestigationUpdateWithoutPatientInput, InvestigationUncheckedUpdateWithoutPatientInput>
    create: XOR<InvestigationCreateWithoutPatientInput, InvestigationUncheckedCreateWithoutPatientInput>
  }

  export type InvestigationUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvestigationWhereUniqueInput
    data: XOR<InvestigationUpdateWithoutPatientInput, InvestigationUncheckedUpdateWithoutPatientInput>
  }

  export type InvestigationUpdateManyWithWhereWithoutPatientInput = {
    where: InvestigationScalarWhereInput
    data: XOR<InvestigationUpdateManyMutationInput, InvestigationUncheckedUpdateManyWithoutPatientInput>
  }

  export type SpecialistNoteUpsertWithWhereUniqueWithoutPatientInput = {
    where: SpecialistNoteWhereUniqueInput
    update: XOR<SpecialistNoteUpdateWithoutPatientInput, SpecialistNoteUncheckedUpdateWithoutPatientInput>
    create: XOR<SpecialistNoteCreateWithoutPatientInput, SpecialistNoteUncheckedCreateWithoutPatientInput>
  }

  export type SpecialistNoteUpdateWithWhereUniqueWithoutPatientInput = {
    where: SpecialistNoteWhereUniqueInput
    data: XOR<SpecialistNoteUpdateWithoutPatientInput, SpecialistNoteUncheckedUpdateWithoutPatientInput>
  }

  export type SpecialistNoteUpdateManyWithWhereWithoutPatientInput = {
    where: SpecialistNoteScalarWhereInput
    data: XOR<SpecialistNoteUpdateManyMutationInput, SpecialistNoteUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientCreateWithoutAdmissionsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAdmissionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
  }

  export type PatientUpsertWithoutAdmissionsInput = {
    update: XOR<PatientUpdateWithoutAdmissionsInput, PatientUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAdmissionsInput, PatientUncheckedUpdateWithoutAdmissionsInput>
  }

  export type PatientUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutNotesInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutNotesInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutNotesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutNotesInput, PatientUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type PatientUpsertWithoutNotesInput = {
    update: XOR<PatientUpdateWithoutNotesInput, PatientUncheckedUpdateWithoutNotesInput>
    create: XOR<PatientCreateWithoutNotesInput, PatientUncheckedCreateWithoutNotesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutNotesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutNotesInput, PatientUncheckedUpdateWithoutNotesInput>
  }

  export type PatientUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
  }

  export type UserUpsertWithoutAuditsInput = {
    update: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
    create: XOR<UserCreateWithoutAuditsInput, UserUncheckedCreateWithoutAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditsInput, UserUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PatientCreateWithoutVitalsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutVitalsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutVitalsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutVitalsInput, PatientUncheckedCreateWithoutVitalsInput>
  }

  export type PatientUpsertWithoutVitalsInput = {
    update: XOR<PatientUpdateWithoutVitalsInput, PatientUncheckedUpdateWithoutVitalsInput>
    create: XOR<PatientCreateWithoutVitalsInput, PatientUncheckedCreateWithoutVitalsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutVitalsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutVitalsInput, PatientUncheckedUpdateWithoutVitalsInput>
  }

  export type PatientUpdateWithoutVitalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutVitalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutPrescriptionsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
  }

  export type MedicationAdministrationCreateWithoutMedicationInput = {
    id?: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    patient: PatientCreateNestedOneWithoutMedicationsInput
    user?: UserCreateNestedOneWithoutAdministeredMedsInput
  }

  export type MedicationAdministrationUncheckedCreateWithoutMedicationInput = {
    id?: string
    patientId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type MedicationAdministrationCreateOrConnectWithoutMedicationInput = {
    where: MedicationAdministrationWhereUniqueInput
    create: XOR<MedicationAdministrationCreateWithoutMedicationInput, MedicationAdministrationUncheckedCreateWithoutMedicationInput>
  }

  export type MedicationAdministrationCreateManyMedicationInputEnvelope = {
    data: MedicationAdministrationCreateManyMedicationInput | MedicationAdministrationCreateManyMedicationInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutPrescriptionsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicationAdministrationUpsertWithWhereUniqueWithoutMedicationInput = {
    where: MedicationAdministrationWhereUniqueInput
    update: XOR<MedicationAdministrationUpdateWithoutMedicationInput, MedicationAdministrationUncheckedUpdateWithoutMedicationInput>
    create: XOR<MedicationAdministrationCreateWithoutMedicationInput, MedicationAdministrationUncheckedCreateWithoutMedicationInput>
  }

  export type MedicationAdministrationUpdateWithWhereUniqueWithoutMedicationInput = {
    where: MedicationAdministrationWhereUniqueInput
    data: XOR<MedicationAdministrationUpdateWithoutMedicationInput, MedicationAdministrationUncheckedUpdateWithoutMedicationInput>
  }

  export type MedicationAdministrationUpdateManyWithWhereWithoutMedicationInput = {
    where: MedicationAdministrationScalarWhereInput
    data: XOR<MedicationAdministrationUpdateManyMutationInput, MedicationAdministrationUncheckedUpdateManyWithoutMedicationInput>
  }

  export type PatientCreateWithoutMedicationsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicationsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
  }

  export type MedicationCreateWithoutAdministrationsInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
    patient?: PatientCreateNestedOneWithoutPrescriptionsInput
  }

  export type MedicationUncheckedCreateWithoutAdministrationsInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
    patientId?: string | null
  }

  export type MedicationCreateOrConnectWithoutAdministrationsInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutAdministrationsInput, MedicationUncheckedCreateWithoutAdministrationsInput>
  }

  export type UserCreateWithoutAdministeredMedsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAdministeredMedsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAdministeredMedsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdministeredMedsInput, UserUncheckedCreateWithoutAdministeredMedsInput>
  }

  export type PatientUpsertWithoutMedicationsInput = {
    update: XOR<PatientUpdateWithoutMedicationsInput, PatientUncheckedUpdateWithoutMedicationsInput>
    create: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicationsInput, PatientUncheckedUpdateWithoutMedicationsInput>
  }

  export type PatientUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicationUpsertWithoutAdministrationsInput = {
    update: XOR<MedicationUpdateWithoutAdministrationsInput, MedicationUncheckedUpdateWithoutAdministrationsInput>
    create: XOR<MedicationCreateWithoutAdministrationsInput, MedicationUncheckedCreateWithoutAdministrationsInput>
    where?: MedicationWhereInput
  }

  export type MedicationUpdateToOneWithWhereWithoutAdministrationsInput = {
    where?: MedicationWhereInput
    data: XOR<MedicationUpdateWithoutAdministrationsInput, MedicationUncheckedUpdateWithoutAdministrationsInput>
  }

  export type MedicationUpdateWithoutAdministrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneWithoutPrescriptionsNestedInput
  }

  export type MedicationUncheckedUpdateWithoutAdministrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutAdministeredMedsInput = {
    update: XOR<UserUpdateWithoutAdministeredMedsInput, UserUncheckedUpdateWithoutAdministeredMedsInput>
    create: XOR<UserCreateWithoutAdministeredMedsInput, UserUncheckedCreateWithoutAdministeredMedsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdministeredMedsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdministeredMedsInput, UserUncheckedUpdateWithoutAdministeredMedsInput>
  }

  export type UserUpdateWithoutAdministeredMedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAdministeredMedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PatientCreateWithoutIoEntriesInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutIoEntriesInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutIoEntriesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutIoEntriesInput, PatientUncheckedCreateWithoutIoEntriesInput>
  }

  export type UserCreateWithoutIoEntriesInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIoEntriesInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIoEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIoEntriesInput, UserUncheckedCreateWithoutIoEntriesInput>
  }

  export type ShiftCreateWithoutIoEntriesInput = {
    id?: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutShiftsInput
    checkIns?: NurseCheckInCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutIoEntriesInput = {
    id?: string
    userId: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutIoEntriesInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutIoEntriesInput, ShiftUncheckedCreateWithoutIoEntriesInput>
  }

  export type PatientUpsertWithoutIoEntriesInput = {
    update: XOR<PatientUpdateWithoutIoEntriesInput, PatientUncheckedUpdateWithoutIoEntriesInput>
    create: XOR<PatientCreateWithoutIoEntriesInput, PatientUncheckedCreateWithoutIoEntriesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutIoEntriesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutIoEntriesInput, PatientUncheckedUpdateWithoutIoEntriesInput>
  }

  export type PatientUpdateWithoutIoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutIoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutIoEntriesInput = {
    update: XOR<UserUpdateWithoutIoEntriesInput, UserUncheckedUpdateWithoutIoEntriesInput>
    create: XOR<UserCreateWithoutIoEntriesInput, UserUncheckedCreateWithoutIoEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIoEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIoEntriesInput, UserUncheckedUpdateWithoutIoEntriesInput>
  }

  export type UserUpdateWithoutIoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShiftUpsertWithoutIoEntriesInput = {
    update: XOR<ShiftUpdateWithoutIoEntriesInput, ShiftUncheckedUpdateWithoutIoEntriesInput>
    create: XOR<ShiftCreateWithoutIoEntriesInput, ShiftUncheckedCreateWithoutIoEntriesInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutIoEntriesInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutIoEntriesInput, ShiftUncheckedUpdateWithoutIoEntriesInput>
  }

  export type ShiftUpdateWithoutIoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutIoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type PatientCreateWithoutCheckInsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutCheckInsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutCheckInsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutCheckInsInput, PatientUncheckedCreateWithoutCheckInsInput>
  }

  export type UserCreateWithoutCheckInsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCheckInsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCheckInsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
  }

  export type ShiftCreateWithoutCheckInsInput = {
    id?: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutShiftsInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutCheckInsInput = {
    id?: string
    userId: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutCheckInsInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutCheckInsInput, ShiftUncheckedCreateWithoutCheckInsInput>
  }

  export type PatientUpsertWithoutCheckInsInput = {
    update: XOR<PatientUpdateWithoutCheckInsInput, PatientUncheckedUpdateWithoutCheckInsInput>
    create: XOR<PatientCreateWithoutCheckInsInput, PatientUncheckedCreateWithoutCheckInsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutCheckInsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutCheckInsInput, PatientUncheckedUpdateWithoutCheckInsInput>
  }

  export type PatientUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutCheckInsInput = {
    update: XOR<UserUpdateWithoutCheckInsInput, UserUncheckedUpdateWithoutCheckInsInput>
    create: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCheckInsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCheckInsInput, UserUncheckedUpdateWithoutCheckInsInput>
  }

  export type UserUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShiftUpsertWithoutCheckInsInput = {
    update: XOR<ShiftUpdateWithoutCheckInsInput, ShiftUncheckedUpdateWithoutCheckInsInput>
    create: XOR<ShiftCreateWithoutCheckInsInput, ShiftUncheckedCreateWithoutCheckInsInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutCheckInsInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutCheckInsInput, ShiftUncheckedUpdateWithoutCheckInsInput>
  }

  export type ShiftUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type PatientCreateWithoutOrdersInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutOrdersInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutOrdersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutOrdersInput, PatientUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutCreatedOrdersInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedOrdersInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
  }

  export type UserCreateWithoutApprovedOrdersInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovedOrdersInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovedOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedOrdersInput, UserUncheckedCreateWithoutApprovedOrdersInput>
  }

  export type InvestigationCreateWithoutOrderInput = {
    id?: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutInvestigationsInput
    author: UserCreateNestedOneWithoutInvestigationsInput
  }

  export type InvestigationUncheckedCreateWithoutOrderInput = {
    id?: string
    patientId: string
    authorId: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type InvestigationCreateOrConnectWithoutOrderInput = {
    where: InvestigationWhereUniqueInput
    create: XOR<InvestigationCreateWithoutOrderInput, InvestigationUncheckedCreateWithoutOrderInput>
  }

  export type InvestigationCreateManyOrderInputEnvelope = {
    data: InvestigationCreateManyOrderInput | InvestigationCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutOrdersInput = {
    update: XOR<PatientUpdateWithoutOrdersInput, PatientUncheckedUpdateWithoutOrdersInput>
    create: XOR<PatientCreateWithoutOrdersInput, PatientUncheckedCreateWithoutOrdersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutOrdersInput, PatientUncheckedUpdateWithoutOrdersInput>
  }

  export type PatientUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutCreatedOrdersInput = {
    update: XOR<UserUpdateWithoutCreatedOrdersInput, UserUncheckedUpdateWithoutCreatedOrdersInput>
    create: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedOrdersInput, UserUncheckedUpdateWithoutCreatedOrdersInput>
  }

  export type UserUpdateWithoutCreatedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutApprovedOrdersInput = {
    update: XOR<UserUpdateWithoutApprovedOrdersInput, UserUncheckedUpdateWithoutApprovedOrdersInput>
    create: XOR<UserCreateWithoutApprovedOrdersInput, UserUncheckedCreateWithoutApprovedOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedOrdersInput, UserUncheckedUpdateWithoutApprovedOrdersInput>
  }

  export type UserUpdateWithoutApprovedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvestigationUpsertWithWhereUniqueWithoutOrderInput = {
    where: InvestigationWhereUniqueInput
    update: XOR<InvestigationUpdateWithoutOrderInput, InvestigationUncheckedUpdateWithoutOrderInput>
    create: XOR<InvestigationCreateWithoutOrderInput, InvestigationUncheckedCreateWithoutOrderInput>
  }

  export type InvestigationUpdateWithWhereUniqueWithoutOrderInput = {
    where: InvestigationWhereUniqueInput
    data: XOR<InvestigationUpdateWithoutOrderInput, InvestigationUncheckedUpdateWithoutOrderInput>
  }

  export type InvestigationUpdateManyWithWhereWithoutOrderInput = {
    where: InvestigationScalarWhereInput
    data: XOR<InvestigationUpdateManyMutationInput, InvestigationUncheckedUpdateManyWithoutOrderInput>
  }

  export type PatientCreateWithoutSpecialistNotesInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    investigations?: InvestigationCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutSpecialistNotesInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutSpecialistNotesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutSpecialistNotesInput, PatientUncheckedCreateWithoutSpecialistNotesInput>
  }

  export type UserCreateWithoutSpecialistNotesInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    investigations?: InvestigationCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSpecialistNotesInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    investigations?: InvestigationUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSpecialistNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpecialistNotesInput, UserUncheckedCreateWithoutSpecialistNotesInput>
  }

  export type PatientUpsertWithoutSpecialistNotesInput = {
    update: XOR<PatientUpdateWithoutSpecialistNotesInput, PatientUncheckedUpdateWithoutSpecialistNotesInput>
    create: XOR<PatientCreateWithoutSpecialistNotesInput, PatientUncheckedCreateWithoutSpecialistNotesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutSpecialistNotesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutSpecialistNotesInput, PatientUncheckedUpdateWithoutSpecialistNotesInput>
  }

  export type PatientUpdateWithoutSpecialistNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutSpecialistNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutSpecialistNotesInput = {
    update: XOR<UserUpdateWithoutSpecialistNotesInput, UserUncheckedUpdateWithoutSpecialistNotesInput>
    create: XOR<UserCreateWithoutSpecialistNotesInput, UserUncheckedCreateWithoutSpecialistNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpecialistNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpecialistNotesInput, UserUncheckedUpdateWithoutSpecialistNotesInput>
  }

  export type UserUpdateWithoutSpecialistNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSpecialistNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    investigations?: InvestigationUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PatientCreateWithoutInvestigationsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    vitals?: VitalSignCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvestigationsInput = {
    id?: string
    mrn: string
    firstName: string
    lastName: string
    dob: Date | string
    gender: string
    comorbidities?: PatientCreatecomorbiditiesInput | string[]
    diagnosis?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    vitals?: VitalSignUncheckedCreateNestedManyWithoutPatientInput
    medications?: MedicationAdministrationUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: MedicationUncheckedCreateNestedManyWithoutPatientInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutPatientInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutPatientInput
    orders?: ClinicalOrderUncheckedCreateNestedManyWithoutPatientInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvestigationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvestigationsInput, PatientUncheckedCreateWithoutInvestigationsInput>
  }

  export type ClinicalOrderCreateWithoutInvestigationsInput = {
    id?: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutOrdersInput
    author: UserCreateNestedOneWithoutCreatedOrdersInput
    approver?: UserCreateNestedOneWithoutApprovedOrdersInput
  }

  export type ClinicalOrderUncheckedCreateWithoutInvestigationsInput = {
    id?: string
    patientId: string
    authorId: string
    approverId?: string | null
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalOrderCreateOrConnectWithoutInvestigationsInput = {
    where: ClinicalOrderWhereUniqueInput
    create: XOR<ClinicalOrderCreateWithoutInvestigationsInput, ClinicalOrderUncheckedCreateWithoutInvestigationsInput>
  }

  export type UserCreateWithoutInvestigationsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteCreateNestedManyWithoutAuthorInput
    audits?: AuditLogCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderCreateNestedManyWithoutApproverInput
    specialistNotes?: SpecialistNoteCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestigationsInput = {
    id?: string
    name: string
    username: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    notes?: ClinicalNoteUncheckedCreateNestedManyWithoutAuthorInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    ioEntries?: IntakeOutputUncheckedCreateNestedManyWithoutUserInput
    checkIns?: NurseCheckInUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutAuthorInput
    approvedOrders?: ClinicalOrderUncheckedCreateNestedManyWithoutApproverInput
    specialistNotes?: SpecialistNoteUncheckedCreateNestedManyWithoutAuthorInput
    administeredMeds?: MedicationAdministrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestigationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestigationsInput, UserUncheckedCreateWithoutInvestigationsInput>
  }

  export type PatientUpsertWithoutInvestigationsInput = {
    update: XOR<PatientUpdateWithoutInvestigationsInput, PatientUncheckedUpdateWithoutInvestigationsInput>
    create: XOR<PatientCreateWithoutInvestigationsInput, PatientUncheckedCreateWithoutInvestigationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvestigationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvestigationsInput, PatientUncheckedUpdateWithoutInvestigationsInput>
  }

  export type PatientUpdateWithoutInvestigationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvestigationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrn?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    comorbidities?: PatientUpdatecomorbiditiesInput | string[]
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    vitals?: VitalSignUncheckedUpdateManyWithoutPatientNestedInput
    medications?: MedicationAdministrationUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: MedicationUncheckedUpdateManyWithoutPatientNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutPatientNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutPatientNestedInput
    orders?: ClinicalOrderUncheckedUpdateManyWithoutPatientNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ClinicalOrderUpsertWithoutInvestigationsInput = {
    update: XOR<ClinicalOrderUpdateWithoutInvestigationsInput, ClinicalOrderUncheckedUpdateWithoutInvestigationsInput>
    create: XOR<ClinicalOrderCreateWithoutInvestigationsInput, ClinicalOrderUncheckedCreateWithoutInvestigationsInput>
    where?: ClinicalOrderWhereInput
  }

  export type ClinicalOrderUpdateToOneWithWhereWithoutInvestigationsInput = {
    where?: ClinicalOrderWhereInput
    data: XOR<ClinicalOrderUpdateWithoutInvestigationsInput, ClinicalOrderUncheckedUpdateWithoutInvestigationsInput>
  }

  export type ClinicalOrderUpdateWithoutInvestigationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutOrdersNestedInput
    author?: UserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    approver?: UserUpdateOneWithoutApprovedOrdersNestedInput
  }

  export type ClinicalOrderUncheckedUpdateWithoutInvestigationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutInvestigationsInput = {
    update: XOR<UserUpdateWithoutInvestigationsInput, UserUncheckedUpdateWithoutInvestigationsInput>
    create: XOR<UserCreateWithoutInvestigationsInput, UserUncheckedCreateWithoutInvestigationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestigationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestigationsInput, UserUncheckedUpdateWithoutInvestigationsInput>
  }

  export type UserUpdateWithoutInvestigationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUpdateManyWithoutApproverNestedInput
    specialistNotes?: SpecialistNoteUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestigationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    notes?: ClinicalNoteUncheckedUpdateManyWithoutAuthorNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: ClinicalOrderUncheckedUpdateManyWithoutAuthorNestedInput
    approvedOrders?: ClinicalOrderUncheckedUpdateManyWithoutApproverNestedInput
    specialistNotes?: SpecialistNoteUncheckedUpdateManyWithoutAuthorNestedInput
    administeredMeds?: MedicationAdministrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShiftCreateManyUserInput = {
    id?: string
    type: $Enums.ShiftType
    startTime?: Date | string
    endTime?: Date | string | null
    isActive?: boolean
  }

  export type ClinicalNoteCreateManyAuthorInput = {
    id?: string
    patientId: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    details?: string | null
    timestamp?: Date | string
  }

  export type IntakeOutputCreateManyUserInput = {
    id?: string
    patientId: string
    shiftId?: string | null
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInCreateManyUserInput = {
    id?: string
    patientId: string
    shiftId?: string | null
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type ClinicalOrderCreateManyAuthorInput = {
    id?: string
    patientId: string
    approverId?: string | null
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalOrderCreateManyApproverInput = {
    id?: string
    patientId: string
    authorId: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestigationCreateManyAuthorInput = {
    id?: string
    patientId: string
    orderId?: string | null
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type SpecialistNoteCreateManyAuthorInput = {
    id?: string
    patientId: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationAdministrationCreateManyUserInput = {
    id?: string
    patientId: string
    medicationId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
  }

  export type ShiftUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ioEntries?: IntakeOutputUpdateManyWithoutShiftNestedInput
    checkIns?: NurseCheckInUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ioEntries?: IntakeOutputUncheckedUpdateManyWithoutShiftNestedInput
    checkIns?: NurseCheckInUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumShiftTypeFieldUpdateOperationsInput | $Enums.ShiftType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntakeOutputUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutIoEntriesNestedInput
    shift?: ShiftUpdateOneWithoutIoEntriesNestedInput
  }

  export type IntakeOutputUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntakeOutputUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutCheckInsNestedInput
    shift?: ShiftUpdateOneWithoutCheckInsNestedInput
  }

  export type NurseCheckInUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalOrderUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutOrdersNestedInput
    approver?: UserUpdateOneWithoutApprovedOrdersNestedInput
    investigations?: InvestigationUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigations?: InvestigationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalOrderUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutOrdersNestedInput
    author?: UserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    investigations?: InvestigationUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigations?: InvestigationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvestigationsNestedInput
    order?: ClinicalOrderUpdateOneWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialistNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutSpecialistNotesNestedInput
  }

  export type SpecialistNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialistNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicationsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutAdministrationsNestedInput
  }

  export type MedicationAdministrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntakeOutputCreateManyShiftInput = {
    id?: string
    patientId: string
    userId: string
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInCreateManyShiftInput = {
    id?: string
    patientId: string
    userId: string
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type IntakeOutputUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutIoEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutIoEntriesNestedInput
  }

  export type IntakeOutputUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntakeOutputUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutCheckInsNestedInput
    user?: UserUpdateOneRequiredWithoutCheckInsNestedInput
  }

  export type NurseCheckInUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateManyPatientInput = {
    id?: string
    bed?: string | null
    diagnosis?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
  }

  export type ClinicalNoteCreateManyPatientInput = {
    id?: string
    authorId: string
    type: $Enums.NoteType
    title: string
    content: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VitalSignCreateManyPatientInput = {
    id?: string
    heartRate?: number | null
    bpSys?: number | null
    bpDia?: number | null
    spo2?: number | null
    temp?: number | null
    rbs?: number | null
    timestamp?: Date | string
  }

  export type MedicationAdministrationCreateManyPatientInput = {
    id?: string
    medicationId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type MedicationCreateManyPatientInput = {
    id?: string
    name: string
    defaultDose: string
    route: string
    frequency?: string | null
    infusionRate?: string | null
    otherInstructions?: string | null
  }

  export type IntakeOutputCreateManyPatientInput = {
    id?: string
    userId: string
    shiftId?: string | null
    type: string
    category: string
    amount: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type NurseCheckInCreateManyPatientInput = {
    id?: string
    userId: string
    shiftId?: string | null
    airwaySafe?: boolean
    breathingOk?: boolean
    circulationOk?: boolean
    notes?: string | null
    timestamp?: Date | string
  }

  export type ClinicalOrderCreateManyPatientInput = {
    id?: string
    authorId: string
    approverId?: string | null
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    priority?: $Enums.Priority
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestigationCreateManyPatientInput = {
    id?: string
    orderId?: string | null
    authorId: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type SpecialistNoteCreateManyPatientInput = {
    id?: string
    authorId: string
    date?: Date | string
    apacheScore?: string | null
    histHT?: boolean
    histDM?: boolean
    histAsthma?: boolean
    histCOPD?: boolean
    histIHD?: boolean
    histStroke?: boolean
    histOther?: string | null
    neuroGCS?: string | null
    neuroRASS?: string | null
    respChest?: string | null
    respRoomAir?: boolean
    respO2Therapy?: boolean
    respVentMode?: boolean
    respVentModeText?: string | null
    respFio2?: string | null
    respPS?: string | null
    intCVLine?: boolean
    intArtLine?: boolean
    intETT?: boolean
    intTrach?: boolean
    intDoubleLumen?: boolean
    hydNormovolemia?: boolean
    hydHypervolemia?: boolean
    hydHypovolemia?: boolean
    hydUOP?: string | null
    hydIVC?: string | null
    hydCVP?: string | null
    hemoStable?: boolean
    hemoUnstable?: boolean
    hemoVasopressor?: boolean
    feedOral?: boolean
    feedNG?: boolean
    feedTPN?: boolean
    feedRate?: string | null
    ivFluidsRate?: string | null
    sedPropofol?: boolean
    sedKetamine?: boolean
    sedMidazolam?: boolean
    sedRemif?: boolean
    sedMR?: boolean
    sedOther?: string | null
    clinicalNotes?: string | null
    planVentilatory?: string | null
    planPhysio?: string | null
    planConsult?: string | null
    planInvestigation?: string | null
    planOther?: string | null
    planFuture?: string | null
    planHomeTeam?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    bed?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdmissionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    bed?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    bed?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicalNoteUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    bpSys?: NullableIntFieldUpdateOperationsInput | number | null
    bpDia?: NullableIntFieldUpdateOperationsInput | number | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    temp?: NullableFloatFieldUpdateOperationsInput | number | null
    rbs?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    bpSys?: NullableIntFieldUpdateOperationsInput | number | null
    bpDia?: NullableIntFieldUpdateOperationsInput | number | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    temp?: NullableFloatFieldUpdateOperationsInput | number | null
    rbs?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    bpSys?: NullableIntFieldUpdateOperationsInput | number | null
    bpDia?: NullableIntFieldUpdateOperationsInput | number | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    temp?: NullableFloatFieldUpdateOperationsInput | number | null
    rbs?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: MedicationUpdateOneRequiredWithoutAdministrationsNestedInput
    user?: UserUpdateOneWithoutAdministeredMedsNestedInput
  }

  export type MedicationAdministrationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    administrations?: MedicationAdministrationUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    administrations?: MedicationAdministrationUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    defaultDose?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    infusionRate?: NullableStringFieldUpdateOperationsInput | string | null
    otherInstructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntakeOutputUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIoEntriesNestedInput
    shift?: ShiftUpdateOneWithoutIoEntriesNestedInput
  }

  export type IntakeOutputUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntakeOutputUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCheckInsNestedInput
    shift?: ShiftUpdateOneWithoutCheckInsNestedInput
  }

  export type NurseCheckInUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NurseCheckInUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    airwaySafe?: BoolFieldUpdateOperationsInput | boolean
    breathingOk?: BoolFieldUpdateOperationsInput | boolean
    circulationOk?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalOrderUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    approver?: UserUpdateOneWithoutApprovedOrdersNestedInput
    investigations?: InvestigationUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigations?: InvestigationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ClinicalOrderUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: ClinicalOrderUpdateOneWithoutInvestigationsNestedInput
    author?: UserUpdateOneRequiredWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialistNoteUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutSpecialistNotesNestedInput
  }

  export type SpecialistNoteUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialistNoteUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    apacheScore?: NullableStringFieldUpdateOperationsInput | string | null
    histHT?: BoolFieldUpdateOperationsInput | boolean
    histDM?: BoolFieldUpdateOperationsInput | boolean
    histAsthma?: BoolFieldUpdateOperationsInput | boolean
    histCOPD?: BoolFieldUpdateOperationsInput | boolean
    histIHD?: BoolFieldUpdateOperationsInput | boolean
    histStroke?: BoolFieldUpdateOperationsInput | boolean
    histOther?: NullableStringFieldUpdateOperationsInput | string | null
    neuroGCS?: NullableStringFieldUpdateOperationsInput | string | null
    neuroRASS?: NullableStringFieldUpdateOperationsInput | string | null
    respChest?: NullableStringFieldUpdateOperationsInput | string | null
    respRoomAir?: BoolFieldUpdateOperationsInput | boolean
    respO2Therapy?: BoolFieldUpdateOperationsInput | boolean
    respVentMode?: BoolFieldUpdateOperationsInput | boolean
    respVentModeText?: NullableStringFieldUpdateOperationsInput | string | null
    respFio2?: NullableStringFieldUpdateOperationsInput | string | null
    respPS?: NullableStringFieldUpdateOperationsInput | string | null
    intCVLine?: BoolFieldUpdateOperationsInput | boolean
    intArtLine?: BoolFieldUpdateOperationsInput | boolean
    intETT?: BoolFieldUpdateOperationsInput | boolean
    intTrach?: BoolFieldUpdateOperationsInput | boolean
    intDoubleLumen?: BoolFieldUpdateOperationsInput | boolean
    hydNormovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypervolemia?: BoolFieldUpdateOperationsInput | boolean
    hydHypovolemia?: BoolFieldUpdateOperationsInput | boolean
    hydUOP?: NullableStringFieldUpdateOperationsInput | string | null
    hydIVC?: NullableStringFieldUpdateOperationsInput | string | null
    hydCVP?: NullableStringFieldUpdateOperationsInput | string | null
    hemoStable?: BoolFieldUpdateOperationsInput | boolean
    hemoUnstable?: BoolFieldUpdateOperationsInput | boolean
    hemoVasopressor?: BoolFieldUpdateOperationsInput | boolean
    feedOral?: BoolFieldUpdateOperationsInput | boolean
    feedNG?: BoolFieldUpdateOperationsInput | boolean
    feedTPN?: BoolFieldUpdateOperationsInput | boolean
    feedRate?: NullableStringFieldUpdateOperationsInput | string | null
    ivFluidsRate?: NullableStringFieldUpdateOperationsInput | string | null
    sedPropofol?: BoolFieldUpdateOperationsInput | boolean
    sedKetamine?: BoolFieldUpdateOperationsInput | boolean
    sedMidazolam?: BoolFieldUpdateOperationsInput | boolean
    sedRemif?: BoolFieldUpdateOperationsInput | boolean
    sedMR?: BoolFieldUpdateOperationsInput | boolean
    sedOther?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    planVentilatory?: NullableStringFieldUpdateOperationsInput | string | null
    planPhysio?: NullableStringFieldUpdateOperationsInput | string | null
    planConsult?: NullableStringFieldUpdateOperationsInput | string | null
    planInvestigation?: NullableStringFieldUpdateOperationsInput | string | null
    planOther?: NullableStringFieldUpdateOperationsInput | string | null
    planFuture?: NullableStringFieldUpdateOperationsInput | string | null
    planHomeTeam?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationAdministrationCreateManyMedicationInput = {
    id?: string
    patientId: string
    status: string
    dose?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type MedicationAdministrationUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicationsNestedInput
    user?: UserUpdateOneWithoutAdministeredMedsNestedInput
  }

  export type MedicationAdministrationUncheckedUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicationAdministrationUncheckedUpdateManyWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvestigationCreateManyOrderInput = {
    id?: string
    patientId: string
    authorId: string
    type: $Enums.OrderType
    category: string
    title: string
    status?: $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: string | null
    conductedAt?: Date | string
    createdAt?: Date | string
  }

  export type InvestigationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInvestigationsNestedInput
    author?: UserUpdateOneRequiredWithoutInvestigationsNestedInput
  }

  export type InvestigationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestigationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumInvestigationStatusFieldUpdateOperationsInput | $Enums.InvestigationStatus
    result?: NullableJsonNullValueInput | InputJsonValue
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conductedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}